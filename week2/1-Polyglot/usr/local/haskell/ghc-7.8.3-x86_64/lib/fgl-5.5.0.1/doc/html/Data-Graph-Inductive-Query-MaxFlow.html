<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Graph.Inductive.Query.MaxFlow</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Graph-Inductive-Query-MaxFlow.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-Graph-Inductive-Query-MaxFlow.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">fgl-5.5.0.1: Martin Erwig's Functional Graph Library</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.Graph.Inductive.Query.MaxFlow</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Maximum Flow algorithm
 We are given a flow network G=(V,E) with source s and sink t where each
 edge (u,v) in E has a nonnegative capacity c(u,v)&gt;=0, and we wish to
 find a flow of maximum value from s to t.</p><p>A flow in G=(V,E) is a real-valued function f:VxV-&gt;R that satisfies:</p><pre>For all u,v in V, f(u,v)&lt;=c(u,v)
For all u,v in V, f(u,v)=-f(v,u)
For all u in V-{s,t}, Sum{f(u,v):v in V } = 0
</pre><p>The value of a flow f is defined as |f|=Sum {f(s,v)|v in V}, i.e.,
 the total net flow out of the source.</p><p>In this module we implement the Edmonds-Karp algorithm, which is the
 Ford-Fulkerson method but using the shortest path from s to t as the
 augmenting path along which the flow is incremented.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:getRevEdges">getRevEdges</a> :: (<a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; [(<a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>, <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>)] -&gt; [(<a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>, <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>, b)]</li><li class="src short"><a href="#v:augmentGraph">augmentGraph</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; gr a b -&gt; gr a (b, b, b)</li><li class="src short"><a href="#v:updAdjList">updAdjList</a> :: (<a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; [((b, b, b), <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>)] -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; b -&gt; <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Bool.html#t:Bool">Bool</a> -&gt; [((b, b, b), <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>)]</li><li class="src short"><a href="#v:updateFlow">updateFlow</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; <a href="Data-Graph-Inductive-Graph.html#t:Path">Path</a> -&gt; b -&gt; gr a (b, b, b) -&gt; gr a (b, b, b)</li><li class="src short"><a href="#v:mfmg">mfmg</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; gr a (b, b, b) -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; gr a (b, b, b)</li><li class="src short"><a href="#v:mf">mf</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; gr a b -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; gr a (b, b, b)</li><li class="src short"><a href="#v:maxFlowgraph">maxFlowgraph</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; gr a b -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; gr a (b, b)</li><li class="src short"><a href="#v:maxFlow">maxFlow</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; gr a b -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; b</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:getRevEdges" class="def">getRevEdges</a> :: (<a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; [(<a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>, <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>)] -&gt; [(<a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>, <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>, b)] <a href="src/Data-Graph-Inductive-Query-MaxFlow.html#getRevEdges" class="link">Source</a></p><div class="doc"><pre>                i                                 0
For each edge a---&gt;b this function returns edge b---&gt;a .
         i
Edges a&lt;---&gt;b are ignored
         j
</pre></div></div><div class="top"><p class="src"><a name="v:augmentGraph" class="def">augmentGraph</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; gr a b -&gt; gr a (b, b, b) <a href="src/Data-Graph-Inductive-Query-MaxFlow.html#augmentGraph" class="link">Source</a></p><div class="doc"><pre>                i                                  0
For each edge a---&gt;b insert into graph the edge a&lt;---b . Then change the
                           i         (i,0,i)
label of every edge from a----&gt;b to a-------&gt;b
</pre><p>where label (x,y,z)=(Max Capacity, Current flow, Residual capacity)</p></div></div><div class="top"><p class="src"><a name="v:updAdjList" class="def">updAdjList</a> :: (<a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; [((b, b, b), <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>)] -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; b -&gt; <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Bool.html#t:Bool">Bool</a> -&gt; [((b, b, b), <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a>)] <a href="src/Data-Graph-Inductive-Query-MaxFlow.html#updAdjList" class="link">Source</a></p><div class="doc"><p>Given a successor or predecessor list for node u and given node v, find
 the label corresponding to edge (u,v) and update the flow and residual
 capacity of that edge's label. Then return the updated list.</p></div></div><div class="top"><p class="src"><a name="v:updateFlow" class="def">updateFlow</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; <a href="Data-Graph-Inductive-Graph.html#t:Path">Path</a> -&gt; b -&gt; gr a (b, b, b) -&gt; gr a (b, b, b) <a href="src/Data-Graph-Inductive-Query-MaxFlow.html#updateFlow" class="link">Source</a></p><div class="doc"><p>Update flow and residual capacity along augmenting path from s to t in
 graph G. For a path [u,v,w,...] find the node u in G and its successor and
 predecessor list, then update the corresponding edges (u,v) and (v,u) on
 those lists by using the minimum residual capacity of the path.</p></div></div><div class="top"><p class="src"><a name="v:mfmg" class="def">mfmg</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; gr a (b, b, b) -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; gr a (b, b, b) <a href="src/Data-Graph-Inductive-Query-MaxFlow.html#mfmg" class="link">Source</a></p><div class="doc"><p>Compute the flow from s to t on a graph whose edges are labeled with
 (x,y,z)=(max capacity,current flow,residual capacity) and all edges
 are of the form a&lt;----&gt;b. First compute the residual graph, that is,
 delete those edges whose residual capacity is zero. Then compute the
 shortest augmenting path from s to t, and finally update the flow and
 residual capacity along that path by using the minimum capacity of
 that path. Repeat this process until no shortest path from s to t exist.</p></div></div><div class="top"><p class="src"><a name="v:mf" class="def">mf</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; gr a b -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; gr a (b, b, b) <a href="src/Data-Graph-Inductive-Query-MaxFlow.html#mf" class="link">Source</a></p><div class="doc"><p>Compute the flow from s to t on a graph whose edges are labeled with
 x, which is the max capacity and where not all edges need to be of the
 form a&lt;----&gt;b. Return the flow as a grap whose edges are labeled with
 (x,y,z)=(max capacity,current flow,residual capacity) and all edges
 are of the form a&lt;----&gt;b</p></div></div><div class="top"><p class="src"><a name="v:maxFlowgraph" class="def">maxFlowgraph</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; gr a b -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; gr a (b, b) <a href="src/Data-Graph-Inductive-Query-MaxFlow.html#maxFlowgraph" class="link">Source</a></p><div class="doc"><p>Compute the maximum flow from s to t on a graph whose edges are labeled
 with x, which is the max capacity and where not all edges need to be of
 the form a&lt;----&gt;b. Return the flow as a grap whose edges are labeled with
 (y,x) = (current flow, max capacity).</p></div></div><div class="top"><p class="src"><a name="v:maxFlow" class="def">maxFlow</a> :: (<a href="Data-Graph-Inductive-Graph.html#t:DynGraph">DynGraph</a> gr, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b, <a href="/usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> b) =&gt; gr a b -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; <a href="Data-Graph-Inductive-Graph.html#t:Node">Node</a> -&gt; b <a href="src/Data-Graph-Inductive-Query-MaxFlow.html#maxFlow" class="link">Source</a></p><div class="doc"><p>Compute the value of a maximumflow</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>