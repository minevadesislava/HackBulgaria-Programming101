<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>7.10. Type-Level Literals</title><link rel="stylesheet" type="text/css" href="fptools.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.8.3"><link rel="up" href="ghc-language-features.html" title="Chapter 7. GHC Language Features"><link rel="prev" href="promotion.html" title="7.9. Datatype promotion"><link rel="next" href="equality-constraints.html" title="7.11. Equality constraints"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.10. Type-Level Literals</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="promotion.html">Prev</a> </td><th width="60%" align="center">Chapter 7. GHC Language Features</th><td width="20%" align="right"> <a accesskey="n" href="equality-constraints.html">Next</a></td></tr></table><hr></div><div class="sect1" title="7.10. Type-Level Literals"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="type-level-literals"></a>7.10. Type-Level Literals</h2></div></div></div><p>
GHC supports numeric and string literals at the type level, giving convenient
access to a large number of predefined type-level constants.
Numeric literals are of kind <code class="literal">Nat</code>, while string literals
are of kind <code class="literal">Symbol</code>.
This feature is enabled by the <code class="literal">XDataKinds</code>
language extension.
</p><p>
The kinds of the literals and all other low-level operations for this feature
are defined in module <code class="literal">GHC.TypeLits</code>. Note that the module
defines some type-level operators that clash with their value-level
counterparts (e.g. <code class="literal">(+)</code>).  Import and export declarations
referring to these operators require an explicit namespace
annotation (see <a class="xref" href="syntax-extns.html#explicit-namespaces" title="7.3.27. Explicit namespaces in import/export">Section 7.3.27, &#8220;Explicit namespaces in import/export&#8221;</a>).
</p><p>
Here is an exampe of using type-level numeric literals to provide a safe
interface to a low-level function:
</p><pre class="programlisting">
import GHC.TypeLits
import Data.Word
import Foreign

newtype ArrPtr (n :: Nat) a = ArrPtr (Ptr a)

clearPage :: ArrPtr 4096 Word8 -&gt; IO ()
clearPage (ArrPtr p) = ...
</pre><p>
</p><p>
Here is an example of using type-level string literals to simulate
simple record operations:
</p><pre class="programlisting">
data Label (l :: Symbol) = Get

class Has a l b | a l -&gt; b where
  from :: a -&gt; Label l -&gt; b

data Point = Point Int Int deriving Show

instance Has Point "x" Int where from (Point x _) _ = x
instance Has Point "y" Int where from (Point _ y) _ = y

example = from (Point 1 2) (Get :: Label "x")
</pre><p>
</p><div class="sect2" title="7.10.1. Runtime Values for Type-Level Literals"><div class="titlepage"><div><div><h3 class="title"><a name="typelit-runtime"></a>7.10.1. Runtime Values for Type-Level Literals</h3></div></div></div><p>
Sometimes it is useful to access the value-level literal assocaited with
a type-level literal.  This is done with the functions
<code class="literal">natVal</code> and <code class="literal">symbolVal</code>. For example:
</p><pre class="programlisting">
GHC.TypeLits&gt; natVal (Proxy :: Proxy 2)
2
</pre><p>
These functions are overloaded because they need to return a different
result, depending on the type at which they are instantiated.
</p><pre class="programlisting">
natVal :: KnownNat n =&gt; proxy n -&gt; Integer

-- instance KnownNat 0
-- instance KnownNat 1
-- instance KnownNat 2
-- ...
</pre><p>
GHC discharges the constraint as soon as it knows what concrete
type-level literal is being used in the program.  Note that this works
only for <span class="emphasis"><em>literals</em></span> and not arbitrary type expressions.
For example, a constraint of the form <code class="literal">KnownNat (a + b)</code>
will <span class="emphasis"><em>not</em></span> be simplified to
<code class="literal">(KnownNat a, KnownNat b)</code>; instead, GHC will keep the
constraint as is, until it can simplify <code class="literal">a + b</code> to
a constant value.
</p></div><p>
It is also possible to convert a run-time integer or string value to
the corresponding type-level literal.  Of course, the resulting type
literal will be unknown at compile-time, so it is hidden in an existential
type.   The conversion may be performed using <code class="literal">someNatVal</code>
for integers and <code class="literal">someSymbolVal</code> for strings:
</p><pre class="programlisting">
someNatVal :: Integer -&gt; Maybe SomeNat
SomeNat    :: KnownNat n =&gt; Proxy n -&gt; SomeNat
</pre><p>
The operations on strings are similar.
</p><div class="sect2" title="7.10.2. Computing With Type-Level Naturals"><div class="titlepage"><div><div><h3 class="title"><a name="typelit-tyfuns"></a>7.10.2. Computing With Type-Level Naturals</h3></div></div></div><p>
GHC 7.8 can evaluate arithmetic expressions involving type-level natural
numbers.  Such expressions may be constructed using the type-families
<code class="literal">(+), (*), (^)</code> for addition, multiplication,
and exponentiation.  Numbers may be compared using <code class="literal">(&lt;=?)</code>,
which returns a promoted boolean value, or <code class="literal">(&lt;=)</code>, which
compares numbers as a constraint.  For example:
</p><pre class="programlisting">
GHC.TypeLits&gt; natVal (Proxy :: Proxy (2 + 3))
5
</pre><p>
</p><p>
At present, GHC is quite limited in its reasoning about arithmetic:
it will only evalute the arithmetic type functions and compare the results---
in the same way that it does for any other type function.  In particular,
it does not know more general facts about arithmetic, such as the commutativity
and associativity of <code class="literal">(+)</code>, for example.
</p><p>
However, it is possible to perform a bit of "backwards" evaluation.
For example, here is how we could get GHC to compute arbitrary logarithms
at the type level:
</p><pre class="programlisting">
lg :: Proxy base -&gt; Proxy (base ^ pow) -&gt; Proxy pow
lg _ _ = Proxy

GHC.TypeLits&gt; natVal (lg (Proxy :: Proxy 2) (Proxy :: Proxy 8))
3
</pre><p>
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="promotion.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ghc-language-features.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="equality-constraints.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.9. Datatype promotion </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.11. Equality constraints</td></tr></table></div></body></html>
