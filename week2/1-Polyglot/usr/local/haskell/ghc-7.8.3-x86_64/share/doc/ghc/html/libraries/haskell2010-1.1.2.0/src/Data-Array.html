<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Data/Array.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP, PackageImports #-}</span>
<a name="line-2"></a><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &gt;= 701</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE Trustworthy #-}</span>
<a name="line-4"></a><span class='hs-cpp'>#endif</span>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Array</span> <span class='hs-layout'>(</span>
<a name="line-7"></a>    <span class='hs-comment'>-- * Immutable non-strict arrays</span>
<a name="line-8"></a>    <span class='hs-comment'>-- $intro</span>
<a name="line-9"></a>      <span class='hs-keyword'>module</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Ix</span>            <span class='hs-comment'>-- export all of Ix</span>
<a name="line-10"></a>    <span class='hs-layout'>,</span> <span class='hs-conid'>Array</span>                     <span class='hs-comment'>-- Array type is abstract</span>
<a name="line-11"></a>
<a name="line-12"></a>    <span class='hs-comment'>-- * Array construction</span>
<a name="line-13"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>array</span>         <span class='hs-comment'>-- :: (Ix a) =&gt; (a,a) -&gt; [(a,b)] -&gt; Array a b</span>
<a name="line-14"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>listArray</span>     <span class='hs-comment'>-- :: (Ix a) =&gt; (a,a) -&gt; [b] -&gt; Array a b</span>
<a name="line-15"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>accumArray</span>    <span class='hs-comment'>-- :: (Ix a) =&gt; (b -&gt; c -&gt; b) -&gt; b -&gt; (a,a) -&gt; [(a,c)] -&gt; Array a b</span>
<a name="line-16"></a>    <span class='hs-comment'>-- * Accessing arrays</span>
<a name="line-17"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>!</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- :: (Ix a) =&gt; Array a b -&gt; a -&gt; b</span>
<a name="line-18"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>bounds</span>        <span class='hs-comment'>-- :: (Ix a) =&gt; Array a b -&gt; (a,a)</span>
<a name="line-19"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>indices</span>       <span class='hs-comment'>-- :: (Ix a) =&gt; Array a b -&gt; [a]</span>
<a name="line-20"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>elems</span>         <span class='hs-comment'>-- :: (Ix a) =&gt; Array a b -&gt; [b]</span>
<a name="line-21"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>assocs</span>        <span class='hs-comment'>-- :: (Ix a) =&gt; Array a b -&gt; [(a,b)]</span>
<a name="line-22"></a>    <span class='hs-comment'>-- * Incremental array updates</span>
<a name="line-23"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>//</span><span class='hs-layout'>)</span>          <span class='hs-comment'>-- :: (Ix a) =&gt; Array a b -&gt; [(a,b)] -&gt; Array a b</span>
<a name="line-24"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>accum</span>         <span class='hs-comment'>-- :: (Ix a) =&gt; (b -&gt; c -&gt; b) -&gt; Array a b -&gt; [(a,c)] -&gt; Array a b</span>
<a name="line-25"></a>    <span class='hs-comment'>-- * Derived arrays</span>
<a name="line-26"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>ixmap</span>         <span class='hs-comment'>-- :: (Ix a, Ix b) =&gt; (a,a) -&gt; (a -&gt; b) -&gt; Array b c -&gt; Array a b</span>
<a name="line-27"></a>
<a name="line-28"></a>    <span class='hs-comment'>-- * Specification</span>
<a name="line-29"></a>
<a name="line-30"></a>    <span class='hs-comment'>-- $code</span>
<a name="line-31"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-32"></a>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-str'>"array"</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Array</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Array</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-str'>"array"</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Array</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>array</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>//</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-str'>"base"</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Ix</span>
<a name="line-36"></a>
<a name="line-37"></a><span class='hs-comment'>{- $intro
<a name="line-38"></a>Haskell provides indexable /arrays/, which may be thought of as functions
<a name="line-39"></a>whose domains are isomorphic to contiguous subsets of the integers.
<a name="line-40"></a>Functions restricted in this way can be implemented efficiently;
<a name="line-41"></a>in particular, a programmer may reasonably expect rapid access to
<a name="line-42"></a>the components.  To ensure the possibility of such an implementation,
<a name="line-43"></a>arrays are treated as data, not as general functions.
<a name="line-44"></a>
<a name="line-45"></a>Since most array functions involve the class 'Ix', the contents of the
<a name="line-46"></a>module "Data.Ix" are re-exported from "Data.Array" for convenience:
<a name="line-47"></a>-}</span>
<a name="line-48"></a>
<a name="line-49"></a><span class='hs-comment'>-- SDM: copied documentation for 'array' to remove GHC reference</span>
<a name="line-50"></a>
<a name="line-51"></a><a name="array"></a><span class='hs-comment'>-- | Construct an array with the specified bounds and containing values</span>
<a name="line-52"></a><span class='hs-comment'>-- for given indices within these bounds.</span>
<a name="line-53"></a><span class='hs-comment'>--</span>
<a name="line-54"></a><span class='hs-comment'>-- The array is undefined (i.e. bottom) if any index in the list is</span>
<a name="line-55"></a><span class='hs-comment'>-- out of bounds.  If any</span>
<a name="line-56"></a><span class='hs-comment'>-- two associations in the list have the same index, the value at that</span>
<a name="line-57"></a><span class='hs-comment'>-- index is undefined (i.e. bottom).</span>
<a name="line-58"></a><span class='hs-comment'>--</span>
<a name="line-59"></a><span class='hs-comment'>-- Because the indices must be checked for these errors, 'array' is</span>
<a name="line-60"></a><span class='hs-comment'>-- strict in the bounds argument and in the indices of the association</span>
<a name="line-61"></a><span class='hs-comment'>-- list, but non-strict in the values.  Thus, recurrences such as the</span>
<a name="line-62"></a><span class='hs-comment'>-- following are possible:</span>
<a name="line-63"></a><span class='hs-comment'>--</span>
<a name="line-64"></a><span class='hs-comment'>-- &gt; a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i &lt;- [2..100]])</span>
<a name="line-65"></a><span class='hs-comment'>--</span>
<a name="line-66"></a><span class='hs-comment'>-- Not every index within the bounds of the array need appear in the</span>
<a name="line-67"></a><span class='hs-comment'>-- association list, but the values associated with indices that do not</span>
<a name="line-68"></a><span class='hs-comment'>-- appear will be undefined (i.e. bottom).</span>
<a name="line-69"></a><span class='hs-comment'>--</span>
<a name="line-70"></a><span class='hs-comment'>-- If, in any dimension, the lower bound is greater than the upper bound,</span>
<a name="line-71"></a><span class='hs-comment'>-- then the array is legal, but empty.  Indexing an empty array always</span>
<a name="line-72"></a><span class='hs-comment'>-- gives an array-bounds error, but 'bounds' still yields the bounds</span>
<a name="line-73"></a><span class='hs-comment'>-- with which the array was constructed.</span>
<a name="line-74"></a><span class='hs-definition'>array</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ix</span> <span class='hs-varid'>i</span>
<a name="line-75"></a>        <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-layout'>,</span><span class='hs-varid'>i</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- ^ a pair of /bounds/, each of the index type</span>
<a name="line-76"></a>                        <span class='hs-comment'>-- of the array.  These bounds are the lowest and</span>
<a name="line-77"></a>                        <span class='hs-comment'>-- highest indices in the array, in that order.</span>
<a name="line-78"></a>                        <span class='hs-comment'>-- For example, a one-origin vector of length</span>
<a name="line-79"></a>                        <span class='hs-comment'>-- '10' has bounds '(1,10)', and a one-origin '10'</span>
<a name="line-80"></a>                        <span class='hs-comment'>-- by '10' matrix has bounds '((1,1),(10,10))'.</span>
<a name="line-81"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- ^ a list of /associations/ of the form</span>
<a name="line-82"></a>                        <span class='hs-comment'>-- (/index/, /value/).  Typically, this list will</span>
<a name="line-83"></a>                        <span class='hs-comment'>-- be expressed as a comprehension.  An</span>
<a name="line-84"></a>                        <span class='hs-comment'>-- association '(i, x)' defines the value of</span>
<a name="line-85"></a>                        <span class='hs-comment'>-- the array at index 'i' to be 'x'.</span>
<a name="line-86"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Array</span> <span class='hs-varid'>i</span> <span class='hs-varid'>e</span>
<a name="line-87"></a><span class='hs-definition'>array</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Array</span><span class='hs-varop'>.</span><span class='hs-varid'>array</span>
<a name="line-88"></a>
<a name="line-89"></a><span class='hs-comment'>-- SDM copied docs for (//) to remove GHC reference</span>
<a name="line-90"></a>
<a name="line-91"></a><a name="//"></a><span class='hs-comment'>-- | Constructs an array identical to the first argument except that it has</span>
<a name="line-92"></a><span class='hs-comment'>-- been updated by the associations in the right argument.</span>
<a name="line-93"></a><span class='hs-comment'>-- For example, if @m@ is a 1-origin, @n@ by @n@ matrix, then</span>
<a name="line-94"></a><span class='hs-comment'>--</span>
<a name="line-95"></a><span class='hs-comment'>-- &gt; m//[((i,i), 0) | i &lt;- [1..n]]</span>
<a name="line-96"></a><span class='hs-comment'>--</span>
<a name="line-97"></a><span class='hs-comment'>-- is the same matrix, except with the diagonal zeroed.</span>
<a name="line-98"></a><span class='hs-comment'>--</span>
<a name="line-99"></a><span class='hs-comment'>-- Repeated indices in the association list are handled as for 'array':</span>
<a name="line-100"></a><span class='hs-comment'>-- the resulting array is undefined (i.e. bottom),</span>
<a name="line-101"></a><span class='hs-layout'>(</span><span class='hs-varop'>//</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ix</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Array</span> <span class='hs-varid'>i</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Array</span> <span class='hs-varid'>i</span> <span class='hs-varid'>e</span>
<a name="line-102"></a><span class='hs-layout'>(</span><span class='hs-varop'>//</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Array</span><span class='hs-varop'>.//</span><span class='hs-layout'>)</span>
<a name="line-103"></a>
<a name="line-104"></a><span class='hs-comment'>{- $code
<a name="line-105"></a>&gt; module  Array (
<a name="line-106"></a>&gt;     module Data.Ix,  -- export all of Data.Ix
<a name="line-107"></a>&gt;     Array, array, listArray, (!), bounds, indices, elems, assocs,
<a name="line-108"></a>&gt;     accumArray, (//), accum, ixmap ) where
<a name="line-109"></a>&gt;
<a name="line-110"></a>&gt; import Data.Ix
<a name="line-111"></a>&gt; import Data.List( (\\) )
<a name="line-112"></a>&gt;
<a name="line-113"></a>&gt; infixl 9  !, //
<a name="line-114"></a>&gt;
<a name="line-115"></a>&gt; data (Ix a) =&gt; Array a b = MkArray (a,a) (a -&gt; b) deriving ()
<a name="line-116"></a>&gt;
<a name="line-117"></a>&gt; array       :: (Ix a) =&gt; (a,a) -&gt; [(a,b)] -&gt; Array a b
<a name="line-118"></a>&gt; array b ivs
<a name="line-119"></a>&gt;   | any (not . inRange b. fst) ivs
<a name="line-120"></a>&gt;      = error "Data.Array.array: out-of-range array association"
<a name="line-121"></a>&gt;   | otherwise
<a name="line-122"></a>&gt;      = MkArray b arr
<a name="line-123"></a>&gt;   where
<a name="line-124"></a>&gt;     arr j = case [ v | (i,v) &lt;- ivs, i == j ] of
<a name="line-125"></a>&gt;               [v]   -&gt; v
<a name="line-126"></a>&gt;               []    -&gt; error "Data.Array.!: undefined array element"
<a name="line-127"></a>&gt;               _     -&gt; error "Data.Array.!: multiply defined array element"
<a name="line-128"></a>&gt;
<a name="line-129"></a>&gt; listArray             :: (Ix a) =&gt; (a,a) -&gt; [b] -&gt; Array a b
<a name="line-130"></a>&gt; listArray b vs        =  array b (zipWith (\ a b -&gt; (a,b)) (range b) vs)
<a name="line-131"></a>&gt;
<a name="line-132"></a>&gt; (!)                   :: (Ix a) =&gt; Array a b -&gt; a -&gt; b
<a name="line-133"></a>&gt; (!) (MkArray _ f)     =  f
<a name="line-134"></a>&gt;
<a name="line-135"></a>&gt; bounds                :: (Ix a) =&gt; Array a b -&gt; (a,a)
<a name="line-136"></a>&gt; bounds (MkArray b _)  =  b
<a name="line-137"></a>&gt;
<a name="line-138"></a>&gt; indices               :: (Ix a) =&gt; Array a b -&gt; [a]
<a name="line-139"></a>&gt; indices               =  range . bounds
<a name="line-140"></a>&gt;
<a name="line-141"></a>&gt; elems                 :: (Ix a) =&gt; Array a b -&gt; [b]
<a name="line-142"></a>&gt; elems a               =  [a!i | i &lt;- indices a]
<a name="line-143"></a>&gt;
<a name="line-144"></a>&gt; assocs                :: (Ix a) =&gt; Array a b -&gt; [(a,b)]
<a name="line-145"></a>&gt; assocs a              =  [(i, a!i) | i &lt;- indices a]
<a name="line-146"></a>&gt;
<a name="line-147"></a>&gt; (//)                  :: (Ix a) =&gt; Array a b -&gt; [(a,b)] -&gt; Array a b
<a name="line-148"></a>&gt; a // new_ivs          = array (bounds a) (old_ivs ++ new_ivs)
<a name="line-149"></a>&gt;                       where
<a name="line-150"></a>&gt;                         old_ivs = [(i,a!i) | i &lt;- indices a,
<a name="line-151"></a>&gt;                                              i `notElem` new_is]
<a name="line-152"></a>&gt;                         new_is  = [i | (i,_) &lt;- new_ivs]
<a name="line-153"></a>&gt;
<a name="line-154"></a>&gt; accum                 :: (Ix a) =&gt; (b -&gt; c -&gt; b) -&gt; Array a b -&gt; [(a,c)]
<a name="line-155"></a>&gt;                                    -&gt; Array a b
<a name="line-156"></a>&gt; accum f               =  foldl (\a (i,v) -&gt; a // [(i,f (a!i) v)])
<a name="line-157"></a>&gt;
<a name="line-158"></a>&gt; accumArray            :: (Ix a) =&gt; (b -&gt; c -&gt; b) -&gt; b -&gt; (a,a) -&gt; [(a,c)]
<a name="line-159"></a>&gt;                                    -&gt; Array a b
<a name="line-160"></a>&gt; accumArray f z b      =  accum f (array b [(i,z) | i &lt;- range b])
<a name="line-161"></a>&gt;
<a name="line-162"></a>&gt; ixmap                 :: (Ix a, Ix b) =&gt; (a,a) -&gt; (a -&gt; b) -&gt; Array b c
<a name="line-163"></a>&gt;                                          -&gt; Array a c
<a name="line-164"></a>&gt; ixmap b f a           = array b [(i, a ! f i) | i &lt;- range b]
<a name="line-165"></a>&gt;
<a name="line-166"></a>&gt; instance  (Ix a)          =&gt; Functor (Array a) where
<a name="line-167"></a>&gt;     fmap fn (MkArray b f) =  MkArray b (fn . f)
<a name="line-168"></a>&gt;
<a name="line-169"></a>&gt; instance  (Ix a, Eq b)  =&gt; Eq (Array a b)  where
<a name="line-170"></a>&gt;     a == a' =  assocs a == assocs a'
<a name="line-171"></a>&gt;
<a name="line-172"></a>&gt; instance  (Ix a, Ord b) =&gt; Ord (Array a b)  where
<a name="line-173"></a>&gt;     a &lt;= a' =  assocs a &lt;= assocs a'
<a name="line-174"></a>&gt;
<a name="line-175"></a>&gt; instance  (Ix a, Show a, Show b) =&gt; Show (Array a b)  where
<a name="line-176"></a>&gt;     showsPrec p a = showParen (p &gt; arrPrec) (
<a name="line-177"></a>&gt;                     showString "array " .
<a name="line-178"></a>&gt;                     showsPrec (arrPrec+1) (bounds a) . showChar ' ' .
<a name="line-179"></a>&gt;                     showsPrec (arrPrec+1) (assocs a)                  )
<a name="line-180"></a>&gt;
<a name="line-181"></a>&gt; instance  (Ix a, Read a, Read b) =&gt; Read (Array a b)  where
<a name="line-182"></a>&gt;     readsPrec p = readParen (p &gt; arrPrec)
<a name="line-183"></a>&gt;            (\r -&gt; [ (array b as, u)
<a name="line-184"></a>&gt;                   | ("array",s) &lt;- lex r,
<a name="line-185"></a>&gt;                     (b,t)       &lt;- readsPrec (arrPrec+1) s,
<a name="line-186"></a>&gt;                     (as,u)      &lt;- readsPrec (arrPrec+1) t ])
<a name="line-187"></a>&gt;
<a name="line-188"></a>&gt; -- Precedence of the 'array' function is that of application itself
<a name="line-189"></a>&gt; arrPrec = 10
<a name="line-190"></a>-}</span>
</pre></body>
</html>
