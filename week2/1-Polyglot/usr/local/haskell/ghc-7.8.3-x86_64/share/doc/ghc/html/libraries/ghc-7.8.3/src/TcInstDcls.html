<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcInstDcls.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
%
% (c) The University of Glasgow 2006
% (c) The GRASP/AQUA Project, Glasgow University, 1992-1998
%

TcInstDecls: Typechecking instance declarations

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>{-# OPTIONS -fno-warn-tabs #-}</span>
<a name="line-2"></a><span class='hs-comment'>-- The above warning supression flag is a temporary kludge.</span>
<a name="line-3"></a><span class='hs-comment'>-- While working on this module you are encouraged to remove it and</span>
<a name="line-4"></a><span class='hs-comment'>-- detab the module (please do the detabbing in a separate patch). See</span>
<a name="line-5"></a><span class='hs-comment'>--     <a href="http://ghc.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces">http://ghc.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces</a></span>
<a name="line-6"></a><span class='hs-comment'>-- for details</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcInstDcls</span> <span class='hs-layout'>(</span> <span class='hs-varid'>tcInstDecls1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tcInstDecls2</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>HsSyn</span>
<a name="line-13"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcBinds</span>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcTyClsDecls</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcClassDcl</span><span class='hs-layout'>(</span> <span class='hs-varid'>tcClassDecl2</span><span class='hs-layout'>,</span> 
<a name="line-16"></a>                   <span class='hs-conid'>HsSigFun</span><span class='hs-layout'>,</span> <span class='hs-varid'>lookupHsSig</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkHsSigFun</span><span class='hs-layout'>,</span>
<a name="line-17"></a>                   <span class='hs-varid'>findMethodBind</span><span class='hs-layout'>,</span> <span class='hs-varid'>instantiateMethod</span><span class='hs-layout'>,</span> <span class='hs-varid'>tcInstanceMethodBody</span> <span class='hs-layout'>)</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcPat</span>      <span class='hs-layout'>(</span> <span class='hs-varid'>addInlinePrags</span> <span class='hs-layout'>)</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnMonad</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcValidity</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcMType</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BuildTyCl</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Inst</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>InstEnv</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FamInst</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FamInstEnv</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcDeriv</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEnv</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcHsType</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcUnify</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MkCore</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>nO_METHOD_BINDING_ERROR_ID</span> <span class='hs-layout'>)</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoAxiom</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DataCon</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span> 
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreUnfold</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkDFunUnfolding</span> <span class='hs-layout'>)</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreSyn</span>    <span class='hs-layout'>(</span> <span class='hs-conid'>Expr</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyApps</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkVarApps</span> <span class='hs-layout'>)</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelNames</span>  <span class='hs-layout'>(</span> <span class='hs-varid'>tYPEABLE_INTERNAL</span><span class='hs-layout'>,</span> <span class='hs-varid'>typeableClassName</span><span class='hs-layout'>,</span> <span class='hs-varid'>oldTypeableClassNames</span> <span class='hs-layout'>)</span>
<a name="line-45"></a>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ErrUtils</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>HscTypes</span> <span class='hs-layout'>(</span> <span class='hs-varid'>isHsBoot</span> <span class='hs-layout'>)</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Id</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MkId</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>NameSet</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>SrcLoc</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BooleanFormula</span> <span class='hs-layout'>(</span> <span class='hs-varid'>isUnsatisfied</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprBooleanFormulaNice</span> <span class='hs-layout'>)</span>
<a name="line-60"></a>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Maybes</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>isNothing</span><span class='hs-layout'>,</span> <span class='hs-varid'>isJust</span><span class='hs-layout'>,</span> <span class='hs-varid'>whenIsJust</span> <span class='hs-layout'>)</span>
</pre>\end{code}

Typechecking instance declarations is done in two passes. The first
pass, made by @tcInstDecls1@, collects information to be used in the
second pass.

This pre-processed info includes the as-yet-unprocessed bindings
inside the instance declaration.  These are type-checked in the second
pass, when the class-instance envs and GVE contain all the info from
all the instance and value decls.  Indeed that's the reason we need
two passes over the instance decls.


Note [How instance declarations are translated]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Here is how we translation instance declarations into Core

Running example:
        class C a where
           op1, op2 :: Ix b => a -> b -> b
           op2 = <dm-rhs>

        instance C a => C [a]
           {-# INLINE [2] op1 #-}
           op1 = <rhs>
===>
        -- Method selectors
        op1,op2 :: forall a. C a => forall b. Ix b => a -> b -> b
        op1 = ...
        op2 = ...

        -- Default methods get the 'self' dictionary as argument
        -- so they can call other methods at the same type
        -- Default methods get the same type as their method selector
        $dmop2 :: forall a. C a => forall b. Ix b => a -> b -> b
        $dmop2 = /\a. \(d:C a). /\b. \(d2: Ix b). <dm-rhs>
               -- NB: type variables 'a' and 'b' are *both* in scope in <dm-rhs>
               -- Note [Tricky type variable scoping]

        -- A top-level definition for each instance method
        -- Here op1_i, op2_i are the "instance method Ids"
        -- The INLINE pragma comes from the user pragma
        {-# INLINE [2] op1_i #-}  -- From the instance decl bindings
        op1_i, op2_i :: forall a. C a => forall b. Ix b => [a] -> b -> b
        op1_i = /\a. \(d:C a).
               let this :: C [a]
                   this = df_i a d
                     -- Note [Subtle interaction of recursion and overlap]

                   local_op1 :: forall b. Ix b => [a] -> b -> b
                   local_op1 = <rhs>
                     -- Source code; run the type checker on this
                     -- NB: Type variable 'a' (but not 'b') is in scope in <rhs>
                     -- Note [Tricky type variable scoping]

               in local_op1 a d

        op2_i = /\a \d:C a. $dmop2 [a] (df_i a d)

        -- The dictionary function itself
        {-# NOINLINE CONLIKE df_i #-}   -- Never inline dictionary functions
        df_i :: forall a. C a -> C [a]
        df_i = /\a. \d:C a. MkC (op1_i a d) (op2_i a d)
                -- But see Note [Default methods in instances]
                -- We can't apply the type checker to the default-method call

        -- Use a RULE to short-circuit applications of the class ops
        {-# RULE "op1@C[a]" forall a, d:C a.
                            op1 [a] (df_i d) = op1_i a d #-}

Note [Instances and loop breakers]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* Note that df_i may be mutually recursive with both op1_i and op2_i.
  It's crucial that df_i is not chosen as the loop breaker, even
  though op1_i has a (user-specified) INLINE pragma.

* Instead the idea is to inline df_i into op1_i, which may then select
  methods from the MkC record, and thereby break the recursion with
  df_i, leaving a *self*-recurisve op1_i.  (If op1_i doesn't call op at
  the same type, it won't mention df_i, so there won't be recursion in
  the first place.)

* If op1_i is marked INLINE by the user there's a danger that we won't
  inline df_i in it, and that in turn means that (since it'll be a
  loop-breaker because df_i isn't), op1_i will ironically never be
  inlined.  But this is OK: the recursion breaking happens by way of
  a RULE (the magic ClassOp rule above), and RULES work inside InlineRule
  unfoldings. See Note [RULEs enabled in SimplGently] in SimplUtils

Note [ClassOp/DFun selection]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
One thing we see a lot is stuff like
    op2 (df d1 d2)
where 'op2' is a ClassOp and 'df' is DFun.  Now, we could inline *both*
'op2' and 'df' to get
     case (MkD ($cop1 d1 d2) ($cop2 d1 d2) ... of
       MkD _ op2 _ _ _ -> op2
And that will reduce to ($cop2 d1 d2) which is what we wanted.

But it's tricky to make this work in practice, because it requires us to
inline both 'op2' and 'df'.  But neither is keen to inline without having
seen the other's result; and it's very easy to get code bloat (from the
big intermediate) if you inline a bit too much.

Instead we use a cunning trick.
 * We arrange that 'df' and 'op2' NEVER inline.

 * We arrange that 'df' is ALWAYS defined in the sylised form
      df d1 d2 = MkD ($cop1 d1 d2) ($cop2 d1 d2) ...

 * We give 'df' a magical unfolding (DFunUnfolding [$cop1, $cop2, ..])
   that lists its methods.

 * We make CoreUnfold.exprIsConApp_maybe spot a DFunUnfolding and return
   a suitable constructor application -- inlining df "on the fly" as it
   were.

 * ClassOp rules: We give the ClassOp 'op2' a BuiltinRule that
   extracts the right piece iff its argument satisfies
   exprIsConApp_maybe.  This is done in MkId mkDictSelId

 * We make 'df' CONLIKE, so that shared uses still match; eg
      let d = df d1 d2
      in ...(op2 d)...(op1 d)...

Note [Single-method classes]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If the class has just one method (or, more accurately, just one element
of {superclasses + methods}), then we use a different strategy.

   class C a where op :: a -> a
   instance C a => C [a] where op = <blah>

We translate the class decl into a newtype, which just gives a
top-level axiom. The "constructor" MkC expands to a cast, as does the
class-op selector.

   axiom Co:C a :: C a ~ (a->a)

   op :: forall a. C a -> (a -> a)
   op a d = d |> (Co:C a)

   MkC :: forall a. (a->a) -> C a
   MkC = /\a.\op. op |> (sym Co:C a)

The clever RULE stuff doesn't work now, because ($df a d) isn't
a constructor application, so exprIsConApp_maybe won't return
Just <blah>.

Instead, we simply rely on the fact that casts are cheap:

   $df :: forall a. C a => C [a]
   {-# INLINE df #-}  -- NB: INLINE this
   $df = /\a. \d. MkC [a] ($cop_list a d)
       = $cop_list |> forall a. C a -> (sym (Co:C [a]))

   $cop_list :: forall a. C a => [a] -> [a]
   $cop_list = <blah>

So if we see
   (op ($df a d))
we'll inline 'op' and '$df', since both are simply casts, and
good things happen.

Why do we use this different strategy?  Because otherwise we
end up with non-inlined dictionaries that look like
    $df = $cop |> blah
which adds an extra indirection to every use, which seems stupid.  See
Trac #4138 for an example (although the regression reported there
wasn't due to the indirection).

There is an awkward wrinkle though: we want to be very
careful when we have
    instance C a => C [a] where
      {-# INLINE op #-}
      op = ...
then we'll get an INLINE pragma on $cop_list but it's important that
$cop_list only inlines when it's applied to *two* arguments (the
dictionary and the list argument).  So we must not eta-expand $df
above.  We ensure that this doesn't happen by putting an INLINE
pragma on the dfun itself; after all, it ends up being just a cast.

There is one more dark corner to the INLINE story, even more deeply
buried.  Consider this (Trac #3772):

    class DeepSeq a => C a where
      gen :: Int -> a

    instance C a => C [a] where
      gen n = ...

    class DeepSeq a where
      deepSeq :: a -> b -> b

    instance DeepSeq a => DeepSeq [a] where
      {-# INLINE deepSeq #-}
      deepSeq xs b = foldr deepSeq b xs

That gives rise to these defns:

    $cdeepSeq :: DeepSeq a -> [a] -> b -> b
    -- User INLINE( 3 args )!
    $cdeepSeq a (d:DS a) b (x:[a]) (y:b) = ...

    $fDeepSeq[] :: DeepSeq a -> DeepSeq [a]
    -- DFun (with auto INLINE pragma)
    $fDeepSeq[] a d = $cdeepSeq a d |> blah

    $cp1 a d :: C a => DeepSep [a]
    -- We don't want to eta-expand this, lest
    -- $cdeepSeq gets inlined in it!
    $cp1 a d = $fDeepSep[] a (scsel a d)

    $fC[] :: C a => C [a]
    -- Ordinary DFun
    $fC[] a d = MkC ($cp1 a d) ($cgen a d)

Here $cp1 is the code that generates the superclass for C [a].  The
issue is this: we must not eta-expand $cp1 either, or else $fDeepSeq[]
and then $cdeepSeq will inline there, which is definitely wrong.  Like
on the dfun, we solve this by adding an INLINE pragma to $cp1.

Note [Subtle interaction of recursion and overlap]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider this
  class C a where { op1,op2 :: a -> a }
  instance C a => C [a] where
    op1 x = op2 x ++ op2 x
    op2 x = ...
  instance C [Int] where
    ...

When type-checking the C [a] instance, we need a C [a] dictionary (for
the call of op2).  If we look up in the instance environment, we find
an overlap.  And in *general* the right thing is to complain (see Note
[Overlapping instances] in InstEnv).  But in *this* case it's wrong to
complain, because we just want to delegate to the op2 of this same
instance.

Why is this justified?  Because we generate a (C [a]) constraint in
a context in which 'a' cannot be instantiated to anything that matches
other overlapping instances, or else we would not be executing this
version of op1 in the first place.

It might even be a bit disguised:

  nullFail :: C [a] => [a] -> [a]
  nullFail x = op2 x ++ op2 x

  instance C a => C [a] where
    op1 x = nullFail x

Precisely this is used in package 'regex-base', module Context.hs.
See the overlapping instances for RegexContext, and the fact that they
call 'nullFail' just like the example above.  The DoCon package also
does the same thing; it shows up in module Fraction.hs.

Conclusion: when typechecking the methods in a C [a] instance, we want to
treat the 'a' as an *existential* type variable, in the sense described
by Note [Binding when looking up instances].  That is why isOverlappableTyVar
responds True to an InstSkol, which is the kind of skolem we use in
tcInstDecl2.


Note [Tricky type variable scoping]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In our example
        class C a where
           op1, op2 :: Ix b => a -> b -> b
           op2 = <dm-rhs>

        instance C a => C [a]
           {-# INLINE [2] op1 #-}
           op1 = <rhs>

note that 'a' and 'b' are *both* in scope in <dm-rhs>, but only 'a' is
in scope in <rhs>.  In particular, we must make sure that 'b' is in
scope when typechecking <dm-rhs>.  This is achieved by subFunTys,
which brings appropriate tyvars into scope. This happens for both
<dm-rhs> and for <rhs>, but that doesn't matter: the *renamer* will have
complained if 'b' is mentioned in <rhs>.



%************************************************************************
%*                                                                      *
\subsection{Extracting instance decls}
%*                                                                      *
%************************************************************************

Gather up the instance declarations from their various sources

\begin{code}
<pre><a name="line-1"></a><a name="tcInstDecls1"></a><span class='hs-definition'>tcInstDecls1</span>    <span class='hs-comment'>-- Deal with both source-code and imported instance decls</span>
<a name="line-2"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LTyClDecl</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span>          <span class='hs-comment'>-- For deriving stuff</span>
<a name="line-3"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LInstDecl</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span>          <span class='hs-comment'>-- Source code instance decls</span>
<a name="line-4"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LDerivDecl</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span>         <span class='hs-comment'>-- Source code stand-alone deriving decls</span>
<a name="line-5"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcGblEnv</span><span class='hs-layout'>,</span>            <span class='hs-comment'>-- The full inst env</span>
<a name="line-6"></a>           <span class='hs-keyglyph'>[</span><span class='hs-conid'>InstInfo</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- Source-code instance decls to process;</span>
<a name="line-7"></a>                                <span class='hs-comment'>-- contains all dfuns for this module</span>
<a name="line-8"></a>           <span class='hs-conid'>HsValBinds</span> <span class='hs-conid'>Name</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- Supporting bindings for derived instances</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-definition'>tcInstDecls1</span> <span class='hs-varid'>tycl_decls</span> <span class='hs-varid'>inst_decls</span> <span class='hs-varid'>deriv_decls</span> 
<a name="line-11"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>checkNoErrs</span> <span class='hs-varop'>$</span>
<a name="line-12"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>    <span class='hs-comment'>-- Stop if addInstInfos etc discovers any errors</span>
<a name="line-13"></a>            <span class='hs-comment'>-- (they recover, so that we get more than one error each</span>
<a name="line-14"></a>            <span class='hs-comment'>-- round)</span>
<a name="line-15"></a>
<a name="line-16"></a>            <span class='hs-comment'>-- Do class and family instance declarations</span>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getGblEnv</span>
<a name="line-18"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>stuff</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAndRecoverM</span> <span class='hs-varid'>tcLocalInstDecl</span> <span class='hs-varid'>inst_decls</span>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>local_infos_s</span><span class='hs-layout'>,</span> <span class='hs-varid'>fam_insts_s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-varid'>stuff</span>
<a name="line-20"></a>             <span class='hs-varid'>fam_insts</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concat</span> <span class='hs-varid'>fam_insts_s</span>
<a name="line-21"></a>             <span class='hs-varid'>local_infos'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concat</span> <span class='hs-varid'>local_infos_s</span>
<a name="line-22"></a>             <span class='hs-comment'>-- Handwritten instances of the poly-kinded Typeable class are</span>
<a name="line-23"></a>             <span class='hs-comment'>-- forbidden, so we handle those separately</span>
<a name="line-24"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>typeable_instances</span><span class='hs-layout'>,</span> <span class='hs-varid'>local_infos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitTypeable</span> <span class='hs-varid'>env</span> <span class='hs-varid'>local_infos'</span>
<a name="line-25"></a>
<a name="line-26"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>addClsInsts</span> <span class='hs-varid'>local_infos</span> <span class='hs-varop'>$</span>
<a name="line-27"></a>         <span class='hs-varid'>addFamInsts</span> <span class='hs-varid'>fam_insts</span>   <span class='hs-varop'>$</span>
<a name="line-28"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>    <span class='hs-comment'>-- Compute instances from "deriving" clauses;</span>
<a name="line-29"></a>            <span class='hs-comment'>-- This stuff computes a context for the derived instance</span>
<a name="line-30"></a>            <span class='hs-comment'>-- decl, so it needs to know about all the instances possible</span>
<a name="line-31"></a>            <span class='hs-comment'>-- NB: class instance declarations can contain derivings as</span>
<a name="line-32"></a>            <span class='hs-comment'>--     part of associated data type declarations</span>
<a name="line-33"></a>         <span class='hs-varid'>failIfErrsM</span>    <span class='hs-comment'>-- If the addInsts stuff gave any errors, don't</span>
<a name="line-34"></a>                        <span class='hs-comment'>-- try the deriving stuff, because that may give</span>
<a name="line-35"></a>                        <span class='hs-comment'>-- more errors still</span>
<a name="line-36"></a>
<a name="line-37"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"tcDeriving"</span> <span class='hs-varid'>empty</span>
<a name="line-38"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>th_stage</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getStage</span>   <span class='hs-comment'>-- See Note [Deriving inside TH brackets ]</span>
<a name="line-39"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>gbl_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>deriv_inst_info</span><span class='hs-layout'>,</span> <span class='hs-varid'>deriv_binds</span><span class='hs-layout'>)</span>
<a name="line-40"></a>              <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isBrackStage</span> <span class='hs-varid'>th_stage</span> 
<a name="line-41"></a>                 <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>gbl_env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getGblEnv</span>
<a name="line-42"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>gbl_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyValBindsOut</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-43"></a>                 <span class='hs-keyword'>else</span> <span class='hs-varid'>tcDeriving</span> <span class='hs-varid'>tycl_decls</span> <span class='hs-varid'>inst_decls</span> <span class='hs-varid'>deriv_decls</span>
<a name="line-44"></a>
<a name="line-45"></a>       <span class='hs-comment'>-- Fail if there are any handwritten instance of poly-kinded Typeable</span>
<a name="line-46"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>failWithTc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>instMsg</span><span class='hs-layout'>)</span> <span class='hs-varid'>typeable_instances</span>
<a name="line-47"></a>
<a name="line-48"></a>       <span class='hs-comment'>-- Check that if the module is compiled with -XSafe, there are no</span>
<a name="line-49"></a>       <span class='hs-comment'>-- hand written instances of old Typeable as then unsafe casts could be</span>
<a name="line-50"></a>       <span class='hs-comment'>-- performed. Derived instances are OK.</span>
<a name="line-51"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-52"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>safeLanguageOn</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-53"></a>             <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>typInstCheck</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-54"></a>                               <span class='hs-layout'>(</span><span class='hs-varid'>addErrAt</span> <span class='hs-layout'>(</span><span class='hs-varid'>getSrcSpan</span> <span class='hs-varop'>$</span> <span class='hs-varid'>iSpec</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>typInstErr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-55"></a>                   <span class='hs-varid'>local_infos</span>
<a name="line-56"></a>       <span class='hs-comment'>-- As above but for Safe Inference mode.</span>
<a name="line-57"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>safeInferOn</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-58"></a>             <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>typInstCheck</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>recordUnsafeInfer</span><span class='hs-layout'>)</span> <span class='hs-varid'>local_infos</span>
<a name="line-59"></a>
<a name="line-60"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>gbl_env</span>
<a name="line-61"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>deriv_inst_info</span> <span class='hs-varop'>++</span> <span class='hs-varid'>local_infos</span>
<a name="line-62"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>deriv_binds</span><span class='hs-layout'>)</span>
<a name="line-63"></a>    <span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-64"></a>  <span class='hs-keyword'>where</span>
<a name="line-65"></a>    <span class='hs-comment'>-- Separate the Typeable instances from the rest</span>
<a name="line-66"></a>    <span class='hs-varid'>splitTypeable</span> <span class='hs-keyword'>_</span>   <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-67"></a>    <span class='hs-varid'>splitTypeable</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-varid'>is</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-68"></a>      <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeableInsts</span><span class='hs-layout'>,</span> <span class='hs-varid'>otherInsts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitTypeable</span> <span class='hs-varid'>env</span> <span class='hs-varid'>is</span>
<a name="line-69"></a>      <span class='hs-keyword'>in</span> <span class='hs-keyword'>if</span> <span class='hs-comment'>-- We will filter out instances of Typeable</span>
<a name="line-70"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>typeableClassName</span> <span class='hs-varop'>==</span> <span class='hs-varid'>is_cls_nm</span> <span class='hs-layout'>(</span><span class='hs-varid'>iSpec</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-71"></a>            <span class='hs-comment'>-- but not those that come from Data.Typeable.Internal</span>
<a name="line-72"></a>            <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>tcg_mod</span> <span class='hs-varid'>env</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>tYPEABLE_INTERNAL</span>
<a name="line-73"></a>            <span class='hs-comment'>-- nor those from an .hs-boot file (deriving can't be used there)</span>
<a name="line-74"></a>            <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isHsBoot</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcg_src</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-75"></a>         <span class='hs-keyword'>then</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-varid'>typeableInsts</span><span class='hs-layout'>,</span> <span class='hs-varid'>otherInsts</span><span class='hs-layout'>)</span>
<a name="line-76"></a>         <span class='hs-keyword'>else</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeableInsts</span><span class='hs-layout'>,</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-varid'>otherInsts</span><span class='hs-layout'>)</span>
<a name="line-77"></a>
<a name="line-78"></a>    <span class='hs-varid'>typInstCheck</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_cls_nm</span> <span class='hs-layout'>(</span><span class='hs-varid'>iSpec</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>oldTypeableClassNames</span>
<a name="line-79"></a>    <span class='hs-varid'>typInstErr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-varop'>$</span> <span class='hs-varid'>sLit</span> <span class='hs-varop'>$</span> <span class='hs-str'>"Can't create hand written instances of Typeable in Safe"</span>
<a name="line-80"></a>                              <span class='hs-varop'>++</span> <span class='hs-str'>" Haskell! Can only derive them"</span>
<a name="line-81"></a>
<a name="line-82"></a>    <span class='hs-varid'>instMsg</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-varop'>$</span> <span class='hs-str'>"Typeable instances can only be derived; replace "</span>
<a name="line-83"></a>                                 <span class='hs-varop'>++</span> <span class='hs-str'>"the following instance:"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-84"></a>                     <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprInstance</span> <span class='hs-layout'>(</span><span class='hs-varid'>iSpec</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-85"></a>
<a name="line-86"></a><a name="addClsInsts"></a><span class='hs-definition'>addClsInsts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InstInfo</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span>
<a name="line-87"></a><span class='hs-definition'>addClsInsts</span> <span class='hs-varid'>infos</span> <span class='hs-varid'>thing_inside</span>
<a name="line-88"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcExtendLocalInstEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>iSpec</span> <span class='hs-varid'>infos</span><span class='hs-layout'>)</span> <span class='hs-varid'>thing_inside</span>
<a name="line-89"></a>
<a name="line-90"></a><a name="addFamInsts"></a><span class='hs-definition'>addFamInsts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>FamInst</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span>
<a name="line-91"></a><span class='hs-comment'>-- Extend (a) the family instance envt</span>
<a name="line-92"></a><span class='hs-comment'>--        (b) the type envt with stuff from data type decls</span>
<a name="line-93"></a><span class='hs-definition'>addFamInsts</span> <span class='hs-varid'>fam_insts</span> <span class='hs-varid'>thing_inside</span>
<a name="line-94"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcExtendLocalFamInstEnv</span> <span class='hs-varid'>fam_insts</span> <span class='hs-varop'>$</span> 
<a name="line-95"></a>    <span class='hs-varid'>tcExtendGlobalEnv</span> <span class='hs-varid'>things</span>  <span class='hs-varop'>$</span> 
<a name="line-96"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"addFamInsts"</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprFamInsts</span> <span class='hs-varid'>fam_insts</span><span class='hs-layout'>)</span>
<a name="line-97"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tcg_env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcAddImplicits</span> <span class='hs-varid'>things</span>
<a name="line-98"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setGblEnv</span> <span class='hs-varid'>tcg_env</span> <span class='hs-varid'>thing_inside</span> <span class='hs-layout'>}</span>
<a name="line-99"></a>  <span class='hs-keyword'>where</span>
<a name="line-100"></a>    <span class='hs-varid'>axioms</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>toBranchedAxiom</span> <span class='hs-varop'>.</span> <span class='hs-varid'>famInstAxiom</span><span class='hs-layout'>)</span> <span class='hs-varid'>fam_insts</span>
<a name="line-101"></a>    <span class='hs-varid'>tycons</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>famInstsRepTyCons</span> <span class='hs-varid'>fam_insts</span>
<a name="line-102"></a>    <span class='hs-varid'>things</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-conid'>ATyCon</span> <span class='hs-varid'>tycons</span> <span class='hs-varop'>++</span> <span class='hs-varid'>map</span> <span class='hs-conid'>ACoAxiom</span> <span class='hs-varid'>axioms</span> 
</pre>\end{code}

Note [Deriving inside TH brackets]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Given a declaration bracket
  [d| data T = A | B deriving( Show ) |]

there is really no point in generating the derived code for deriving(
Show) and then type-checking it. This will happen at the call site
anyway, and the type check should never fail!  Moreover (Trac #6005)
the scoping of the generated code inside the bracket does not seem to 
work out.  

The easy solution is simply not to generate the derived instances at
all.  (A less brutal solution would be to generate them with no
bindings.)  This will become moot when we shift to the new TH plan, so 
the brutal solution will do.


\begin{code}
<pre><a name="line-1"></a><a name="tcLocalInstDecl"></a><span class='hs-definition'>tcLocalInstDecl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LInstDecl</span> <span class='hs-conid'>Name</span>
<a name="line-2"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>InstInfo</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>FamInst</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-3"></a>        <span class='hs-comment'>-- A source-file instance declaration</span>
<a name="line-4"></a>        <span class='hs-comment'>-- Type-check all the stuff before the "where"</span>
<a name="line-5"></a>        <span class='hs-comment'>--</span>
<a name="line-6"></a>        <span class='hs-comment'>-- We check for respectable instance type, and context</span>
<a name="line-7"></a><span class='hs-definition'>tcLocalInstDecl</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyFamInstD</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tfid_inst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decl</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fam_inst</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcTyFamInstDecl</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>decl</span><span class='hs-layout'>)</span>
<a name="line-9"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>fam_inst</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-definition'>tcLocalInstDecl</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataFamInstD</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dfid_inst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decl</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-12"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fam_inst</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcDataFamInstDecl</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>decl</span><span class='hs-layout'>)</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>fam_inst</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-14"></a>
<a name="line-15"></a><span class='hs-definition'>tcLocalInstDecl</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsInstD</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cid_inst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decl</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-16"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>insts</span><span class='hs-layout'>,</span> <span class='hs-varid'>fam_insts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcClsInstDecl</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>decl</span><span class='hs-layout'>)</span>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>insts</span><span class='hs-layout'>,</span> <span class='hs-varid'>fam_insts</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-18"></a>
<a name="line-19"></a><a name="tcClsInstDecl"></a><span class='hs-definition'>tcClsInstDecl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LClsInstDecl</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>InstInfo</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>FamInst</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-20"></a><span class='hs-definition'>tcClsInstDecl</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsInstDecl</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cid_poly_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>poly_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>cid_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>binds</span>
<a name="line-21"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>cid_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uprags</span><span class='hs-layout'>,</span> <span class='hs-varid'>cid_tyfam_insts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ats</span>
<a name="line-22"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>cid_datafam_insts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>adts</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setSrcSpan</span> <span class='hs-varid'>loc</span>                      <span class='hs-varop'>$</span>
<a name="line-24"></a>    <span class='hs-varid'>addErrCtxt</span> <span class='hs-layout'>(</span><span class='hs-varid'>instDeclCtxt1</span> <span class='hs-varid'>poly_ty</span><span class='hs-layout'>)</span>  <span class='hs-varop'>$</span>
<a name="line-25"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>is_boot</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcIsHsBoot</span>
<a name="line-26"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>is_boot</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyLHsBinds</span> <span class='hs-varid'>binds</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>uprags</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-27"></a>                  <span class='hs-varid'>badBootDeclErr</span>
<a name="line-28"></a>
<a name="line-29"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyvars</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>clas</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcHsInstHead</span> <span class='hs-conid'>InstDeclCtxt</span> <span class='hs-varid'>poly_ty</span>
<a name="line-30"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>mini_env</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyVars</span> <span class='hs-varid'>clas</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span>
<a name="line-31"></a>              <span class='hs-varid'>mini_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTvSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkInScopeSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>tyvars</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>mini_env</span>
<a name="line-32"></a>              <span class='hs-varid'>mb_info</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>clas</span><span class='hs-layout'>,</span> <span class='hs-varid'>mini_env</span><span class='hs-layout'>)</span>
<a name="line-33"></a>                           
<a name="line-34"></a>        <span class='hs-comment'>-- Next, process any associated types.</span>
<a name="line-35"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"tcLocalInstDecl"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>poly_ty</span><span class='hs-layout'>)</span>
<a name="line-36"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>tyfam_insts0</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcExtendTyVarEnv</span> <span class='hs-varid'>tyvars</span> <span class='hs-varop'>$</span>
<a name="line-37"></a>                          <span class='hs-varid'>mapAndRecoverM</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcAssocTyDecl</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>mini_env</span><span class='hs-layout'>)</span> <span class='hs-varid'>ats</span>
<a name="line-38"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>datafam_insts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcExtendTyVarEnv</span> <span class='hs-varid'>tyvars</span> <span class='hs-varop'>$</span>
<a name="line-39"></a>                           <span class='hs-varid'>mapAndRecoverM</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcDataFamInstDecl</span> <span class='hs-varid'>mb_info</span><span class='hs-layout'>)</span> <span class='hs-varid'>adts</span>
<a name="line-40"></a>
<a name="line-41"></a>        <span class='hs-comment'>-- Check for missing associated types and build them</span>
<a name="line-42"></a>        <span class='hs-comment'>-- from their defaults (if available)</span>
<a name="line-43"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>defined_ats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNameSet</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyFamInstDeclName</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unLoc</span><span class='hs-layout'>)</span> <span class='hs-varid'>ats</span>
<a name="line-44"></a>              <span class='hs-varid'>defined_adts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNameSet</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>unLoc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>dfid_tycon</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unLoc</span><span class='hs-layout'>)</span> <span class='hs-varid'>adts</span>
<a name="line-45"></a>
<a name="line-46"></a>              <span class='hs-varid'>mk_deflt_at_instances</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClassATItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>FamInst</span><span class='hs-keyglyph'>]</span>
<a name="line-47"></a>              <span class='hs-varid'>mk_deflt_at_instances</span> <span class='hs-layout'>(</span><span class='hs-varid'>fam_tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>defs</span><span class='hs-layout'>)</span>
<a name="line-48"></a>                 <span class='hs-comment'>-- User supplied instances ==&gt; everything is OK</span>
<a name="line-49"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tyConName</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varop'>`elemNameSet`</span> <span class='hs-varid'>defined_ats</span>
<a name="line-50"></a>                   <span class='hs-varop'>||</span> <span class='hs-varid'>tyConName</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varop'>`elemNameSet`</span> <span class='hs-varid'>defined_adts</span>
<a name="line-51"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
<a name="line-52"></a>
<a name="line-53"></a>                 <span class='hs-comment'>-- No defaults ==&gt; generate a warning</span>
<a name="line-54"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>defs</span>
<a name="line-55"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>warnMissingMethodOrAT</span> <span class='hs-str'>"associated type"</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-56"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>}</span>
<a name="line-57"></a>
<a name="line-58"></a>                 <span class='hs-comment'>-- No user instance, have defaults ==&gt; instatiate them</span>
<a name="line-59"></a>                 <span class='hs-comment'>-- Example:   class C a where { type F a b :: *; type F a b = () }</span>
<a name="line-60"></a>                 <span class='hs-comment'>--            instance C [x]</span>
<a name="line-61"></a>                 <span class='hs-comment'>-- Then we want to generate the decl:   type F [x] b = ()</span>
<a name="line-62"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> 
<a name="line-63"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forM</span> <span class='hs-varid'>defs</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>CoAxBranch</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cab_lhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pat_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>cab_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-64"></a>                  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>pat_tys'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTys</span> <span class='hs-varid'>mini_subst</span> <span class='hs-varid'>pat_tys</span>
<a name="line-65"></a>                           <span class='hs-varid'>rhs'</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span>  <span class='hs-varid'>mini_subst</span> <span class='hs-varid'>rhs</span>
<a name="line-66"></a>                           <span class='hs-varid'>tv_set'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>pat_tys'</span>
<a name="line-67"></a>                           <span class='hs-varid'>tvs'</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>varSetElems</span> <span class='hs-varid'>tv_set'</span>
<a name="line-68"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>rep_tc_name</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFamInstTyConName</span> <span class='hs-layout'>(</span><span class='hs-varid'>noLoc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>pat_tys'</span>
<a name="line-69"></a>                     <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>axiom</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSingleCoAxiom</span> <span class='hs-varid'>rep_tc_name</span> <span class='hs-varid'>tvs'</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>pat_tys'</span> <span class='hs-varid'>rhs'</span>
<a name="line-70"></a>                     <span class='hs-layout'>;</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>rhs'</span> <span class='hs-varop'>`subVarSet`</span> <span class='hs-varid'>tv_set'</span> <span class='hs-layout'>)</span> 
<a name="line-71"></a>                       <span class='hs-varid'>newFamInst</span> <span class='hs-conid'>SynFamilyInst</span> <span class='hs-varid'>axiom</span> <span class='hs-layout'>}</span>
<a name="line-72"></a>
<a name="line-73"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>tyfam_insts1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>mk_deflt_at_instances</span> <span class='hs-layout'>(</span><span class='hs-varid'>classATItems</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span>
<a name="line-74"></a>        
<a name="line-75"></a>        <span class='hs-comment'>-- Finally, construct the Core representation of the instance.</span>
<a name="line-76"></a>        <span class='hs-comment'>-- (This no longer includes the associated types.)</span>
<a name="line-77"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>dfun_name</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newDFunName</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span> <span class='hs-layout'>(</span><span class='hs-varid'>getLoc</span> <span class='hs-varid'>poly_ty</span><span class='hs-layout'>)</span>
<a name="line-78"></a>                <span class='hs-comment'>-- Dfun location is that of instance *header*</span>
<a name="line-79"></a>
<a name="line-80"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>overlap_flag</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getOverlapFlag</span>
<a name="line-81"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>tyvars'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInstSkolTyVars</span> <span class='hs-varid'>tyvars</span>
<a name="line-82"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>dfun</span>  	<span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkDictFunId</span> <span class='hs-varid'>dfun_name</span> <span class='hs-varid'>tyvars</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span>
<a name="line-83"></a>              <span class='hs-varid'>ispec</span> 	<span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLocalInstance</span> <span class='hs-varid'>dfun</span> <span class='hs-varid'>overlap_flag</span> <span class='hs-varid'>tyvars'</span> <span class='hs-varid'>clas</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTys</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span>
<a name="line-84"></a>                            <span class='hs-comment'>-- Be sure to freshen those type variables, </span>
<a name="line-85"></a>                            <span class='hs-comment'>-- so they are sure not to appear in any lookup</span>
<a name="line-86"></a>              <span class='hs-varid'>inst_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InstInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>iSpec</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ispec</span>
<a name="line-87"></a>                                   <span class='hs-layout'>,</span> <span class='hs-varid'>iBinds</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InstBindings</span>
<a name="line-88"></a>                                     <span class='hs-layout'>{</span> <span class='hs-varid'>ib_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>binds</span>
<a name="line-89"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>ib_pragmas</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uprags</span>
<a name="line-90"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>ib_extensions</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-91"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>ib_standalone_deriving</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-92"></a>
<a name="line-93"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>inst_info</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>tyfam_insts0</span> <span class='hs-varop'>++</span> <span class='hs-varid'>concat</span> <span class='hs-varid'>tyfam_insts1</span> <span class='hs-varop'>++</span> <span class='hs-varid'>datafam_insts</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-94"></a>
<a name="line-95"></a><a name="tcAssocTyDecl"></a><span class='hs-comment'>--------------</span>
<a name="line-96"></a><span class='hs-definition'>tcAssocTyDecl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Class</span>                   <span class='hs-comment'>-- Class of associated type</span>
<a name="line-97"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>Type</span>             <span class='hs-comment'>-- Instantiation of class TyVars</span>
<a name="line-98"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LTyFamInstDecl</span> <span class='hs-conid'>Name</span>     
<a name="line-99"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>FamInst</span><span class='hs-layout'>)</span>
<a name="line-100"></a><span class='hs-definition'>tcAssocTyDecl</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>mini_env</span> <span class='hs-varid'>ldecl</span>
<a name="line-101"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fam_inst</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcTyFamInstDecl</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>clas</span><span class='hs-layout'>,</span> <span class='hs-varid'>mini_env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>ldecl</span>
<a name="line-102"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>fam_inst</span> <span class='hs-layout'>}</span>
</pre>\end{code}

%************************************************************************
%*                                                                      *
               Type checking family instances
%*                                                                      *
%************************************************************************

Family instances are somewhat of a hybrid.  They are processed together with
class instance heads, but can contain data constructors and hence they share a
lot of kinding and type checking code with ordinary algebraic data types (and
GADTs).

\begin{code}
<pre><a name="line-1"></a><a name="tcFamInstDeclCombined"></a><span class='hs-definition'>tcFamInstDeclCombined</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- the class &amp; mini_env if applicable</span>
<a name="line-2"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Located</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>TyCon</span>
<a name="line-3"></a><span class='hs-definition'>tcFamInstDeclCombined</span> <span class='hs-varid'>mb_clsinfo</span> <span class='hs-varid'>fam_tc_lname</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- Type family instances require -XTypeFamilies</span>
<a name="line-5"></a>         <span class='hs-comment'>-- and can't (currently) be in an hs-boot file</span>
<a name="line-6"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"tcFamInstDecl"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>fam_tc_lname</span><span class='hs-layout'>)</span>
<a name="line-7"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>type_families</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_TypeFamilies</span>
<a name="line-8"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>is_boot</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcIsHsBoot</span>   <span class='hs-comment'>-- Are we compiling an hs-boot file?</span>
<a name="line-9"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-varid'>type_families</span> <span class='hs-varop'>$</span> <span class='hs-varid'>badFamInstDecl</span> <span class='hs-varid'>fam_tc_lname</span>
<a name="line-10"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>is_boot</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>badBootFamInstDeclErr</span>
<a name="line-11"></a>
<a name="line-12"></a>       <span class='hs-comment'>-- Look up the family TyCon and check for validity including</span>
<a name="line-13"></a>       <span class='hs-comment'>-- check that toplevel type instances are not for associated types.</span>
<a name="line-14"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>fam_tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcLookupLocatedTyCon</span> <span class='hs-varid'>fam_tc_lname</span>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isNothing</span> <span class='hs-varid'>mb_clsinfo</span> <span class='hs-varop'>&amp;&amp;</span>   <span class='hs-comment'>-- Not in a class decl</span>
<a name="line-16"></a>               <span class='hs-varid'>isTyConAssoc</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- but an associated type</span>
<a name="line-17"></a>              <span class='hs-layout'>(</span><span class='hs-varid'>addErr</span> <span class='hs-varop'>$</span> <span class='hs-varid'>assocInClassErr</span> <span class='hs-varid'>fam_tc_lname</span><span class='hs-layout'>)</span>
<a name="line-18"></a>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>fam_tc</span> <span class='hs-layout'>}</span>
<a name="line-20"></a>
<a name="line-21"></a><a name="tcTyFamInstDecl"></a><span class='hs-definition'>tcTyFamInstDecl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- the class &amp; mini_env if applicable</span>
<a name="line-22"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LTyFamInstDecl</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>FamInst</span>
<a name="line-23"></a>  <span class='hs-comment'>-- "type instance"</span>
<a name="line-24"></a><span class='hs-definition'>tcTyFamInstDecl</span> <span class='hs-varid'>mb_clsinfo</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>decl</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>TyFamInstDecl</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tfid_eqn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqn</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-25"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setSrcSpan</span> <span class='hs-varid'>loc</span>           <span class='hs-varop'>$</span>
<a name="line-26"></a>    <span class='hs-varid'>tcAddTyFamInstCtxt</span> <span class='hs-varid'>decl</span>  <span class='hs-varop'>$</span>
<a name="line-27"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fam_lname</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tfie_tycon</span> <span class='hs-layout'>(</span><span class='hs-varid'>unLoc</span> <span class='hs-varid'>eqn</span><span class='hs-layout'>)</span>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>fam_tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcFamInstDeclCombined</span> <span class='hs-varid'>mb_clsinfo</span> <span class='hs-varid'>fam_lname</span>
<a name="line-29"></a>
<a name="line-30"></a>         <span class='hs-comment'>-- (0) Check it's an open type family</span>
<a name="line-31"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>isFamilyTyCon</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>        <span class='hs-layout'>(</span><span class='hs-varid'>notFamily</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-32"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSynFamilyTyCon</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>     <span class='hs-layout'>(</span><span class='hs-varid'>wrongKindOfFamily</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-33"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>isOpenSynFamilyTyCon</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>notOpenFamily</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-34"></a>
<a name="line-35"></a>         <span class='hs-comment'>-- (1) do the work of verifying the synonym group</span>
<a name="line-36"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>co_ax_branch</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSynFamInstDecl</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>decl</span>
<a name="line-37"></a>
<a name="line-38"></a>         <span class='hs-comment'>-- (2) check for validity</span>
<a name="line-39"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkValidTyFamInst</span> <span class='hs-varid'>mb_clsinfo</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>co_ax_branch</span>
<a name="line-40"></a>
<a name="line-41"></a>         <span class='hs-comment'>-- (3) construct coercion axiom</span>
<a name="line-42"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rep_tc_name</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFamInstAxiomName</span> <span class='hs-varid'>loc</span>
<a name="line-43"></a>                                            <span class='hs-layout'>(</span><span class='hs-varid'>tyFamInstDeclName</span> <span class='hs-varid'>decl</span><span class='hs-layout'>)</span>
<a name="line-44"></a>                                            <span class='hs-keyglyph'>[</span><span class='hs-varid'>co_ax_branch</span><span class='hs-keyglyph'>]</span>
<a name="line-45"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>axiom</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkUnbranchedCoAxiom</span> <span class='hs-varid'>rep_tc_name</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>co_ax_branch</span>
<a name="line-46"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>newFamInst</span> <span class='hs-conid'>SynFamilyInst</span> <span class='hs-varid'>axiom</span> <span class='hs-layout'>}</span>
<a name="line-47"></a>
<a name="line-48"></a><a name="tcDataFamInstDecl"></a><span class='hs-definition'>tcDataFamInstDecl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>
<a name="line-49"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LDataFamInstDecl</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>FamInst</span>
<a name="line-50"></a>  <span class='hs-comment'>-- "newtype instance" and "data instance"</span>
<a name="line-51"></a><span class='hs-definition'>tcDataFamInstDecl</span> <span class='hs-varid'>mb_clsinfo</span> 
<a name="line-52"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>decl</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>DataFamInstDecl</span>
<a name="line-53"></a>       <span class='hs-layout'>{</span> <span class='hs-varid'>dfid_pats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pats</span>
<a name="line-54"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>dfid_tycon</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fam_tc_name</span>
<a name="line-55"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>dfid_defn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defn</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>HsDataDefn</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dd_ND</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_or_data</span><span class='hs-layout'>,</span> <span class='hs-varid'>dd_cType</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cType</span>
<a name="line-56"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>dd_ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>,</span> <span class='hs-varid'>dd_cons</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cons</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-57"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setSrcSpan</span> <span class='hs-varid'>loc</span>             <span class='hs-varop'>$</span>
<a name="line-58"></a>    <span class='hs-varid'>tcAddDataFamInstCtxt</span> <span class='hs-varid'>decl</span>  <span class='hs-varop'>$</span>
<a name="line-59"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fam_tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcFamInstDeclCombined</span> <span class='hs-varid'>mb_clsinfo</span> <span class='hs-varid'>fam_tc_name</span>
<a name="line-60"></a>
<a name="line-61"></a>         <span class='hs-comment'>-- Check that the family declaration is for the right kind</span>
<a name="line-62"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>isFamilyTyCon</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>notFamily</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-63"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>isAlgTyCon</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrongKindOfFamily</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-64"></a>
<a name="line-65"></a>         <span class='hs-comment'>-- Kind check type patterns</span>
<a name="line-66"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tcFamTyPats</span> <span class='hs-layout'>(</span><span class='hs-varid'>unLoc</span> <span class='hs-varid'>fam_tc_name</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConKind</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>pats</span>
<a name="line-67"></a>                     <span class='hs-layout'>(</span><span class='hs-varid'>kcDataDefn</span> <span class='hs-varid'>defn</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> 
<a name="line-68"></a>           <span class='hs-keyglyph'>\</span><span class='hs-varid'>tvs'</span> <span class='hs-varid'>pats'</span> <span class='hs-varid'>res_kind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-69"></a>
<a name="line-70"></a>       <span class='hs-layout'>{</span> <span class='hs-comment'>-- Check that left-hand side contains no type family applications</span>
<a name="line-71"></a>         <span class='hs-comment'>-- (vanilla synonyms are fine, though, and we checked for</span>
<a name="line-72"></a>         <span class='hs-comment'>--  foralls earlier)</span>
<a name="line-73"></a>         <span class='hs-varid'>checkValidFamPats</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>tvs'</span> <span class='hs-varid'>pats'</span>
<a name="line-74"></a>         <span class='hs-comment'>-- Check that type patterns match class instance head, if any</span>
<a name="line-75"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkConsistentFamInst</span> <span class='hs-varid'>mb_clsinfo</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>tvs'</span> <span class='hs-varid'>pats'</span>
<a name="line-76"></a>         
<a name="line-77"></a>         <span class='hs-comment'>-- Result kind must be '*' (otherwise, we have too few patterns)</span>
<a name="line-78"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>isLiftedTypeKind</span> <span class='hs-varid'>res_kind</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tooFewParmsErr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConArity</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-79"></a>
<a name="line-80"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>stupid_theta</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcHsContext</span> <span class='hs-varid'>ctxt</span>
<a name="line-81"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>h98_syntax</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dataDeclChecks</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_or_data</span> <span class='hs-varid'>stupid_theta</span> <span class='hs-varid'>cons</span>
<a name="line-82"></a>
<a name="line-83"></a>         <span class='hs-comment'>-- Construct representation tycon</span>
<a name="line-84"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rep_tc_name</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFamInstTyConName</span> <span class='hs-varid'>fam_tc_name</span> <span class='hs-varid'>pats'</span>
<a name="line-85"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>axiom_name</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newImplicitBinder</span> <span class='hs-varid'>rep_tc_name</span> <span class='hs-varid'>mkInstTyCoOcc</span>
<a name="line-86"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>orig_res_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>pats'</span>
<a name="line-87"></a>
<a name="line-88"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>fam_inst</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>fixM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>rec_rep_tc</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-89"></a>           <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>data_cons</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcConDecls</span> <span class='hs-varid'>new_or_data</span> <span class='hs-varid'>rec_rep_tc</span>
<a name="line-90"></a>                                       <span class='hs-layout'>(</span><span class='hs-varid'>tvs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>orig_res_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>cons</span>
<a name="line-91"></a>              <span class='hs-layout'>;</span> <span class='hs-varid'>tc_rhs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>new_or_data</span> <span class='hs-keyword'>of</span>
<a name="line-92"></a>                     <span class='hs-conid'>DataType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkDataTyConRhs</span> <span class='hs-varid'>data_cons</span><span class='hs-layout'>)</span>
<a name="line-93"></a>                     <span class='hs-conid'>NewType</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>data_cons</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-94"></a>                                 <span class='hs-varid'>mkNewTyConRhs</span> <span class='hs-varid'>rep_tc_name</span> <span class='hs-varid'>rec_rep_tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>data_cons</span><span class='hs-layout'>)</span>
<a name="line-95"></a>              <span class='hs-comment'>-- freshen tyvars</span>
<a name="line-96"></a>              <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>eta_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>eta_pats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eta_reduce</span> <span class='hs-varid'>tvs'</span> <span class='hs-varid'>pats'</span>
<a name="line-97"></a>                    <span class='hs-varid'>axiom</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSingleCoAxiom</span> <span class='hs-varid'>axiom_name</span> <span class='hs-varid'>eta_tvs</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>eta_pats</span> 
<a name="line-98"></a>                                               <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>rep_tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTys</span> <span class='hs-varid'>eta_tvs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-99"></a>                    <span class='hs-varid'>parent</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FamInstTyCon</span> <span class='hs-varid'>axiom</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>pats'</span>
<a name="line-100"></a>                    <span class='hs-varid'>roles</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs'</span>
<a name="line-101"></a>                    <span class='hs-varid'>rep_tc</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>buildAlgTyCon</span> <span class='hs-varid'>rep_tc_name</span> <span class='hs-varid'>tvs'</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>cType</span> <span class='hs-varid'>stupid_theta</span> <span class='hs-varid'>tc_rhs</span> 
<a name="line-102"></a>                                             <span class='hs-conid'>Recursive</span> 
<a name="line-103"></a>                                             <span class='hs-conid'>False</span>      <span class='hs-comment'>-- No promotable to the kind level</span>
<a name="line-104"></a>                                             <span class='hs-varid'>h98_syntax</span> <span class='hs-varid'>parent</span>
<a name="line-105"></a>                 <span class='hs-comment'>-- We always assume that indexed types are recursive.  Why?</span>
<a name="line-106"></a>                 <span class='hs-comment'>-- (1) Due to their open nature, we can never be sure that a</span>
<a name="line-107"></a>                 <span class='hs-comment'>-- further instance might not introduce a new recursive</span>
<a name="line-108"></a>                 <span class='hs-comment'>-- dependency.  (2) They are always valid loop breakers as</span>
<a name="line-109"></a>                 <span class='hs-comment'>-- they involve a coercion.</span>
<a name="line-110"></a>              <span class='hs-layout'>;</span> <span class='hs-varid'>fam_inst</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFamInst</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataFamilyInst</span> <span class='hs-varid'>rep_tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>axiom</span>
<a name="line-111"></a>              <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>fam_inst</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-112"></a>
<a name="line-113"></a>         <span class='hs-comment'>-- Remember to check validity; no recursion to worry about here</span>
<a name="line-114"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkValidTyCon</span> <span class='hs-varid'>rep_tc</span>
<a name="line-115"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>fam_inst</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-116"></a>  <span class='hs-keyword'>where</span>
<a name="line-117"></a>    <span class='hs-comment'>-- See Note [Eta reduction for data family axioms]</span>
<a name="line-118"></a>    <span class='hs-comment'>--  [a,b,c,d].T [a] c Int c d  ==&gt;  [a,b,c]. T [a] c Int c</span>
<a name="line-119"></a>    <span class='hs-varid'>eta_reduce</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>pats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span>
<a name="line-120"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span><span class='hs-conop'>:</span><span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>pat</span><span class='hs-conop'>:</span><span class='hs-varid'>pats</span><span class='hs-layout'>)</span>
<a name="line-121"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTyVar_maybe</span> <span class='hs-varid'>pat</span>
<a name="line-122"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tv'</span>
<a name="line-123"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span>
<a name="line-124"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>pats</span>
<a name="line-125"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>pats</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span>
<a name="line-126"></a>
</pre>\end{code}

Note [Eta reduction for data family axioms]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider this
   data family T a b :: *
   newtype instance T Int a = MkT (IO a) deriving( Monad )
We'd like this to work.  From the 'newtype instance' you might
think we'd get:
   newtype TInt a = MkT (IO a)
   axiom ax1 a :: T Int a ~ TInt a   -- The type-instance part
   axiom ax2 a :: TInt a ~ IO a      -- The newtype part

But now what can we do?  We have this problem
   Given:   d  :: Monad IO
   Wanted:  d' :: Monad (T Int) = d |> ????
What coercion can we use for the ???

Solution: eta-reduce both axioms, thus:
   axiom ax1 :: T Int ~ TInt
   axiom ax2 :: TInt ~ IO
Now
   d' = d |> Monad (sym (ax2 ; ax1))

This eta reduction happens both for data instances and newtype instances.

See Note [Newtype eta] in TyCon.



%************************************************************************
%*                                                                      *
      Type-checking instance declarations, pass 2
%*                                                                      *
%************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="tcInstDecls2"></a><span class='hs-definition'>tcInstDecls2</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LTyClDecl</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InstInfo</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span>
<a name="line-2"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsBinds</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-comment'>-- (a) From each class declaration,</span>
<a name="line-4"></a><span class='hs-comment'>--      generate any default-method bindings</span>
<a name="line-5"></a><span class='hs-comment'>-- (b) From each instance decl</span>
<a name="line-6"></a><span class='hs-comment'>--      generate the dfun binding</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-definition'>tcInstDecls2</span> <span class='hs-varid'>tycl_decls</span> <span class='hs-varid'>inst_decls</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-comment'>-- (a) Default methods from class decls</span>
<a name="line-10"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>class_decls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>isClassDecl</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unLoc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tycl_decls</span>
<a name="line-11"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>dm_binds_s</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>tcClassDecl2</span> <span class='hs-varid'>class_decls</span>
<a name="line-12"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>dm_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unionManyBags</span> <span class='hs-varid'>dm_binds_s</span>
<a name="line-13"></a>
<a name="line-14"></a>          <span class='hs-comment'>-- (b) instance declarations</span>
<a name="line-15"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>dm_ids</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectHsBindsBinders</span> <span class='hs-varid'>dm_binds</span>
<a name="line-16"></a>              <span class='hs-comment'>-- Add the default method Ids (again)</span>
<a name="line-17"></a>              <span class='hs-comment'>-- See Note [Default methods and instances]</span>
<a name="line-18"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>inst_binds_s</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcExtendLetEnv</span> <span class='hs-conid'>TopLevel</span> <span class='hs-conid'>TopLevel</span> <span class='hs-varid'>dm_ids</span> <span class='hs-varop'>$</span>
<a name="line-19"></a>                          <span class='hs-varid'>mapM</span> <span class='hs-varid'>tcInstDecl2</span> <span class='hs-varid'>inst_decls</span>
<a name="line-20"></a>
<a name="line-21"></a>          <span class='hs-comment'>-- Done</span>
<a name="line-22"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>dm_binds</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>unionManyBags</span> <span class='hs-varid'>inst_binds_s</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

See Note [Default methods and instances]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The default method Ids are already in the type environment (see Note
[Default method Ids and Template Haskell] in TcTyClsDcls), BUT they
don't have their InlinePragmas yet.  Usually that would not matter,
because the simplifier propagates information from binding site to
use.  But, unusually, when compiling instance decls we *copy* the
INLINE pragma from the default method to the method for that
particular operation (see Note [INLINE and default methods] below).

So right here in tcInstDecls2 we must re-extend the type envt with
the default method Ids replete with their INLINE pragmas.  Urk.

\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a><a name="tcInstDecl2"></a><span class='hs-definition'>tcInstDecl2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstInfo</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsBinds</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span>
<a name="line-3"></a>            <span class='hs-comment'>-- Returns a binding for the dfun</span>
<a name="line-4"></a><span class='hs-definition'>tcInstDecl2</span> <span class='hs-layout'>(</span><span class='hs-conid'>InstInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>iSpec</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ispec</span><span class='hs-layout'>,</span> <span class='hs-varid'>iBinds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ibinds</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-5"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>recoverM</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-varid'>emptyLHsBinds</span><span class='hs-layout'>)</span>             <span class='hs-varop'>$</span>
<a name="line-6"></a>    <span class='hs-varid'>setSrcSpan</span> <span class='hs-varid'>loc</span>                              <span class='hs-varop'>$</span>
<a name="line-7"></a>    <span class='hs-varid'>addErrCtxt</span> <span class='hs-layout'>(</span><span class='hs-varid'>instDeclCtxt2</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>dfun_id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-8"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>  <span class='hs-comment'>-- Instantiate the instance decl with skolem constants</span>
<a name="line-9"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>inst_tyvars</span><span class='hs-layout'>,</span> <span class='hs-varid'>dfun_theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_head</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSkolDFunType</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>dfun_id</span><span class='hs-layout'>)</span>
<a name="line-10"></a>                     <span class='hs-comment'>-- We instantiate the dfun_id with superSkolems.</span>
<a name="line-11"></a>                     <span class='hs-comment'>-- See Note [Subtle interaction of recursion and overlap]</span>
<a name="line-12"></a>                     <span class='hs-comment'>-- and Note [Binding when looking up instances]</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>clas</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitDFunHead</span> <span class='hs-varid'>inst_head</span>
<a name="line-14"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>class_tyvars</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_theta</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>op_items</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classBigSig</span> <span class='hs-varid'>clas</span>
<a name="line-15"></a>             <span class='hs-varid'>sc_theta'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTheta</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipOpenTvSubst</span> <span class='hs-varid'>class_tyvars</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>sc_theta</span>
<a name="line-16"></a>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>dfun_ev_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newEvVars</span> <span class='hs-varid'>dfun_theta</span>
<a name="line-18"></a>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_binds</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_ev_vars</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSuperClasses</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>inst_tyvars</span> <span class='hs-varid'>dfun_ev_vars</span> <span class='hs-varid'>sc_theta'</span>
<a name="line-20"></a>
<a name="line-21"></a>       <span class='hs-comment'>-- Deal with 'SPECIALISE instance' pragmas</span>
<a name="line-22"></a>       <span class='hs-comment'>-- See Note [SPECIALISE instance pragmas]</span>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>spec_inst_info</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>spec_inst_prags</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSpecInstPrags</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>ibinds</span>
<a name="line-24"></a>
<a name="line-25"></a>        <span class='hs-comment'>-- Typecheck the methods</span>
<a name="line-26"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>meth_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>meth_binds</span><span class='hs-layout'>)</span>
<a name="line-27"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcExtendTyVarEnv</span> <span class='hs-varid'>inst_tyvars</span> <span class='hs-varop'>$</span>
<a name="line-28"></a>                <span class='hs-comment'>-- The inst_tyvars scope over the 'where' part</span>
<a name="line-29"></a>                <span class='hs-comment'>-- Those tyvars are inside the dfun_id's type, which is a bit</span>
<a name="line-30"></a>                <span class='hs-comment'>-- bizarre, but OK so long as you realise it!</span>
<a name="line-31"></a>              <span class='hs-varid'>tcInstanceMethods</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tyvars</span> <span class='hs-varid'>dfun_ev_vars</span>
<a name="line-32"></a>                                <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>spec_inst_info</span>
<a name="line-33"></a>                                <span class='hs-varid'>op_items</span> <span class='hs-varid'>ibinds</span>
<a name="line-34"></a>
<a name="line-35"></a>       <span class='hs-comment'>-- Create the result bindings</span>
<a name="line-36"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>self_dict</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newDict</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span>
<a name="line-37"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>class_tc</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classTyCon</span> <span class='hs-varid'>clas</span>
<a name="line-38"></a>             <span class='hs-keyglyph'>[</span><span class='hs-varid'>dict_constr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>class_tc</span>
<a name="line-39"></a>             <span class='hs-varid'>dict_bind</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarBind</span> <span class='hs-varid'>self_dict</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>con_app_args</span><span class='hs-layout'>)</span>
<a name="line-40"></a>
<a name="line-41"></a>                     <span class='hs-comment'>-- We don't produce a binding for the dict_constr; instead we</span>
<a name="line-42"></a>                     <span class='hs-comment'>-- rely on the simplifier to unfold this saturated application</span>
<a name="line-43"></a>                     <span class='hs-comment'>-- We do this rather than generate an HsCon directly, because</span>
<a name="line-44"></a>                     <span class='hs-comment'>-- it means that the special cases (e.g. dictionary with only one</span>
<a name="line-45"></a>                     <span class='hs-comment'>-- member) are dealt with by the common MkId.mkDataConWrapId</span>
<a name="line-46"></a>                     <span class='hs-comment'>-- code rather than needing to be repeated here.</span>
<a name="line-47"></a>                     <span class='hs-comment'>--    con_app_tys  = MkD ty1 ty2</span>
<a name="line-48"></a>                     <span class='hs-comment'>--    con_app_scs  = MkD ty1 ty2 sc1 sc2</span>
<a name="line-49"></a>                     <span class='hs-comment'>--    con_app_args = MkD ty1 ty2 sc1 sc2 op1 op2</span>
<a name="line-50"></a>             <span class='hs-varid'>con_app_tys</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrapId</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkWpTyApps</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span>
<a name="line-51"></a>                                   <span class='hs-layout'>(</span><span class='hs-varid'>dataConWrapId</span> <span class='hs-varid'>dict_constr</span><span class='hs-layout'>)</span>
<a name="line-52"></a>             <span class='hs-varid'>con_app_scs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkHsWrap</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkWpEvApps</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-conid'>EvId</span> <span class='hs-varid'>sc_ev_vars</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>con_app_tys</span>
<a name="line-53"></a>             <span class='hs-varid'>con_app_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-varid'>app_to_meth</span> <span class='hs-varid'>con_app_scs</span> <span class='hs-varid'>meth_ids</span>
<a name="line-54"></a>
<a name="line-55"></a>             <span class='hs-varid'>app_to_meth</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsExpr</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsExpr</span> <span class='hs-conid'>Id</span>
<a name="line-56"></a>             <span class='hs-varid'>app_to_meth</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>meth_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>`HsApp`</span> <span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrapId</span> <span class='hs-varid'>arg_wrapper</span> <span class='hs-varid'>meth_id</span><span class='hs-layout'>)</span>
<a name="line-57"></a>
<a name="line-58"></a>             <span class='hs-varid'>inst_tv_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTys</span> <span class='hs-varid'>inst_tyvars</span>
<a name="line-59"></a>             <span class='hs-varid'>arg_wrapper</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWpEvVarApps</span> <span class='hs-varid'>dfun_ev_vars</span> <span class='hs-varop'>&lt;.&gt;</span> <span class='hs-varid'>mkWpTyApps</span> <span class='hs-varid'>inst_tv_tys</span>
<a name="line-60"></a>
<a name="line-61"></a>                <span class='hs-comment'>-- Do not inline the dfun; instead give it a magic DFunFunfolding</span>
<a name="line-62"></a>                <span class='hs-comment'>-- See Note [ClassOp/DFun selection]</span>
<a name="line-63"></a>                <span class='hs-comment'>-- See also note [Single-method classes]</span>
<a name="line-64"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>dfun_id_w_fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>dfun_spec_prags</span><span class='hs-layout'>)</span>
<a name="line-65"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-varid'>class_tc</span>
<a name="line-66"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varop'>`setInlinePragma`</span> <span class='hs-varid'>alwaysInlinePragma</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inl_sat</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-num'>0</span> <span class='hs-layout'>}</span>
<a name="line-67"></a>                  <span class='hs-layout'>,</span> <span class='hs-conid'>SpecPrags</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>)</span>   <span class='hs-comment'>-- Newtype dfuns just inline unconditionally,</span>
<a name="line-68"></a>                                     <span class='hs-comment'>-- so don't attempt to specialise them</span>
<a name="line-69"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-70"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varop'>`setIdUnfolding`</span>  <span class='hs-varid'>mkDFunUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>inst_tyvars</span> <span class='hs-varop'>++</span> <span class='hs-varid'>dfun_ev_vars</span><span class='hs-layout'>)</span>
<a name="line-71"></a>                                                              <span class='hs-varid'>dict_constr</span> <span class='hs-varid'>dfun_args</span>
<a name="line-72"></a>                            <span class='hs-varop'>`setInlinePragma`</span> <span class='hs-varid'>dfunInlinePragma</span>
<a name="line-73"></a>                  <span class='hs-layout'>,</span> <span class='hs-conid'>SpecPrags</span> <span class='hs-varid'>spec_inst_prags</span> <span class='hs-layout'>)</span>
<a name="line-74"></a>
<a name="line-75"></a>             <span class='hs-varid'>dfun_args</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span>
<a name="line-76"></a>             <span class='hs-varid'>dfun_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>inst_tys</span>        <span class='hs-varop'>++</span>
<a name="line-77"></a>                         <span class='hs-varid'>map</span> <span class='hs-conid'>Var</span>  <span class='hs-varid'>sc_ev_vars</span>      <span class='hs-varop'>++</span> 
<a name="line-78"></a>                         <span class='hs-varid'>map</span> <span class='hs-varid'>mk_meth_app</span> <span class='hs-varid'>meth_ids</span>
<a name="line-79"></a>             <span class='hs-varid'>mk_meth_app</span> <span class='hs-varid'>meth_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>meth_id</span> <span class='hs-varop'>`mkTyApps`</span> <span class='hs-varid'>inst_tv_tys</span> <span class='hs-varop'>`mkVarApps`</span> <span class='hs-varid'>dfun_ev_vars</span> 
<a name="line-80"></a>
<a name="line-81"></a>             <span class='hs-varid'>export</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ABE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>abe_wrap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idHsWrapper</span><span class='hs-layout'>,</span> <span class='hs-varid'>abe_poly</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun_id_w_fun</span>
<a name="line-82"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>abe_mono</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>self_dict</span><span class='hs-layout'>,</span> <span class='hs-varid'>abe_prags</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun_spec_prags</span> <span class='hs-layout'>}</span>
<a name="line-83"></a>                          <span class='hs-comment'>-- NB: see Note [SPECIALISE instance pragmas]</span>
<a name="line-84"></a>             <span class='hs-varid'>main_bind</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AbsBinds</span> <span class='hs-layout'>{</span> <span class='hs-varid'>abs_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inst_tyvars</span>
<a name="line-85"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>abs_ev_vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun_ev_vars</span>
<a name="line-86"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>abs_exports</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>export</span><span class='hs-keyglyph'>]</span>
<a name="line-87"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>abs_ev_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sc_binds</span>
<a name="line-88"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>abs_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitBag</span> <span class='hs-varid'>dict_bind</span> <span class='hs-layout'>}</span>
<a name="line-89"></a>
<a name="line-90"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>main_bind</span><span class='hs-layout'>)</span> <span class='hs-varop'>`unionBags`</span>
<a name="line-91"></a>                 <span class='hs-varid'>listToBag</span> <span class='hs-varid'>meth_binds</span><span class='hs-layout'>)</span>
<a name="line-92"></a>       <span class='hs-layout'>}</span>
<a name="line-93"></a> <span class='hs-keyword'>where</span>
<a name="line-94"></a>   <span class='hs-varid'>dfun_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>instanceDFunId</span> <span class='hs-varid'>ispec</span>
<a name="line-95"></a>   <span class='hs-varid'>loc</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSrcSpan</span> <span class='hs-varid'>dfun_id</span>
<a name="line-96"></a>
<a name="line-97"></a><a name="tcSuperClasses"></a><span class='hs-comment'>------------------------------</span>
<a name="line-98"></a><span class='hs-definition'>tcSuperClasses</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DFunId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcThetaType</span>
<a name="line-99"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcEvBinds</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-100"></a><span class='hs-comment'>-- See Note [Silent superclass arguments]</span>
<a name="line-101"></a><span class='hs-definition'>tcSuperClasses</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>inst_tyvars</span> <span class='hs-varid'>dfun_ev_vars</span> <span class='hs-varid'>sc_theta</span>
<a name="line-102"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>   <span class='hs-comment'>-- Check that all superclasses can be deduced from</span>
<a name="line-103"></a>           <span class='hs-comment'>-- the originally-specified dfun arguments</span>
<a name="line-104"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_binds</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_evs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>checkConstraints</span> <span class='hs-conid'>InstSkol</span> <span class='hs-varid'>inst_tyvars</span> <span class='hs-varid'>orig_ev_vars</span> <span class='hs-varop'>$</span>
<a name="line-105"></a>                               <span class='hs-varid'>emitWanteds</span> <span class='hs-conid'>ScOrigin</span> <span class='hs-varid'>sc_theta</span>
<a name="line-106"></a>
<a name="line-107"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>inst_tyvars</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>dfun_ev_vars</span> 
<a name="line-108"></a>         <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_binds</span><span class='hs-layout'>,</span>       <span class='hs-varid'>sc_evs</span><span class='hs-layout'>)</span>
<a name="line-109"></a>         <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyTcEvBinds</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_lam_args</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-110"></a>  <span class='hs-keyword'>where</span>
<a name="line-111"></a>    <span class='hs-varid'>n_silent</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfunNSilent</span> <span class='hs-varid'>dfun_id</span>
<a name="line-112"></a>    <span class='hs-varid'>orig_ev_vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>drop</span> <span class='hs-varid'>n_silent</span> <span class='hs-varid'>dfun_ev_vars</span>
<a name="line-113"></a>
<a name="line-114"></a>    <span class='hs-varid'>sc_lam_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>find</span> <span class='hs-varid'>dfun_ev_vars</span><span class='hs-layout'>)</span> <span class='hs-varid'>sc_theta</span>
<a name="line-115"></a>    <span class='hs-varid'>find</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>pred</span> 
<a name="line-116"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"tcInstDecl2"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>dfun_id</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-117"></a>    <span class='hs-varid'>find</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev</span><span class='hs-conop'>:</span><span class='hs-varid'>evs</span><span class='hs-layout'>)</span> <span class='hs-varid'>pred</span> 
<a name="line-118"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>pred</span> <span class='hs-varop'>`eqPred`</span> <span class='hs-varid'>evVarPred</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span>
<a name="line-119"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>find</span> <span class='hs-varid'>evs</span> <span class='hs-varid'>pred</span>
<a name="line-120"></a>
<a name="line-121"></a><a name="mkMethIds"></a><span class='hs-comment'>----------------------</span>
<a name="line-122"></a><span class='hs-definition'>mkMethIds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsSigFun</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span> 
<a name="line-123"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcId</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcSigInfo</span><span class='hs-layout'>)</span>
<a name="line-124"></a><span class='hs-definition'>mkMethIds</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tyvars</span> <span class='hs-varid'>dfun_ev_vars</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>sel_id</span>
<a name="line-125"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>sel_occ</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nameOccName</span> <span class='hs-varid'>sel_name</span>
<a name="line-126"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>meth_name</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newName</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkClassOpAuxOcc</span> <span class='hs-varid'>sel_occ</span><span class='hs-layout'>)</span>
<a name="line-127"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>local_meth_name</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newName</span> <span class='hs-varid'>sel_occ</span>
<a name="line-128"></a>                  <span class='hs-comment'>-- Base the local_meth_name on the selector name, because</span>
<a name="line-129"></a>                  <span class='hs-comment'>-- type errors from tcInstanceMethodBody come from here</span>
<a name="line-130"></a>
<a name="line-131"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>local_meth_sig</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupHsSig</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>sel_name</span> <span class='hs-keyword'>of</span>
<a name="line-132"></a>            <span class='hs-conid'>Just</span> <span class='hs-varid'>hs_ty</span>  <span class='hs-comment'>-- There is a signature in the instance declaration</span>
<a name="line-133"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sig_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>check_inst_sig</span> <span class='hs-varid'>hs_ty</span>
<a name="line-134"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>instTcTySig</span> <span class='hs-varid'>hs_ty</span> <span class='hs-varid'>sig_ty</span> <span class='hs-varid'>local_meth_name</span> <span class='hs-layout'>}</span>
<a name="line-135"></a>
<a name="line-136"></a>            <span class='hs-conid'>Nothing</span>     <span class='hs-comment'>-- No type signature</span>
<a name="line-137"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getSrcSpanM</span>
<a name="line-138"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>instTcTySigFromId</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLocalId</span> <span class='hs-varid'>local_meth_name</span> <span class='hs-varid'>local_meth_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-139"></a>              <span class='hs-comment'>-- Absent a type sig, there are no new scoped type variables here</span>
<a name="line-140"></a>              <span class='hs-comment'>-- Only the ones from the instance decl itself, which are already</span>
<a name="line-141"></a>              <span class='hs-comment'>-- in scope.  Example:</span>
<a name="line-142"></a>              <span class='hs-comment'>--      class C a where { op :: forall b. Eq b =&gt; ... }</span>
<a name="line-143"></a>              <span class='hs-comment'>--      instance C [c] where { op = &lt;rhs&gt; }</span>
<a name="line-144"></a>              <span class='hs-comment'>-- In &lt;rhs&gt;, 'c' is scope but 'b' is not!</span>
<a name="line-145"></a>
<a name="line-146"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>meth_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLocalId</span> <span class='hs-varid'>meth_name</span> <span class='hs-varid'>meth_ty</span>
<a name="line-147"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>meth_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>local_meth_sig</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-148"></a>  <span class='hs-keyword'>where</span>
<a name="line-149"></a>    <span class='hs-varid'>sel_name</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idName</span> <span class='hs-varid'>sel_id</span>
<a name="line-150"></a>    <span class='hs-varid'>local_meth_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>instantiateMethod</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>inst_tys</span>
<a name="line-151"></a>    <span class='hs-varid'>meth_ty</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkForAllTys</span> <span class='hs-varid'>tyvars</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkPiTypes</span> <span class='hs-varid'>dfun_ev_vars</span> <span class='hs-varid'>local_meth_ty</span>
<a name="line-152"></a>
<a name="line-153"></a>    <span class='hs-comment'>-- Check that any type signatures have exactly the right type</span>
<a name="line-154"></a>    <span class='hs-varid'>check_inst_sig</span> <span class='hs-varid'>hs_ty</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> 
<a name="line-155"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setSrcSpan</span> <span class='hs-varid'>loc</span> <span class='hs-varop'>$</span> 
<a name="line-156"></a>         <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sig_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcHsSigType</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunSigCtxt</span> <span class='hs-varid'>sel_name</span><span class='hs-layout'>)</span> <span class='hs-varid'>hs_ty</span>
<a name="line-157"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>inst_sigs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_InstanceSigs</span>
<a name="line-158"></a>            <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>inst_sigs</span> <span class='hs-keyword'>then</span> 
<a name="line-159"></a>                <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>sig_ty</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>local_meth_ty</span><span class='hs-layout'>)</span>
<a name="line-160"></a>                       <span class='hs-layout'>(</span><span class='hs-varid'>badInstSigErr</span> <span class='hs-varid'>sel_name</span> <span class='hs-varid'>local_meth_ty</span><span class='hs-layout'>)</span>
<a name="line-161"></a>              <span class='hs-keyword'>else</span>
<a name="line-162"></a>                <span class='hs-varid'>addErrTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>misplacedInstSig</span> <span class='hs-varid'>sel_name</span> <span class='hs-varid'>hs_ty</span><span class='hs-layout'>)</span>
<a name="line-163"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>sig_ty</span> <span class='hs-layout'>}</span>
<a name="line-164"></a>
<a name="line-165"></a><a name="badInstSigErr"></a><span class='hs-definition'>badInstSigErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-166"></a><span class='hs-definition'>badInstSigErr</span> <span class='hs-varid'>meth</span> <span class='hs-varid'>ty</span>
<a name="line-167"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>env0</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInitTidyEnv</span>
<a name="line-168"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tidy_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tidyType</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>ty</span>
<a name="line-169"></a>                 <span class='hs-comment'>-- Tidy the type using the ambient TidyEnv, </span>
<a name="line-170"></a>                 <span class='hs-comment'>-- to avoid apparent name capture (Trac #7475)</span>
<a name="line-171"></a>                 <span class='hs-comment'>--    class C a where { op :: a -&gt; b }</span>
<a name="line-172"></a>                 <span class='hs-comment'>--    instance C (a-&gt;b) where</span>
<a name="line-173"></a>                 <span class='hs-comment'>--       op :: forall x. x</span>
<a name="line-174"></a>                 <span class='hs-comment'>--       op = ...blah...</span>
<a name="line-175"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>addErrTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Method signature does not match class; it should be"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-176"></a>                      <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprPrefixName</span> <span class='hs-varid'>meth</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tidy_ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-177"></a>
<a name="line-178"></a><a name="misplacedInstSig"></a><span class='hs-definition'>misplacedInstSig</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LHsType</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-179"></a><span class='hs-definition'>misplacedInstSig</span> <span class='hs-varid'>name</span> <span class='hs-varid'>hs_ty</span>
<a name="line-180"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal type signature in instance declaration:"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-181"></a>              <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprPrefixName</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-182"></a>                    <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>hs_ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-183"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"(Use InstanceSigs to allow this)"</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-184"></a>
<a name="line-185"></a><a name="tcSpecInstPrags"></a><span class='hs-comment'>------------------------------</span>
<a name="line-186"></a><span class='hs-definition'>tcSpecInstPrags</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DFunId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InstBindings</span> <span class='hs-conid'>Name</span>
<a name="line-187"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Located</span> <span class='hs-conid'>TcSpecPrag</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>PragFun</span><span class='hs-layout'>)</span>
<a name="line-188"></a><span class='hs-definition'>tcSpecInstPrags</span> <span class='hs-varid'>dfun_id</span> <span class='hs-layout'>(</span><span class='hs-conid'>InstBindings</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ib_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>binds</span><span class='hs-layout'>,</span> <span class='hs-varid'>ib_pragmas</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uprags</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-189"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>spec_inst_prags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrapLocM</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcSpecInst</span> <span class='hs-varid'>dfun_id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-190"></a>                            <span class='hs-varid'>filter</span> <span class='hs-varid'>isSpecInstLSig</span> <span class='hs-varid'>uprags</span>
<a name="line-191"></a>             <span class='hs-comment'>-- The filter removes the pragmas for methods</span>
<a name="line-192"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_inst_prags</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkPragFun</span> <span class='hs-varid'>uprags</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Silent superclass arguments]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
See Trac #3731, #4809, #5751, #5913, #6117, which all
describe somewhat more complicated situations, but ones
encountered in practice.  

      THE PROBLEM

The problem is that it is all too easy to create a class whose
superclass is bottom when it should not be.

Consider the following (extreme) situation:
        class C a => D a where ...
        instance D [a] => D [a] where ...
Although this looks wrong (assume D [a] to prove D [a]), it is only a
more extreme case of what happens with recursive dictionaries, and it
can, just about, make sense because the methods do some work before
recursing.

To implement the dfun we must generate code for the superclass C [a],
which we had better not get by superclass selection from the supplied
argument:
       dfun :: forall a. D [a] -> D [a]
       dfun = \d::D [a] -> MkD (scsel d) ..

Otherwise if we later encounter a situation where
we have a [Wanted] dw::D [a] we might solve it thus:
     dw := dfun dw
Which is all fine except that now ** the superclass C is bottom **!

      THE SOLUTION

Our solution to this problem "silent superclass arguments".  We pass
to each dfun some ``silent superclass arguments’’, which are the
immediate superclasses of the dictionary we are trying to
construct. In our example:
       dfun :: forall a. C [a] -> D [a] -> D [a]
       dfun = \(dc::C [a]) (dd::D [a]) -> DOrd dc ...
Notice the extra (dc :: C [a]) argument compared to the previous version.

This gives us:

     -----------------------------------------------------------
     DFun Superclass Invariant
     ~~~~~~~~~~~~~~~~~~~~~~~~
     In the body of a DFun, every superclass argument to the
     returned dictionary is
       either   * one of the arguments of the DFun,
       or       * constant, bound at top level
     -----------------------------------------------------------

This net effect is that it is safe to treat a dfun application as
wrapping a dictionary constructor around its arguments (in particular,
a dfun never picks superclasses from the arguments under the
dictionary constructor). No superclass is hidden inside a dfun
application.

The extra arguments required to satisfy the DFun Superclass Invariant
always come first, and are called the "silent" arguments.  You can
find out how many silent arguments there are using Id.dfunNSilent;
and then you can just drop that number of arguments to see the ones
that were in the original instance declaration.

DFun types are built (only) by MkId.mkDictFunId, so that is where we
decide what silent arguments are to be added.

In our example, if we had  [Wanted] dw :: D [a] we would get via the instance:
    dw := dfun d1 d2
    [Wanted] (d1 :: C [a])
    [Wanted] (d2 :: D [a])

And now, though we *can* solve: 
     d2 := dw
That's fine; and we solve d1:C[a] separately.

Test case SCLoop tests this fix.

Note [SPECIALISE instance pragmas]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider

   instance (Ix a, Ix b) => Ix (a,b) where
     {-# SPECIALISE instance Ix (Int,Int) #-}
     range (x,y) = ...

We make a specialised version of the dictionary function, AND
specialised versions of each *method*.  Thus we should generate
something like this:

  $dfIxPair :: (Ix a, Ix b) => Ix (a,b)
  {-# DFUN [$crangePair, ...] #-}
  {-# SPECIALISE $dfIxPair :: Ix (Int,Int) #-}
  $dfIxPair da db = Ix ($crangePair da db) (...other methods...)

  $crange :: (Ix a, Ix b) -> ((a,b),(a,b)) -> [(a,b)]
  {-# SPECIALISE $crange :: ((Int,Int),(Int,Int)) -> [(Int,Int)] #-}
  $crange da db = <blah>

The SPECIALISE pragmas are acted upon by the desugarer, which generate

  dii :: Ix Int
  dii = ...

  $s$dfIxPair :: Ix ((Int,Int),(Int,Int))
  {-# DFUN [$crangePair di di, ...] #-}
  $s$dfIxPair = Ix ($crangePair di di) (...)

  {-# RULE forall (d1,d2:Ix Int). $dfIxPair Int Int d1 d2 = $s$dfIxPair #-}

  $s$crangePair :: ((Int,Int),(Int,Int)) -> [(Int,Int)]
  $c$crangePair = ...specialised RHS of $crangePair...

  {-# RULE forall (d1,d2:Ix Int). $crangePair Int Int d1 d2 = $s$crangePair #-}
 
Note that

  * The specialised dictionary $s$dfIxPair is very much needed, in case we
    call a function that takes a dictionary, but in a context where the 
    specialised dictionary can be used.  See Trac #7797.

  * The ClassOp rule for 'range' works equally well on $s$dfIxPair, because
    it still has a DFunUnfolding.  See Note [ClassOp/DFun selection]

  * A call (range ($dfIxPair Int Int d1 d2)) might simplify two ways:
       --> {ClassOp rule for range}     $crangePair Int Int d1 d2
       --> {SPEC rule for $crangePair}  $s$crangePair
    or thus:
       --> {SPEC rule for $dfIxPair}    range $s$dfIxPair
       --> {ClassOpRule for range}      $s$crangePair
    It doesn't matter which way.

  * We want to specialise the RHS of both $dfIxPair and $crangePair,
    but the SAME HsWrapper will do for both!  We can call tcSpecPrag
    just once, and pass the result (in spec_inst_info) to tcInstanceMethods.


\begin{code}
<pre><a name="line-1"></a><a name="tcSpecInst"></a><span class='hs-definition'>tcSpecInst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Sig</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>TcSpecPrag</span>
<a name="line-2"></a><span class='hs-definition'>tcSpecInst</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>prag</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>SpecInstSig</span> <span class='hs-varid'>hs_ty</span><span class='hs-layout'>)</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addErrCtxt</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_ctxt</span> <span class='hs-varid'>prag</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-4"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idName</span> <span class='hs-varid'>dfun_id</span>
<a name="line-5"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyvars</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>clas</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcHsInstHead</span> <span class='hs-conid'>SpecInstCtxt</span> <span class='hs-varid'>hs_ty</span>
<a name="line-6"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>spec_dfun_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkDictFunTy</span> <span class='hs-varid'>tyvars</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span>
<a name="line-7"></a>
<a name="line-8"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>co_fn</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSubType</span> <span class='hs-layout'>(</span><span class='hs-conid'>SpecPragOrigin</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span> <span class='hs-conid'>SpecInstCtxt</span>
<a name="line-9"></a>                             <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>dfun_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>spec_dfun_ty</span>
<a name="line-10"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>SpecPrag</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>co_fn</span> <span class='hs-varid'>defaultInlinePragma</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-11"></a>  <span class='hs-keyword'>where</span>
<a name="line-12"></a>    <span class='hs-varid'>spec_ctxt</span> <span class='hs-varid'>prag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"In the SPECIALISE pragma"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>prag</span><span class='hs-layout'>)</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-definition'>tcSpecInst</span> <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"tcSpecInst"</span>
</pre>\end{code}

%************************************************************************
%*                                                                      *
      Type-checking an instance method
%*                                                                      *
%************************************************************************

tcInstanceMethod
- Make the method bindings, as a [(NonRec, HsBinds)], one per method
- Remembering to use fresh Name (the instance method Name) as the binder
- Bring the instance method Ids into scope, for the benefit of tcInstSig
- Use sig_fn mapping instance method Name -> instance tyvars
- Ditto prag_fn
- Use tcValBinds to do the checking

\begin{code}
<pre><a name="line-1"></a><a name="tcInstanceMethods"></a><span class='hs-definition'>tcInstanceMethods</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DFunId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span>
<a name="line-2"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span>
<a name="line-3"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-4"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Located</span> <span class='hs-conid'>TcSpecPrag</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>PragFun</span><span class='hs-layout'>)</span>
<a name="line-5"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>DefMeth</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-6"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InstBindings</span> <span class='hs-conid'>Name</span>
<a name="line-7"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsBind</span> <span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-8"></a>        <span class='hs-comment'>-- The returned inst_meth_ids all have types starting</span>
<a name="line-9"></a>        <span class='hs-comment'>--      forall tvs. theta =&gt; ...</span>
<a name="line-10"></a><span class='hs-definition'>tcInstanceMethods</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tyvars</span> <span class='hs-varid'>dfun_ev_vars</span> <span class='hs-varid'>inst_tys</span>
<a name="line-11"></a>                  <span class='hs-layout'>(</span><span class='hs-varid'>spec_inst_prags</span><span class='hs-layout'>,</span> <span class='hs-varid'>prag_fn</span><span class='hs-layout'>)</span>
<a name="line-12"></a>                  <span class='hs-varid'>op_items</span> <span class='hs-layout'>(</span><span class='hs-conid'>InstBindings</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ib_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>binds</span>
<a name="line-13"></a>                                         <span class='hs-layout'>,</span> <span class='hs-varid'>ib_pragmas</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sigs</span>
<a name="line-14"></a>                                         <span class='hs-layout'>,</span> <span class='hs-varid'>ib_extensions</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exts</span>
<a name="line-15"></a>                                         <span class='hs-layout'>,</span> <span class='hs-varid'>ib_standalone_deriving</span>
<a name="line-16"></a>                                              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>standalone_deriv</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-17"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"tcInstMeth"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>sigs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-18"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>hs_sig_fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkHsSigFun</span> <span class='hs-varid'>sigs</span>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkMinimalDefinition</span>
<a name="line-20"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>set_exts</span> <span class='hs-varid'>exts</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mapAndUnzipM</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc_item</span> <span class='hs-varid'>hs_sig_fn</span><span class='hs-layout'>)</span> <span class='hs-varid'>op_items</span> <span class='hs-layout'>}</span>
<a name="line-21"></a>  <span class='hs-keyword'>where</span>
<a name="line-22"></a>    <span class='hs-varid'>set_exts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ExtensionFlag</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span>
<a name="line-23"></a>    <span class='hs-varid'>set_exts</span> <span class='hs-varid'>es</span> <span class='hs-varid'>thing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>setXOptM</span> <span class='hs-varid'>thing</span> <span class='hs-varid'>es</span>
<a name="line-24"></a>    
<a name="line-25"></a>    <span class='hs-comment'>----------------------</span>
<a name="line-26"></a>    <span class='hs-varid'>tc_item</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsSigFun</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>DefMeth</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsBind</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span>
<a name="line-27"></a>    <span class='hs-varid'>tc_item</span> <span class='hs-varid'>sig_fn</span> <span class='hs-layout'>(</span><span class='hs-varid'>sel_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>dm_info</span><span class='hs-layout'>)</span>
<a name="line-28"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>findMethodBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>idName</span> <span class='hs-varid'>sel_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>binds</span> <span class='hs-keyword'>of</span>
<a name="line-29"></a>            <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>user_bind</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr_loc</span><span class='hs-layout'>)</span> 
<a name="line-30"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tc_body</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>standalone_deriv</span> <span class='hs-varid'>user_bind</span> <span class='hs-varid'>bndr_loc</span>
<a name="line-31"></a>            <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"tc_def"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>sel_id</span><span class='hs-layout'>)</span>
<a name="line-32"></a>                           <span class='hs-layout'>;</span> <span class='hs-varid'>tc_default</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>dm_info</span> <span class='hs-layout'>}</span>
<a name="line-33"></a>
<a name="line-34"></a>    <span class='hs-comment'>----------------------</span>
<a name="line-35"></a>    <span class='hs-varid'>tc_body</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsSigFun</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LHsBind</span> <span class='hs-conid'>Name</span>
<a name="line-36"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SrcSpan</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcId</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsBind</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span>
<a name="line-37"></a>    <span class='hs-varid'>tc_body</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>generated_code</span> <span class='hs-varid'>rn_bind</span> <span class='hs-varid'>bndr_loc</span>
<a name="line-38"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>add_meth_ctxt</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>generated_code</span> <span class='hs-varid'>rn_bind</span> <span class='hs-varop'>$</span>
<a name="line-39"></a>        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"tc_item"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>sel_id</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>sel_id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-40"></a>           <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>meth_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>local_meth_sig</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setSrcSpan</span> <span class='hs-varid'>bndr_loc</span> <span class='hs-varop'>$</span>
<a name="line-41"></a>                                          <span class='hs-varid'>mkMethIds</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tyvars</span> <span class='hs-varid'>dfun_ev_vars</span>
<a name="line-42"></a>                                                    <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>sel_id</span>
<a name="line-43"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>prags</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>prag_fn</span> <span class='hs-layout'>(</span><span class='hs-varid'>idName</span> <span class='hs-varid'>sel_id</span><span class='hs-layout'>)</span>
<a name="line-44"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>meth_id1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addInlinePrags</span> <span class='hs-varid'>meth_id</span> <span class='hs-varid'>prags</span>
<a name="line-45"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>spec_prags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSpecPrags</span> <span class='hs-varid'>meth_id1</span> <span class='hs-varid'>prags</span>
<a name="line-46"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>bind</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInstanceMethodBody</span> <span class='hs-conid'>InstSkol</span>
<a name="line-47"></a>                          <span class='hs-varid'>tyvars</span> <span class='hs-varid'>dfun_ev_vars</span>
<a name="line-48"></a>                          <span class='hs-varid'>meth_id1</span> <span class='hs-varid'>local_meth_sig</span>
<a name="line-49"></a>                          <span class='hs-layout'>(</span><span class='hs-varid'>mk_meth_spec_prags</span> <span class='hs-varid'>meth_id1</span> <span class='hs-varid'>spec_prags</span><span class='hs-layout'>)</span>
<a name="line-50"></a>                          <span class='hs-varid'>rn_bind</span>
<a name="line-51"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>meth_id1</span><span class='hs-layout'>,</span> <span class='hs-varid'>bind</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-52"></a>
<a name="line-53"></a>    <span class='hs-comment'>----------------------</span>
<a name="line-54"></a>    <span class='hs-varid'>tc_default</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsSigFun</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DefMeth</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcId</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsBind</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span>
<a name="line-55"></a>
<a name="line-56"></a>    <span class='hs-varid'>tc_default</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>sel_id</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenDefMeth</span> <span class='hs-varid'>dm_name</span><span class='hs-layout'>)</span>
<a name="line-57"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>meth_bind</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkGenericDefMethBind</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>dm_name</span>
<a name="line-58"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>tc_body</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>sel_id</span> <span class='hs-conid'>False</span> <span class='hs-comment'>{- Not generated code? -}</span> 
<a name="line-59"></a>                     <span class='hs-varid'>meth_bind</span> <span class='hs-varid'>inst_loc</span> <span class='hs-layout'>}</span>
<a name="line-60"></a>
<a name="line-61"></a>    <span class='hs-varid'>tc_default</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>sel_id</span> <span class='hs-conid'>NoDefMeth</span>     <span class='hs-comment'>-- No default method at all</span>
<a name="line-62"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"tc_def: warn"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>sel_id</span><span class='hs-layout'>)</span>
<a name="line-63"></a>           <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>meth_id</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkMethIds</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tyvars</span> <span class='hs-varid'>dfun_ev_vars</span>
<a name="line-64"></a>                                       <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>sel_id</span>
<a name="line-65"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-66"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>meth_id</span><span class='hs-layout'>,</span>
<a name="line-67"></a>                     <span class='hs-varid'>mkVarBind</span> <span class='hs-varid'>meth_id</span> <span class='hs-varop'>$</span>
<a name="line-68"></a>                       <span class='hs-varid'>mkLHsWrap</span> <span class='hs-varid'>lam_wrapper</span> <span class='hs-layout'>(</span><span class='hs-varid'>error_rhs</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-69"></a>      <span class='hs-keyword'>where</span>
<a name="line-70"></a>        <span class='hs-varid'>error_rhs</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>L</span> <span class='hs-varid'>inst_loc</span> <span class='hs-varop'>$</span> <span class='hs-conid'>HsApp</span> <span class='hs-varid'>error_fun</span> <span class='hs-layout'>(</span><span class='hs-varid'>error_msg</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-71"></a>        <span class='hs-varid'>error_fun</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>L</span> <span class='hs-varid'>inst_loc</span> <span class='hs-varop'>$</span> <span class='hs-varid'>wrapId</span> <span class='hs-layout'>(</span><span class='hs-conid'>WpTyApp</span> <span class='hs-varid'>meth_tau</span><span class='hs-layout'>)</span> <span class='hs-varid'>nO_METHOD_BINDING_ERROR_ID</span>
<a name="line-72"></a>        <span class='hs-varid'>error_msg</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>L</span> <span class='hs-varid'>inst_loc</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsLit</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsStringPrim</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsafeMkByteString</span> <span class='hs-layout'>(</span><span class='hs-varid'>error_string</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-73"></a>        <span class='hs-varid'>meth_tau</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>funResultTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>sel_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span>
<a name="line-74"></a>        <span class='hs-varid'>error_string</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>showSDoc</span> <span class='hs-varid'>dflags</span> <span class='hs-layout'>(</span><span class='hs-varid'>hcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>inst_loc</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"|"</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>sel_id</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-75"></a>        <span class='hs-varid'>lam_wrapper</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWpTyLams</span> <span class='hs-varid'>tyvars</span> <span class='hs-varop'>&lt;.&gt;</span> <span class='hs-varid'>mkWpLams</span> <span class='hs-varid'>dfun_ev_vars</span>
<a name="line-76"></a>
<a name="line-77"></a>    <span class='hs-varid'>tc_default</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>sel_id</span> <span class='hs-layout'>(</span><span class='hs-conid'>DefMeth</span> <span class='hs-varid'>dm_name</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- A polymorphic default method</span>
<a name="line-78"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>   <span class='hs-comment'>-- Build the typechecked version directly,</span>
<a name="line-79"></a>                 <span class='hs-comment'>-- without calling typecheck_method;</span>
<a name="line-80"></a>                 <span class='hs-comment'>-- see Note [Default methods in instances]</span>
<a name="line-81"></a>                 <span class='hs-comment'>-- Generate   /\as.\ds. let self = df as ds</span>
<a name="line-82"></a>                 <span class='hs-comment'>--                      in $dm inst_tys self</span>
<a name="line-83"></a>                 <span class='hs-comment'>-- The 'let' is necessary only because HsSyn doesn't allow</span>
<a name="line-84"></a>                 <span class='hs-comment'>-- you to apply a function to a dictionary *expression*.</span>
<a name="line-85"></a>
<a name="line-86"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>self_dict</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newDict</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span>
<a name="line-87"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>self_ev_bind</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvBind</span> <span class='hs-varid'>self_dict</span>
<a name="line-88"></a>                                <span class='hs-layout'>(</span><span class='hs-conid'>EvDFunApp</span> <span class='hs-varid'>dfun_id</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTys</span> <span class='hs-varid'>tyvars</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-conid'>EvId</span> <span class='hs-varid'>dfun_ev_vars</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-89"></a>
<a name="line-90"></a>           <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>meth_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>local_meth_sig</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkMethIds</span> <span class='hs-varid'>sig_fn</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tyvars</span> <span class='hs-varid'>dfun_ev_vars</span>
<a name="line-91"></a>                                                    <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>sel_id</span>
<a name="line-92"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>dm_id</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcLookupId</span> <span class='hs-varid'>dm_name</span>
<a name="line-93"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>dm_inline_prag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idInlinePragma</span> <span class='hs-varid'>dm_id</span>
<a name="line-94"></a>                 <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsWrap</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkWpEvVarApps</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>self_dict</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>&lt;.&gt;</span> <span class='hs-varid'>mkWpTyApps</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-95"></a>                       <span class='hs-conid'>HsVar</span> <span class='hs-varid'>dm_id</span>
<a name="line-96"></a>
<a name="line-97"></a>                 <span class='hs-varid'>local_meth_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sig_id</span> <span class='hs-varid'>local_meth_sig</span>
<a name="line-98"></a>                 <span class='hs-varid'>meth_bind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarBind</span> <span class='hs-varid'>local_meth_id</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>inst_loc</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-99"></a>                 <span class='hs-varid'>meth_id1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>meth_id</span> <span class='hs-varop'>`setInlinePragma`</span> <span class='hs-varid'>dm_inline_prag</span>
<a name="line-100"></a>                        <span class='hs-comment'>-- Copy the inline pragma (if any) from the default</span>
<a name="line-101"></a>                        <span class='hs-comment'>-- method to this version. Note [INLINE and default methods]</span>
<a name="line-102"></a>
<a name="line-103"></a>                  
<a name="line-104"></a>                 <span class='hs-varid'>export</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ABE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>abe_wrap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idHsWrapper</span><span class='hs-layout'>,</span> <span class='hs-varid'>abe_poly</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>meth_id1</span>
<a name="line-105"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>abe_mono</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>local_meth_id</span>
<a name="line-106"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>abe_prags</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_meth_spec_prags</span> <span class='hs-varid'>meth_id1</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>}</span>
<a name="line-107"></a>                 <span class='hs-varid'>bind</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AbsBinds</span> <span class='hs-layout'>{</span> <span class='hs-varid'>abs_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyvars</span><span class='hs-layout'>,</span> <span class='hs-varid'>abs_ev_vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun_ev_vars</span>
<a name="line-108"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>abs_exports</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>export</span><span class='hs-keyglyph'>]</span>
<a name="line-109"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>abs_ev_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvBinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitBag</span> <span class='hs-varid'>self_ev_bind</span><span class='hs-layout'>)</span>
<a name="line-110"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>abs_binds</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitBag</span> <span class='hs-varid'>meth_bind</span> <span class='hs-layout'>}</span>
<a name="line-111"></a>             <span class='hs-comment'>-- Default methods in an instance declaration can't have their own</span>
<a name="line-112"></a>             <span class='hs-comment'>-- INLINE or SPECIALISE pragmas. It'd be possible to allow them, but</span>
<a name="line-113"></a>             <span class='hs-comment'>-- currently they are rejected with</span>
<a name="line-114"></a>             <span class='hs-comment'>--           "INLINE pragma lacks an accompanying binding"</span>
<a name="line-115"></a>
<a name="line-116"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>meth_id1</span><span class='hs-layout'>,</span> <span class='hs-conid'>L</span> <span class='hs-varid'>inst_loc</span> <span class='hs-varid'>bind</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-117"></a>
<a name="line-118"></a>    <span class='hs-comment'>----------------------</span>
<a name="line-119"></a>    <span class='hs-varid'>mk_meth_spec_prags</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LTcSpecPrag</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcSpecPrags</span>
<a name="line-120"></a>        <span class='hs-comment'>-- Adapt the 'SPECIALISE instance' pragmas to work for this method Id</span>
<a name="line-121"></a>        <span class='hs-comment'>-- There are two sources:</span>
<a name="line-122"></a>        <span class='hs-comment'>--   * spec_prags_for_me: {-# SPECIALISE op :: &lt;blah&gt; #-}</span>
<a name="line-123"></a>        <span class='hs-comment'>--   * spec_prags_from_inst: derived from {-# SPECIALISE instance :: &lt;blah&gt; #-}</span>
<a name="line-124"></a>        <span class='hs-comment'>--     These ones have the dfun inside, but [perhaps surprisingly]</span>
<a name="line-125"></a>        <span class='hs-comment'>--     the correct wrapper.</span>
<a name="line-126"></a>    <span class='hs-varid'>mk_meth_spec_prags</span> <span class='hs-varid'>meth_id</span> <span class='hs-varid'>spec_prags_for_me</span>
<a name="line-127"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SpecPrags</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_prags_for_me</span> <span class='hs-varop'>++</span> <span class='hs-varid'>spec_prags_from_inst</span><span class='hs-layout'>)</span>
<a name="line-128"></a>      <span class='hs-keyword'>where</span>
<a name="line-129"></a>        <span class='hs-varid'>spec_prags_from_inst</span>
<a name="line-130"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isInlinePragma</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlinePragma</span> <span class='hs-varid'>meth_id</span><span class='hs-layout'>)</span>
<a name="line-131"></a>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>  <span class='hs-comment'>-- Do not inherit SPECIALISE from the instance if the</span>
<a name="line-132"></a>                 <span class='hs-comment'>-- method is marked INLINE, because then it'll be inlined</span>
<a name="line-133"></a>                 <span class='hs-comment'>-- and the specialisation would do nothing. (Indeed it'll provoke</span>
<a name="line-134"></a>                 <span class='hs-comment'>-- a warning from the desugarer</span>
<a name="line-135"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> 
<a name="line-136"></a>           <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-conid'>L</span> <span class='hs-varid'>inst_loc</span> <span class='hs-layout'>(</span><span class='hs-conid'>SpecPrag</span> <span class='hs-varid'>meth_id</span> <span class='hs-varid'>wrap</span> <span class='hs-varid'>inl</span><span class='hs-layout'>)</span>
<a name="line-137"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>L</span> <span class='hs-varid'>inst_loc</span> <span class='hs-layout'>(</span><span class='hs-conid'>SpecPrag</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>wrap</span> <span class='hs-varid'>inl</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>spec_inst_prags</span><span class='hs-keyglyph'>]</span>
<a name="line-138"></a>
<a name="line-139"></a>    <span class='hs-varid'>inst_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSrcSpan</span> <span class='hs-varid'>dfun_id</span>
<a name="line-140"></a>
<a name="line-141"></a>        <span class='hs-comment'>-- For instance decls that come from standalone deriving clauses</span>
<a name="line-142"></a>        <span class='hs-comment'>-- we want to print out the full source code if there's an error</span>
<a name="line-143"></a>        <span class='hs-comment'>-- because otherwise the user won't see the code at all</span>
<a name="line-144"></a>    <span class='hs-varid'>add_meth_ctxt</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>generated_code</span> <span class='hs-varid'>rn_bind</span> <span class='hs-varid'>thing</span>
<a name="line-145"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>generated_code</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addLandmarkErrCtxt</span> <span class='hs-layout'>(</span><span class='hs-varid'>derivBindCtxt</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>rn_bind</span><span class='hs-layout'>)</span> <span class='hs-varid'>thing</span>
<a name="line-146"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>thing</span>
<a name="line-147"></a>
<a name="line-148"></a>    <span class='hs-comment'>----------------------</span>
<a name="line-149"></a>
<a name="line-150"></a>    <span class='hs-comment'>-- check if one of the minimal complete definitions is satisfied</span>
<a name="line-151"></a>    <span class='hs-varid'>checkMinimalDefinition</span>
<a name="line-152"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>whenIsJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>isUnsatisfied</span> <span class='hs-varid'>methodExists</span> <span class='hs-layout'>(</span><span class='hs-varid'>classMinimalDef</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-153"></a>          <span class='hs-varid'>warnUnsatisifiedMinimalDefinition</span>
<a name="line-154"></a>      <span class='hs-keyword'>where</span>
<a name="line-155"></a>      <span class='hs-varid'>methodExists</span> <span class='hs-varid'>meth</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>findMethodBind</span> <span class='hs-varid'>meth</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-156"></a>
<a name="line-157"></a><a name="mkGenericDefMethBind"></a><span class='hs-definition'>mkGenericDefMethBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsBind</span> <span class='hs-conid'>Name</span><span class='hs-layout'>)</span>
<a name="line-158"></a><span class='hs-definition'>mkGenericDefMethBind</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>dm_name</span>
<a name="line-159"></a>  <span class='hs-keyglyph'>=</span> 	<span class='hs-comment'>-- A generic default method</span>
<a name="line-160"></a>    	<span class='hs-comment'>-- If the method is defined generically, we only have to call the</span>
<a name="line-161"></a>        <span class='hs-comment'>-- dm_name.</span>
<a name="line-162"></a>    <span class='hs-keyword'>do</span>	<span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-163"></a>	<span class='hs-layout'>;</span> <span class='hs-varid'>liftIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>dumpIfSet_dyn</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>Opt_D_dump_deriv</span> <span class='hs-str'>"Filling in method body"</span>
<a name="line-164"></a>		   <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>clas</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>,</span>
<a name="line-165"></a>			  <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>sel_id</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-166"></a>
<a name="line-167"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>noLoc</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkTopFunBind</span> <span class='hs-conid'>Generated</span> <span class='hs-layout'>(</span><span class='hs-varid'>noLoc</span> <span class='hs-layout'>(</span><span class='hs-varid'>idName</span> <span class='hs-varid'>sel_id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-168"></a>                                       <span class='hs-keyglyph'>[</span><span class='hs-varid'>mkSimpleMatch</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>rhs</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-169"></a>  <span class='hs-keyword'>where</span>
<a name="line-170"></a>    <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nlHsVar</span> <span class='hs-varid'>dm_name</span>
<a name="line-171"></a>
<a name="line-172"></a><a name="wrapId"></a><span class='hs-comment'>----------------------</span>
<a name="line-173"></a><span class='hs-definition'>wrapId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsWrapper</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsExpr</span> <span class='hs-varid'>id</span>
<a name="line-174"></a><span class='hs-definition'>wrapId</span> <span class='hs-varid'>wrapper</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkHsWrap</span> <span class='hs-varid'>wrapper</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsVar</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-175"></a>
<a name="line-176"></a><a name="derivBindCtxt"></a><span class='hs-definition'>derivBindCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span> <span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LHsBind</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-177"></a><span class='hs-definition'>derivBindCtxt</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span> <span class='hs-sel'>_bind</span>
<a name="line-178"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"When typechecking the code for "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>sel_id</span><span class='hs-layout'>)</span>
<a name="line-179"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"in a standalone derived instance for"</span><span class='hs-layout'>)</span>
<a name="line-180"></a>                    <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprClassPred</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>colon</span><span class='hs-layout'>)</span>
<a name="line-181"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"To see the code I am typechecking, use -ddump-deriv"</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-182"></a>
<a name="line-183"></a><a name="warnMissingMethodOrAT"></a><span class='hs-definition'>warnMissingMethodOrAT</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-184"></a><span class='hs-definition'>warnMissingMethodOrAT</span> <span class='hs-varid'>what</span> <span class='hs-varid'>name</span>
<a name="line-185"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>warn</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>woptM</span> <span class='hs-conid'>Opt_WarnMissingMethods</span>
<a name="line-186"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"warn"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>warn</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>startsWithUnderscore</span> <span class='hs-layout'>(</span><span class='hs-varid'>getOccName</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-187"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>warnTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>warn</span>  <span class='hs-comment'>-- Warn only if -fwarn-missing-methods</span>
<a name="line-188"></a>                 <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>startsWithUnderscore</span> <span class='hs-layout'>(</span><span class='hs-varid'>getOccName</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-189"></a>                                        <span class='hs-comment'>-- Don't warn about _foo methods</span>
<a name="line-190"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"No explicit"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-varid'>what</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"or default declaration for"</span><span class='hs-layout'>)</span>
<a name="line-191"></a>                 <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-192"></a>
<a name="line-193"></a><a name="warnUnsatisifiedMinimalDefinition"></a><span class='hs-definition'>warnUnsatisifiedMinimalDefinition</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClassMinimalDef</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-194"></a><span class='hs-definition'>warnUnsatisifiedMinimalDefinition</span> <span class='hs-varid'>mindef</span>
<a name="line-195"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>warn</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>woptM</span> <span class='hs-conid'>Opt_WarnMissingMethods</span>
<a name="line-196"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>warnTc</span> <span class='hs-varid'>warn</span> <span class='hs-varid'>message</span>
<a name="line-197"></a>       <span class='hs-layout'>}</span>
<a name="line-198"></a>  <span class='hs-keyword'>where</span>
<a name="line-199"></a>    <span class='hs-varid'>message</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"No explicit implementation for"</span><span class='hs-layout'>)</span>
<a name="line-200"></a>                   <span class='hs-layout'>,</span><span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>pprBooleanFormulaNice</span> <span class='hs-varid'>mindef</span>
<a name="line-201"></a>                   <span class='hs-keyglyph'>]</span>
</pre>\end{code}

Note [Export helper functions]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We arrange to export the "helper functions" of an instance declaration,
so that they are not subject to preInlineUnconditionally, even if their
RHS is trivial.  Reason: they are mentioned in the DFunUnfolding of
the dict fun as Ids, not as CoreExprs, so we can't substitute a
non-variable for them.

We could change this by making DFunUnfoldings have CoreExprs, but it
seems a bit simpler this way.

Note [Default methods in instances]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider this

   class Baz v x where
      foo :: x -> x
      foo y = <blah>

   instance Baz Int Int

From the class decl we get

   $dmfoo :: forall v x. Baz v x => x -> x
   $dmfoo y = <blah>

Notice that the type is ambiguous.  That's fine, though. The instance
decl generates

   $dBazIntInt = MkBaz fooIntInt
   fooIntInt = $dmfoo Int Int $dBazIntInt

BUT this does mean we must generate the dictionary translation of
fooIntInt directly, rather than generating source-code and
type-checking it.  That was the bug in Trac #1061. In any case it's
less work to generate the translated version!

Note [INLINE and default methods]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Default methods need special case.  They are supposed to behave rather like
macros.  For exmample

  class Foo a where
    op1, op2 :: Bool -> a -> a

    {-# INLINE op1 #-}
    op1 b x = op2 (not b) x

  instance Foo Int where
    -- op1 via default method
    op2 b x = <blah>

The instance declaration should behave

   just as if 'op1' had been defined with the
   code, and INLINE pragma, from its original
   definition.

That is, just as if you'd written

  instance Foo Int where
    op2 b x = <blah>

    {-# INLINE op1 #-}
    op1 b x = op2 (not b) x

So for the above example we generate:

  {-# INLINE $dmop1 #-}
  -- $dmop1 has an InlineCompulsory unfolding
  $dmop1 d b x = op2 d (not b) x

  $fFooInt = MkD $cop1 $cop2

  {-# INLINE $cop1 #-}
  $cop1 = $dmop1 $fFooInt

  $cop2 = <blah>

Note carefullly:

* We *copy* any INLINE pragma from the default method $dmop1 to the
  instance $cop1.  Otherwise we'll just inline the former in the
  latter and stop, which isn't what the user expected

* Regardless of its pragma, we give the default method an
  unfolding with an InlineCompulsory source. That means
  that it'll be inlined at every use site, notably in
  each instance declaration, such as $cop1.  This inlining
  must happen even though
    a) $dmop1 is not saturated in $cop1
    b) $cop1 itself has an INLINE pragma

  It's vital that $dmop1 *is* inlined in this way, to allow the mutual
  recursion between $fooInt and $cop1 to be broken

* To communicate the need for an InlineCompulsory to the desugarer
  (which makes the Unfoldings), we use the IsDefaultMethod constructor
  in TcSpecPrags.


%************************************************************************
%*                                                                      *
\subsection{Error messages}
%*                                                                      *
%************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="instDeclCtxt1"></a><span class='hs-definition'>instDeclCtxt1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LHsType</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-2"></a><span class='hs-definition'>instDeclCtxt1</span> <span class='hs-varid'>hs_inst_ty</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inst_decl_ctxt</span> <span class='hs-layout'>(</span><span class='hs-keyword'>case</span> <span class='hs-varid'>unLoc</span> <span class='hs-varid'>hs_inst_ty</span> <span class='hs-keyword'>of</span>
<a name="line-4"></a>                        <span class='hs-conid'>HsForAllTy</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty'</span>
<a name="line-5"></a>                        <span class='hs-keyword'>_</span>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>hs_inst_ty</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- Don't expect this</span>
<a name="line-6"></a><a name="instDeclCtxt2"></a><span class='hs-definition'>instDeclCtxt2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-7"></a><span class='hs-definition'>instDeclCtxt2</span> <span class='hs-varid'>dfun_ty</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inst_decl_ctxt</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-9"></a>  <span class='hs-keyword'>where</span>
<a name="line-10"></a>    <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>cls</span><span class='hs-layout'>,</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitDFunTy</span> <span class='hs-varid'>dfun_ty</span>
<a name="line-11"></a>
<a name="line-12"></a><a name="inst_decl_ctxt"></a><span class='hs-definition'>inst_decl_ctxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-13"></a><span class='hs-definition'>inst_decl_ctxt</span> <span class='hs-varid'>doc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"In the instance declaration for"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-14"></a>                        <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>quotes</span> <span class='hs-varid'>doc</span><span class='hs-layout'>)</span>
<a name="line-15"></a>
<a name="line-16"></a><a name="badBootFamInstDeclErr"></a><span class='hs-definition'>badBootFamInstDeclErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SDoc</span>
<a name="line-17"></a><span class='hs-definition'>badBootFamInstDeclErr</span>
<a name="line-18"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal family instance in hs-boot file"</span><span class='hs-layout'>)</span>
<a name="line-19"></a>
<a name="line-20"></a><a name="notFamily"></a><span class='hs-definition'>notFamily</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-21"></a><span class='hs-definition'>notFamily</span> <span class='hs-varid'>tycon</span>
<a name="line-22"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal family instance for"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tycon</span><span class='hs-layout'>)</span>
<a name="line-23"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tycon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"is not an indexed type family"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-24"></a>
<a name="line-25"></a><a name="tooFewParmsErr"></a><span class='hs-definition'>tooFewParmsErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Arity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-26"></a><span class='hs-definition'>tooFewParmsErr</span> <span class='hs-varid'>arity</span>
<a name="line-27"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Family instance has too few parameters; expected"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-28"></a>    <span class='hs-varid'>ppr</span> <span class='hs-varid'>arity</span>
<a name="line-29"></a>
<a name="line-30"></a><a name="assocInClassErr"></a><span class='hs-definition'>assocInClassErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Located</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-31"></a><span class='hs-definition'>assocInClassErr</span> <span class='hs-varid'>name</span>
<a name="line-32"></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Associated type"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-33"></a>   <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"must be inside a class instance"</span><span class='hs-layout'>)</span>
<a name="line-34"></a>
<a name="line-35"></a><a name="badFamInstDecl"></a><span class='hs-definition'>badFamInstDecl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Located</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-36"></a><span class='hs-definition'>badFamInstDecl</span> <span class='hs-varid'>tc_name</span>
<a name="line-37"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal family instance for"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-38"></a>           <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc_name</span><span class='hs-layout'>)</span>
<a name="line-39"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>parens</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Use TypeFamilies to allow indexed type families"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-40"></a>
<a name="line-41"></a><a name="notOpenFamily"></a><span class='hs-definition'>notOpenFamily</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-42"></a><span class='hs-definition'>notOpenFamily</span> <span class='hs-varid'>tc</span>
<a name="line-43"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal instance for closed family"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
</pre>\end{code}
</body>
</html>
