<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>10.3. Informal Semantics</title><link rel="stylesheet" type="text/css" href="fptools.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.8.3"><link rel="up" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html" title="Chapter 10. An External Representation for the GHC Core Language (For GHC 6.10)"><link rel="prev" href="external-grammar-of-core.html" title="10.2. External Grammar of Core"><link rel="next" href="primitive-module.html" title="10.4. Primitive Module"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">10.3. Informal Semantics</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="external-grammar-of-core.html">Prev</a> </td><th width="60%" align="center">Chapter 10. An External Representation for the GHC Core Language (For GHC 6.10)</th><td width="20%" align="right"> <a accesskey="n" href="primitive-module.html">Next</a></td></tr></table><hr></div><div class="section" title="10.3. Informal Semantics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="informal-semantics"></a>10.3. Informal Semantics</h2></div></div></div><p>At the term level, Core resembles a explicitly-typed polymorphic
    lambda calculus (F<sub>&#969;</sub>), with the addition of
    local <code class="code">let</code> bindings, algebraic type definitions, constructors, and
    <code class="code">case</code> expressions, and primitive types, literals and operators. Its
    type system is richer than that of System F, supporting explicit
    type equality coercions and type functions.[<a class="citation" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html#idp33563456"><span class="citation">system-fc</span></a>]</p><p>In this section we concentrate on the less obvious points about
    Core.</p><div class="section" title="10.3.1. Program Organization and Modules"><div class="titlepage"><div><div><h3 class="title"><a name="program-organization-and-modules"></a>10.3.1. Program Organization and Modules</h3></div></div></div><p>Core programs are organized into <span class="emphasis"><em>modules</em></span>, corresponding directly
      to source-level Haskell modules. Each module has a identifying
      name <span class="emphasis"><em>mident</em></span>. A module identifier consists of a <span class="emphasis"><em>package name</em></span>
      followed by a module name, which may be hierarchical: for
      example, <code class="code">base:GHC.Base</code> is the module identifier for GHC&#8217;s Base
      module. Its name is <code class="code">Base</code>, and it lives in the GHC hierarchy
      within the <code class="code">base</code> package. Section 5.8 of the GHC users&#8217; guide
      explains package names [<a class="citation" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html#idp33546688"><span class="citation">ghc-user-guide</span></a>]. In particular, note that a Core
      program may contain multiple modules with the same (possibly
      hierarchical) module name that differ in their package names. In
      some of the code examples that follow, we will omit package
      names and possibly full hierarchical module names from
      identifiers for brevity, but be aware that they are always
      required.<sup>[<a name="idp33324224" href="#ftn.idp33324224" class="footnote">18</a>]</sup></p><p>Each module may contain the following kinds of top-level
      declarations:

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          Algebraic data type declarations, each defining a type
          constructor and one or more data constructors;
        </li><li class="listitem">
          Newtype declarations, corresponding to Haskell <code class="code">newtype</code>
          declarations, each defining a type constructor and a
          coercion name; and
        </li><li class="listitem">
          Value declarations, defining the types and values of
          top-level variables.
        </li></ul></div><p>
      </p><p>No type constructor, data constructor, or top-level value may be
      declared more than once within a given module. All the type
      declarations are (potentially) mutually recursive. Value
      declarations must be in dependency order, with explicit grouping
      of potentially mutually recursive declarations.</p><p>Identifiers defined in top-level declarations may be <span class="emphasis"><em>external</em></span> or
      <span class="emphasis"><em>internal</em></span>. External identifiers can be referenced from any other
      module in the program, using conventional dot notation (e.g.,
      <code class="code">base:GHC.Base.Bool</code>, <code class="code">base:GHC.Base.True</code>). Internal identifiers
      are visible only within the defining module. All type and data
      constructors are external, and are always defined and referenced
      using fully qualified names (with dots).</p><p>A top-level value is external if it is defined and referenced
      using a fully qualified name with a dot (e.g., <code class="code">main:MyModule.foo = ...</code>);
      otherwise, it is internal (e.g., <code class="code">bar = ...</code>). Note that
      Core&#8217;s notion of an external identifier does not necessarily
      coincide with that of <span class="quote">&#8220;<span class="quote">exported</span>&#8221;</span> identifier in a Haskell source
      module. An identifier can be an external identifier in Core, but
      not be exported by the original Haskell source
      module.<sup>[<a name="idp33333104" href="#ftn.idp33333104" class="footnote">19</a>]</sup>
    However, if an identifier was exported by the Haskell source
      module, it will appear as an external name in Core.</p><p>Core modules have no explicit import or export lists. Modules
      may be mutually recursive. Note that because of the latter fact,
      GHC currently prints out the top-level bindings for every module
      as a single recursive group, in order to avoid keeping track of
      dependencies between top-level values within a module. An
      external Core tool could reconstruct dependencies later, of
      course.</p><p>There is also an implicitly-defined module <code class="code">ghc-prim:GHC.Prim</code>,
      which exports the <span class="quote">&#8220;<span class="quote">built-in</span>&#8221;</span> types and values that must be
      provided by any implementation of Core (including GHC). Details
      of this module are in the <a class="link" href="primitive-module.html" title="10.4. Primitive Module">Primitive Module section</a>.</p><p>A Core <span class="emphasis"><em>program</em></span> is a collection of distinctly-named modules that
      includes a module called main:Main having an exported value
      called <code class="code">main:ZCMain.main</code> of type <code class="code">base:GHC.IOBase.IO a</code> (for some
      type <code class="code">a</code>). (Note that the strangely named wrapper for <code class="code">main</code> is the
      one exception to the rule that qualified names defined within a
      module <code class="code">m</code> must have module name <code class="code">m</code>.)</p><p>Many Core programs will contain library modules, such as
      <code class="code">base:GHC.Base</code>, which implement parts of the Haskell standard
      library. In principle, these modules are ordinary Haskell
      modules, with no special status. In practice, the requirement on
      the type of <code class="code">main:Main.main</code> implies that every program will
      contain a large subset of the standard library modules.</p></div><div class="section" title="10.3.2. Namespaces"><div class="titlepage"><div><div><h3 class="title"><a name="namespaces"></a>10.3.2. Namespaces</h3></div></div></div><p>There are five distinct namespaces:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">module identifiers (<code class="code">mident</code>),</li><li class="listitem">type constructors  (<code class="code">tycon</code>),</li><li class="listitem">type variables     (<code class="code">tyvar</code>),</li><li class="listitem">data constructors  (<code class="code">dcon</code>),</li><li class="listitem">term variables     (<code class="code">var</code>).</li></ol></div><p>
      </p><p>Spaces (1), (2+3), and (4+5) can be distinguished from each
      other by context. To distinguish (2) from (3) and (4) from (5),
      we require that data and type constructors begin with an
      upper-case character, and that term and type variables begin
      with a lower-case character.</p><p>Primitive types and operators are not syntactically
      distinguished.</p><p>Primitive <span class="emphasis"><em>coercion</em></span> operators, of which there are six, <span class="emphasis"><em>are</em></span>
      syntactically distinguished in the grammar. This is because
      these coercions must be fully applied, and because
      distinguishing their applications in the syntax makes
      typechecking easier.</p><p>A given variable (type or term) may have multiple definitions
      within a module. However, definitions of term variables never
      <span class="quote">&#8220;<span class="quote">shadow</span>&#8221;</span> one another: the scope of the definition of a given
      variable never contains a redefinition of the same variable.
      Type variables may be shadowed. Thus, if a term variable has
      multiple definitions within a module, all those definitions must
      be local (let-bound). The only exception to this rule is that
      (necessarily closed) types labelling <code class="code">%external</code> expressions may
      contain <code class="code">tyvar</code> bindings that shadow outer bindings.</p><p>Core generated by GHC makes heavy use of encoded names, in which
      the characters <code class="code">Z</code> and <code class="code">z</code> are used to introduce escape sequences
      for non-alphabetic characters such as dollar sign <code class="code">$</code> (<code class="code">zd</code>), hash <code class="code">#</code>
      (<code class="code">zh</code>), plus <code class="code">+</code> (<code class="code">zp</code>), etc. This is the same encoding used in <code class="code">.hi</code>
      files and in the back-end of GHC itself, except that we
      sometimes change an initial <code class="code">z</code> to <code class="code">Z</code>, or vice-versa, in order to
      maintain case distinctions.</p><p>Finally, note that hierarchical module names are z-encoded in
      Core: for example, <code class="code">base:GHC.Base.foo</code> is rendered as
      <code class="code">base:GHCziBase.foo</code>. A parser may reconstruct the module
      hierarchy, or regard <code class="code">GHCziBase</code> as a flat name.</p></div><div class="section" title="10.3.3. Types and Kinds"><div class="titlepage"><div><div><h3 class="title"><a name="types-and-kinds"></a>10.3.3. Types and Kinds</h3></div></div></div><p>In Core, all type abstractions and applications are explicit.
      This make it easy to typecheck any (closed) fragment of Core
      code. An full executable typechecker is available separately.</p><div class="section" title="10.3.3.1. Types"><div class="titlepage"><div><div><h4 class="title"><a name="types"></a>10.3.3.1. Types</h4></div></div></div><p>Types are described by type expressions, which are built from
        named type constructors and type variables using type
        application and universal quantification. Each type
        constructor has a fixed arity &#8805; 0. Because it is so widely
        used, there is special infix syntax for the fully-applied
        function type constructor (<code class="code">-&gt;</code>). (The prefix identifier for
        this constructor is <code class="code">ghc-prim:GHC.Prim.ZLzmzgZR</code>; this should
        only appear in unapplied or partially applied form.)</p><p>There are also a number of other primitive type constructors
        (e.g., <code class="code">Intzh</code>) that are predefined in the <code class="code">GHC.Prim</code> module, but
        have no special syntax. <code class="code">%data</code> and <code class="code">%newtype</code> declarations
        introduce additional type constructors, as described below.
        Type constructors are distinguished solely by name.</p></div><div class="section" title="10.3.3.2. Coercions"><div class="titlepage"><div><div><h4 class="title"><a name="coercions"></a>10.3.3.2. Coercions</h4></div></div></div><p>A type may also be built using one of the primitive coercion
        operators, as described in <a class="link" href="informal-semantics.html#namespaces" title="10.3.2. Namespaces">the Namespaces section</a>. For details on the
        meanings of these operators, see the System FC paper [<a class="citation" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html#idp33563456"><span class="citation">system-fc</span></a>]. Also
        see <a class="link" href="informal-semantics.html#newtypes" title="10.3.5. Newtypes">the Newtypes section</a> for
        examples of how GHC uses coercions in Core code.</p></div><div class="section" title="10.3.3.3. Kinds"><div class="titlepage"><div><div><h4 class="title"><a name="kinds"></a>10.3.3.3. Kinds</h4></div></div></div><p>As described in the Haskell definition, it is necessary to
        distinguish well-formed type-expressions by classifying them
        into different <span class="emphasis"><em>kinds</em></span> [<span class="citation">haskell98, p. 41</span>]. In particular, Core
        explicitly records the kind of every bound type variable.</p><p>In addition, Core&#8217;s kind system includes equality kinds, as in
        System FC [<a class="citation" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html#idp33563456"><span class="citation">system-fc</span></a>]. An application of a built-in coercion, or of a
        user-defined coercion as introduced by a <code class="code">newtype</code> declaration,
        has an equality kind.</p></div><div class="section" title="10.3.3.4. Lifted and Unlifted Types"><div class="titlepage"><div><div><h4 class="title"><a name="lifted-and-unlifted-types"></a>10.3.3.4. Lifted and Unlifted Types</h4></div></div></div><p>Semantically, a type is <span class="emphasis"><em>lifted</em></span> if and only if it has bottom as
        an element. We need to distinguish them because operationally,
        terms with lifted types may be represented by closures; terms
        with unlifted types must not be represented by closures, which
        implies that any unboxed value is necessarily unlifted. We
        distinguish between lifted and unlifted types by ascribing
        them different kinds.</p><p>Currently, all the primitive types are unlifted (including a
        few boxed primitive types such as <code class="code">ByteArrayzh</code>). Peyton-Jones
        and Launchbury [<a class="citation" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html#idp33588976"><span class="citation">pj:unboxed</span></a>] described the ideas behind unboxed and
        unlifted types.</p></div><div class="section" title="10.3.3.5. Type Constructors; Base Kinds and Higher Kinds"><div class="titlepage"><div><div><h4 class="title"><a name="type-constructors-base-kinds-and-higher-kinds"></a>10.3.3.5. Type Constructors; Base Kinds and Higher Kinds</h4></div></div></div><p>Every type constructor has a kind, depending on its arity and
        whether it or its arguments are lifted.</p><p>Term variables can only be assigned types that have base
        kinds: the base kinds are <code class="code">*</code>, <code class="code">#</code>, and <code class="code">?</code>. The three base kinds
        distinguish the liftedness of the types they classify: <code class="code">*</code>
        represents lifted types; <code class="code">#</code> represents unlifted types; and <code class="code">?</code> is
        the <span class="quote">&#8220;<span class="quote">open</span>&#8221;</span> kind, representing a type that may be either lifted
        or unlifted. Of these, only <code class="code">*</code> ever appears in Core type
        declarations generated from user code; the other two are
        needed to describe certain types in primitive (or otherwise
        specially-generated) code (which, after optimization, could
        potentially appear anywhere).</p><p>In particular, no top-level identifier (except in
        <code class="code">ghc-prim:GHC.Prim</code>) has a type of kind <code class="code">#</code> or <code class="code">?</code>.</p><p>Nullary type constructors have base kinds: for example, the
        type <code class="code">Int</code> has kind <code class="code">*</code>, and <code class="code">Int#</code> has kind <code class="code">#</code>.</p><p>Non-nullary type constructors have higher kinds: kinds that
        have the form
        k<sub>1</sub><code class="code">-&gt;</code>k<sub>2</sub>, where
        k<sub>1</sub> and k<sub>2</sub> are
        kinds. For example, the function type constructor <code class="code">-&gt;</code> has
        kind <code class="code">* -&gt; (* -&gt; *)</code>. Since Haskell allows abstracting
        over type constructors, type variables may have higher kinds;
        however, much more commonly they have kind <code class="code">*</code>, so that is the
        default if a type binder omits a kind.</p></div><div class="section" title="10.3.3.6. Type Synonyms and Type Equivalence"><div class="titlepage"><div><div><h4 class="title"><a name="type-synonyms-and-type-equivalence"></a>10.3.3.6. Type Synonyms and Type Equivalence</h4></div></div></div><p>There is no mechanism for defining type synonyms
        (corresponding to Haskell <code class="code">type</code> declarations).</p><p>Type equivalence is just syntactic equivalence on type
        expressions (of base kinds) modulo:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">alpha-renaming of variables bound in <code class="code">%forall</code> types;</li><li class="listitem">the identity a <code class="code">-&gt;</code> b &#8801; <code class="code">ghc-prim:GHC.Prim.ZLzmzgZR</code> a b</li></ul></div></div></div><div class="section" title="10.3.4. Algebraic data types"><div class="titlepage"><div><div><h3 class="title"><a name="algebraic-data-types"></a>10.3.4. Algebraic data types</h3></div></div></div><p>Each data declaration introduces a new type constructor and a
      set of one or more data constructors, normally corresponding
      directly to a source Haskell <code class="code">data</code> declaration. For example, the
      source declaration
      
      </p><pre class="programlisting">
data Bintree a =
    Fork (Bintree a) (Bintree a)
  | Leaf a
      </pre><p>

      might induce the following Core declaration
      
      </p><pre class="programlisting">
%data Bintree a = {
  Fork (Bintree a) (Bintree a);
  Leaf a)}
      </pre><p>

      which introduces the unary type constructor Bintree of kind
      <code class="code">*-&gt;*</code> and two data constructors with types
      
      </p><pre class="programlisting">
Fork :: %forall a . Bintree a -&gt; Bintree a -&gt; Bintree a
Leaf :: %forall a . a -&gt; Bintree a
      </pre><p>

      We define the <span class="emphasis"><em>arity</em></span> of each data constructor to be the number of
      value arguments it takes; e.g. <code class="code">Fork</code> has arity 2 and <code class="code">Leaf</code> has
      arity 1.</p><p>For a less conventional example illustrating the possibility of
      higher-order kinds, the Haskell source declaration
      
      </p><pre class="programlisting">
data A f a = MkA (f a)
      </pre><p>

      might induce the Core declaration
      
      </p><pre class="programlisting">
%data A (f::*-&gt;*) a = { MkA (f a) }
      </pre><p>

      which introduces the constructor
      
      </p><pre class="programlisting">
MkA :: %forall (f::*-&gt;*) a . (f a) -&gt; (A f) a
      </pre><p>GHC (like some other Haskell implementations) supports an
      extension to Haskell98 for existential types such as
      
      </p><pre class="programlisting">
data T = forall a . MkT a (a -&gt; Bool)
      </pre><p>

      This is represented by the Core declaration
      
      </p><pre class="programlisting">
%data T = {MkT @a a (a -&gt; Bool)}
      </pre><p>

      which introduces the nullary type constructor T and the data
      constructor

      </p><pre class="programlisting">
MkT :: %forall a . a -&gt; (a -&gt; Bool) -&gt; T
      </pre><p>

      In general, existentially quantified variables appear as extra
      universally quantified variables in the data contructor types. An
      example of how to construct and deconstruct values of type <code class="code">T</code> is
      shown in <a class="link" href="informal-semantics.html#expression-forms" title="10.3.6. Expression Forms">the Expression Forms section</a>.</p></div><div class="section" title="10.3.5. Newtypes"><div class="titlepage"><div><div><h3 class="title"><a name="newtypes"></a>10.3.5. Newtypes</h3></div></div></div><p>Each Core <code class="code">%newtype</code> declaration introduces a new type constructor
      and an associated representation type, corresponding to a source
      Haskell <code class="code">newtype</code> declaration. However, unlike in source Haskell,
      a <code class="code">%newtype</code> declaration does not introduce any data constructors.</p><p>Each <code class="code">%newtype</code> declaration also introduces a new coercion
      (syntactically, just another type constructor) that implies an
      axiom equating the type constructor, applied to any type
      variables bound by the <code class="code">%newtype</code>, to the representation type.</p><p>For example, the Haskell fragment
      
      </p><pre class="programlisting">
newtype U = MkU Bool
u = MkU True
v = case u of
  MkU b -&gt; not b
      </pre><p>

      might induce the Core fragment

      </p><pre class="programlisting">
%newtype U ZCCoU = Bool;
u :: U = %cast (True)
           ((%sym ZCCoU));
v :: Bool = not (%cast (u) ZCCoU);
      </pre><p>The <code class="code">newtype</code> declaration implies that the types <code class="code">U</code> and <code class="code">Bool</code> have
      equivalent representations, and the coercion axiom <code class="code">ZCCoU</code>
      provides evidence that <code class="code">U</code> is equivalent to <code class="code">Bool</code>. Notice that in
      the body of <code class="code">u</code>, the boolean value <code class="code">True</code> is cast to type <code class="code">U</code> using
      the primitive symmetry rule applied to <code class="code">ZCCoU</code>: that is, using a
      coercion of kind <code class="code">Bool :=: U</code>. And in the body of <code class="code">v</code>, <code class="code">u</code> is cast
      back to type <code class="code">Bool</code> using the axiom <code class="code">ZCCoU</code>.</p><p>Notice that the <code class="code">case</code> in the Haskell source code above translates
      to a <code class="code">cast</code> in the corresponding Core code. That is because
      operationally, a <code class="code">case</code> on a value whose type is declared by a
      <code class="code">newtype</code> declaration is a no-op. Unlike a <code class="code">case</code> on any other
      value, such a <code class="code">case</code> does no evaluation: its only function is to
      coerce its scrutinee&#8217;s type.</p><p>Also notice that unlike in a previous draft version of External
      Core, there is no need to handle recursive newtypes specially.</p></div><div class="section" title="10.3.6. Expression Forms"><div class="titlepage"><div><div><h3 class="title"><a name="expression-forms"></a>10.3.6. Expression Forms</h3></div></div></div><p>Variables and data constructors are straightforward.</p><p>Literal (<span class="variable">lit</span>) expressions consist of a literal value, in one of
      four different formats, and a (primitive) type annotation. Only
      certain combinations of format and type are permitted;
      see <a class="link" href="primitive-module.html" title="10.4. Primitive Module">the Primitive Module section</a>.
      The character and string formats can describe only 8-bit ASCII characters.</p><p>Moreover, because the operational semantics for Core interprets
      strings as C-style null-terminated strings, strings should not
      contain embedded nulls.</p><p>In Core, value applications, type applications, value
      abstractions, and type abstractions are all explicit. To tell
      them apart, type arguments in applications and formal type
      arguments in abstractions are preceded by an <code class="code">@ symbol</code>. (In
      abstractions, the <code class="code">@</code> plays essentially the same role as the more
      usual &#923; symbol.) For example, the Haskell source declaration
      
      </p><pre class="programlisting">
f x = Leaf (Leaf x)
      </pre><p>

      might induce the Core declaration

      </p><pre class="programlisting">
f :: %forall a . a -&gt; BinTree (BinTree a) =
  \ @a (x::a) -&gt; Leaf @(Bintree a) (Leaf @a x)
      </pre><p>Value applications may be of user-defined functions, data
      constructors, or primitives. None of these sorts of applications
      are necessarily saturated.</p><p>Note that the arguments of type applications are not always of
      kind <code class="code">*</code>. For example, given our previous definition of type <code class="code">A</code>:

      </p><pre class="programlisting">
data A f a = MkA (f a)
      </pre><p>

      the source code

      </p><pre class="programlisting">
MkA (Leaf True)
      </pre><p>

      becomes

      </p><pre class="programlisting">
(MkA @Bintree @Bool) (Leaf @Bool True)
      </pre><p>Local bindings, of a single variable or of a set of mutually
      recursive variables, are represented by <code class="code">%let</code> expressions in the
      usual way.</p><p>By far the most complicated expression form is <code class="code">%case</code>. <code class="code">%case</code>
      expressions are permitted over values of any type, although they
      will normally be algebraic or primitive types (with literal
      values). Evaluating a <code class="code">%case</code> forces the evaluation of the
      expression being tested (the <span class="quote">&#8220;<span class="quote">scrutinee</span>&#8221;</span>). The value of the
      scrutinee is bound to the variable following the <code class="code">%of</code> keyword,
      which is in scope in all alternatives; this is useful when the
      scrutinee is a non-atomic expression (see next example). The
      scrutinee is preceded by the type of the entire <code class="code">%case</code>
      expression: that is, the result type that all of the <code class="code">%case</code>
      alternatives have (this is intended to make type reconstruction
      easier in the presence of type equality coercions).</p><p>In an algebraic <code class="code">%case</code>, all the case alternatives must be labeled
      with distinct data constructors from the algebraic type,
      followed by any existential type variable bindings (see below),
      and typed term variable bindings corresponding to the data
      constructor&#8217;s arguments. The number of variables must match the
      data constructor&#8217;s arity.</p><p>For example, the following Haskell source expression

      </p><pre class="programlisting">
case g x of
  Fork l r -&gt; Fork r l
  t@(Leaf v) -&gt; Fork t t
      </pre><p>

      might induce the Core expression

      </p><pre class="programlisting">
%case ((Bintree a)) g x %of (t::Bintree a)
  Fork (l::Bintree a) (r::Bintree a) -&gt;
    Fork @a r l
  Leaf (v::a) -&gt;
    Fork @a t t
      </pre><p>When performing a <code class="code">%case</code> over a value of an
      existentially-quantified algebraic type, the alternative must
      include extra local type bindings for the
      existentially-quantified variables. For example, given

      </p><pre class="programlisting">
data T = forall a . MkT a (a -&gt; Bool)
      </pre><p>      

      the source

      </p><pre class="programlisting">
case x of
  MkT w g -&gt; g w
      </pre><p>      

      becomes

      </p><pre class="programlisting">
%case x %of (x&#8217;::T)
  MkT @b (w::b) (g::b-&gt;Bool) -&gt; g w
      </pre><p>In a <code class="code">%case</code> over literal alternatives, all the case alternatives
      must be distinct literals of the same primitive type.</p><p>The list of alternatives may begin with a default alternative
      labeled with an underscore (<code class="code">%_</code>), whose right-hand side will be
      evaluated if none of the other alternatives match. The default
      is optional except for in a case over a primitive type, or when
      there are no other alternatives. If the case is over neither an
      algebraic type nor a primitive type, then the list of
      alternatives must contain a default alternative and nothing
      else. For algebraic cases, the set of alternatives need not be
      exhaustive, even if no default is given; if alternatives are
      missing, this implies that GHC has deduced that they cannot
      occur.</p><p><code class="code">%cast</code> is used to manipulate newtypes, as described in
      <a class="link" href="informal-semantics.html#newtypes" title="10.3.5. Newtypes">the Newtype section</a>. The <code class="code">%cast</code> expression
      takes an expression and a coercion: syntactically, the coercion
      is an arbitrary type, but it must have an equality kind. In an
      expression <code class="code">(cast e co)</code>, if <code class="code">e :: T</code> and <code class="code">co</code> has kind <code class="code">T :=: U</code>, then
      the overall expression has type <code class="code">U</code> [<a class="citation" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html#idp33550544"><span class="citation">ghc-fc-commentary</span></a>]. Here, <code class="code">co</code> must be a
      coercion whose left-hand side is <code class="code">T</code>.</p><p>Note that unlike the <code class="code">%coerce</code> expression that existed in previous
      versions of Core, this means that <code class="code">%cast</code> is (almost) type-safe:
      the coercion argument provides evidence that can be verified by
      a typechecker. There are still unsafe <code class="code">%cast</code>s, corresponding to
      the unsafe <code class="code">%coerce</code> construct that existed in old versions of
      Core, because there is a primitive unsafe coercion type that can
      be used to cast arbitrary types to each other. GHC uses this for
      such purposes as coercing the return type of a function (such as
      error) which is guaranteed to never return:
      
      </p><pre class="programlisting">
case (error "") of
  True -&gt; 1
  False -&gt; 2
      </pre><p>

      becomes:

      </p><pre class="programlisting">
%cast (error @ Bool (ZMZN @ Char))
(%unsafe Bool Integer);
      </pre><p>

      <code class="code">%cast</code> has no operational meaning and is only used in
      typechecking.</p><p>A <code class="code">%note</code> expression carries arbitrary internal information that
      GHC finds interesting. The information is encoded as a string.
      Expression notes currently generated by GHC include the inlining
      pragma (<code class="code">InlineMe</code>) and cost-center labels for profiling.</p><p>A <code class="code">%external</code> expression denotes an external identifier, which has
      the indicated type (always expressed in terms of Haskell
      primitive types). External Core supports two kinds of external
      calls: <code class="code">%external</code> and <code class="code">%dynexternal</code>. Only the former is supported
      by the current set of stand-alone Core tools. In addition, there
      is a <code class="code">%label</code> construct which GHC may generate but which the Core
      tools do not support.</p><p>The present syntax for externals is sufficient for describing C
      functions and labels. Interfacing to other languages may require
      additional information or a different interpretation of the name
      string.</p></div><div class="section" title="10.3.7. Expression Evaluation"><div class="titlepage"><div><div><h3 class="title"><a name="expression-evaluation"></a>10.3.7. Expression Evaluation</h3></div></div></div><p>The dynamic semantics of Core are defined on the type-erasure of
      the program: for example, we ignore all type abstractions and
      applications. The denotational semantics of the resulting
      type-free program are just the conventional ones for a
      call-by-name language, in which expressions are only evaluated
      on demand. But Core is intended to be a call-by-<span class="emphasis"><em>need</em></span> language,
      in which expressions are only evaluated once. To express the
      sharing behavior of call-by-need, we give an operational model
      in the style of Launchbury [<a class="citation" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html#idp33617632"><span class="citation">launchbury93natural</span></a>].</p><p>This section describes the model informally; a more formal
      semantics is separately available as an executable interpreter.</p><p>To simplify the semantics, we consider only <span class="quote">&#8220;<span class="quote">well-behaved</span>&#8221;</span> Core
      programs in which constructor and primitive applications are
      fully saturated, and in which non-trivial expresssions of
      unlifted kind (<code class="code">#</code>) appear only as scrutinees in <code class="code">%case</code>
      expressions. Any program can easily be put into this form; a
      separately available preprocessor illustrates how. In the
      remainder of this section, we use <span class="quote">&#8220;<span class="quote">Core</span>&#8221;</span> to mean <span class="quote">&#8220;<span class="quote">well-behaved</span>&#8221;</span>
      Core.</p><p>Evaluating a Core expression means reducing it to <span class="emphasis"><em>weak-head normal form (WHNF)</em></span>,
      i.e., a primitive value, lambda abstraction,
      or fully-applied data constructor. Evaluating a program means
      evaluating the expression <code class="code">main:ZCMain.main</code>.</p><p>To make sure that expression evaluation is shared, we make use
      of a <span class="emphasis"><em>heap</em></span>, which contains <span class="emphasis"><em>heap entries</em></span>. A heap entry can be:

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
	  A <span class="emphasis"><em>thunk</em></span>, representing an unevaluated expression, also known
	  as a suspension.
	</li><li class="listitem">
	  A <span class="emphasis"><em>WHNF</em></span>, representing an evaluated expression. The result of
	  evaluating a thunk is a WHNF. A WHNF is always a closure
	  (corresponding to a lambda abstraction in the source
	  program) or a data constructor application: computations
	  over primitive types are never suspended.
	</li></ul></div><p><span class="emphasis"><em>Heap pointers</em></span> point to heap entries: at different times, the
      same heap pointer can point to either a thunk or a WHNF, because
      the run-time system overwrites thunks with WHNFs as computation
      proceeds.</p><p>The suspended computation that a thunk represents might
      represent evaluating one of three different kinds of expression.
      The run-time system allocates a different kind of thunk
      depending on what kind of expression it is:

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
	  A thunk for a value definition has a group of suspended
	  defining expressions, along with a list of bindings between
	  defined names and heap pointers to those suspensions. (A
	  value definition may be a recursive group of definitions or
	  a single non-recursive definition, and it may be top-level
	  (global) or <code class="code">let</code>-bound (local)).
	</li><li class="listitem">
	  A thunk for a function application (where the function is
	  user-defined) has a suspended actual argument expression,
	  and a binding between the formal argument and a heap pointer
	  to that suspension.
	</li><li class="listitem">
	  A thunk for a constructor application has a suspended actual
	  argument expression; the entire constructed value has a heap
	  pointer to that suspension embedded in it.
	</li></ul></div><p>As computation proceeds, copies of the heap pointer for a given
      thunk propagate through the executing program. When another
      computation demands the result of that thunk, the thunk is
      <span class="emphasis"><em>forced</em></span>: the run-time system computes the thunk&#8217;s result,
      yielding a WHNF, and overwrites the heap entry for the thunk
      with the WHNF. Now, all copies of the heap pointer point to the
      new heap entry: a WHNF. Forcing occurs only in the context of

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">evaluating the operator expression of an application;</li><li class="listitem">evaluating the scrutinee of a <code class="code">case</code> expression; or</li><li class="listitem">evaluating an argument to a primitive or external function application</li></ul></div><p>
      </p><p>When no pointers to a heap entry (whether it is a thunk or WHNF)
      remain, the garbage collector can reclaim the space it uses. We
      assume this happens implicitly.</p><p>With the exception of functions, arrays, and mutable variables,
      we intend that values of all primitive types should be held
      <span class="emphasis"><em>unboxed</em></span>: they should not be heap-allocated. This does not
      violate call-by-need semantics: all primitive types are
      <span class="emphasis"><em>unlifted</em></span>, which means that values of those types must be
      evaluated strictly. Unboxed tuple types are not heap-allocated
      either.</p><p>Certain primitives and <code class="code">%external</code> functions cause side-effects to
      state threads or to the real world. Where the ordering of these
      side-effects matters, Core already forces this order with data
      dependencies on the pseudo-values representing the threads.</p><p>An implementation must specially support the <code class="code">raisezh</code> and
      <code class="code">handlezh</code> primitives: for example, by using a handler stack.
      Again, real-world threading guarantees that they will execute in
      the correct order.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"></div><div class="footnote"><code class="code"><sup>[<a name="ftn.idp33333104" href="#idp33333104" class="code">19</a>] </sup>Main.foo = ... Main.bar ...</code><code class="code">Main.foo</code><code class="code">bar</code><code class="code">foo</code><code class="code">bar</code></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="external-grammar-of-core.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="primitive-module.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">10.2. External Grammar of Core </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 10.4. Primitive Module</td></tr></table></div></body></html>
