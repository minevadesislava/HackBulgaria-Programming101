<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>stranal/WorkWrap.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
%
% (c) The GRASP/AQUA Project, Glasgow University, 1993-1998
%
\section[WorkWrap]{Worker/wrapper-generating back-end of strictness analyser}

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>{-# OPTIONS -fno-warn-tabs #-}</span>
<a name="line-2"></a><span class='hs-comment'>-- The above warning supression flag is a temporary kludge.</span>
<a name="line-3"></a><span class='hs-comment'>-- While working on this module you are encouraged to remove it and</span>
<a name="line-4"></a><span class='hs-comment'>-- detab the module (please do the detabbing in a separate patch). See</span>
<a name="line-5"></a><span class='hs-comment'>--     <a href="http://ghc.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces">http://ghc.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces</a></span>
<a name="line-6"></a><span class='hs-comment'>-- for details</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>WorkWrap</span> <span class='hs-layout'>(</span> <span class='hs-varid'>wwTopBinds</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreSyn</span>
<a name="line-11"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreUnfold</span>	<span class='hs-layout'>(</span> <span class='hs-varid'>certainlyWillInline</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkInlineUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkWwInlineRule</span> <span class='hs-layout'>)</span>
<a name="line-12"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreUtils</span>	<span class='hs-layout'>(</span> <span class='hs-varid'>exprType</span><span class='hs-layout'>,</span> <span class='hs-varid'>exprIsHNF</span> <span class='hs-layout'>)</span>
<a name="line-13"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreArity</span>	<span class='hs-layout'>(</span> <span class='hs-varid'>exprArity</span> <span class='hs-layout'>)</span>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Id</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>IdInfo</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>UniqSupply</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>		<span class='hs-layout'>(</span> <span class='hs-varid'>isEmptyVarEnv</span> <span class='hs-layout'>)</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Demand</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>WwLib</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FamInstEnv</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MonadUtils</span>
<a name="line-27"></a>
<a name="line-28"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
</pre>\end{code}

We take Core bindings whose binders have:

\begin{enumerate}

\item Strictness attached (by the front-end of the strictness
analyser), and / or

\item Constructed Product Result information attached by the CPR
analysis pass.

\end{enumerate}

and we return some ``plain'' bindings which have been
worker/wrapper-ified, meaning:

\begin{enumerate}

\item Functions have been split into workers and wrappers where
appropriate.  If a function has both strictness and CPR properties
then only one worker/wrapper doing both transformations is produced;

\item Binders' @IdInfos@ have been updated to reflect the existence of
these workers/wrappers (this is where we get STRICTNESS and CPR pragma
info for exported values).
\end{enumerate}

\begin{code}
<pre><a name="line-1"></a><a name="wwTopBinds"></a><span class='hs-definition'>wwTopBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSupply</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreProgram</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreProgram</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-definition'>wwTopBinds</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>us</span> <span class='hs-varid'>top_binds</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>initUs_</span> <span class='hs-varid'>us</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-5"></a>    <span class='hs-varid'>top_binds'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>wwBind</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span><span class='hs-layout'>)</span> <span class='hs-varid'>top_binds</span>
<a name="line-6"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span> <span class='hs-varid'>top_binds'</span><span class='hs-layout'>)</span>
</pre>\end{code}

%************************************************************************
%*									*
\subsection[wwBind-wwExpr]{@wwBind@ and @wwExpr@}
%*									*
%************************************************************************

@wwBind@ works on a binding, trying each \tr{(binder, expr)} pair in
turn.  Non-recursive case first, then recursive...

\begin{code}
<pre><a name="line-1"></a><a name="wwBind"></a><span class='hs-definition'>wwBind</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-2"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-3"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-4"></a>	<span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span>	<span class='hs-comment'>-- returns a WwBinding intermediate form;</span>
<a name="line-5"></a>				<span class='hs-comment'>-- the caller will convert to Expr/Binding,</span>
<a name="line-6"></a>				<span class='hs-comment'>-- as appropriate.</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-definition'>wwBind</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>binder</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-9"></a>    <span class='hs-varid'>new_rhs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>rhs</span>
<a name="line-10"></a>    <span class='hs-varid'>new_pairs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryWW</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-conid'>NonRecursive</span> <span class='hs-varid'>binder</span> <span class='hs-varid'>new_rhs</span>
<a name="line-11"></a>    <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>new_pairs</span><span class='hs-keyglyph'>]</span>
<a name="line-12"></a>      <span class='hs-comment'>-- Generated bindings must be non-recursive</span>
<a name="line-13"></a>      <span class='hs-comment'>-- because the original binding was.</span>
<a name="line-14"></a>
<a name="line-15"></a><span class='hs-definition'>wwBind</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span>
<a name="line-16"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Rec</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>concatMapM</span> <span class='hs-varid'>do_one</span> <span class='hs-varid'>pairs</span>
<a name="line-17"></a>  <span class='hs-keyword'>where</span>
<a name="line-18"></a>    <span class='hs-varid'>do_one</span> <span class='hs-layout'>(</span><span class='hs-varid'>binder</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>new_rhs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>rhs</span>
<a name="line-19"></a>                              <span class='hs-varid'>tryWW</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-conid'>Recursive</span> <span class='hs-varid'>binder</span> <span class='hs-varid'>new_rhs</span>
</pre>\end{code}

@wwExpr@ basically just walks the tree, looking for appropriate
annotations that can be used. Remember it is @wwBind@ that does the
matching by looking for strict arguments of the correct type.
@wwExpr@ is a version that just returns the ``Plain'' Tree.

\begin{code}
<pre><a name="line-1"></a><a name="wwExpr"></a><span class='hs-definition'>wwExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-definition'>wwExpr</span> <span class='hs-keyword'>_</span>      <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>e</span>
<a name="line-4"></a><span class='hs-definition'>wwExpr</span> <span class='hs-keyword'>_</span>      <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>e</span>
<a name="line-5"></a><span class='hs-definition'>wwExpr</span> <span class='hs-keyword'>_</span>      <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Lit</span>  <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>e</span>
<a name="line-6"></a><span class='hs-definition'>wwExpr</span> <span class='hs-keyword'>_</span>      <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span>  <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>e</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-definition'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>binder</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>binder</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>expr</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-definition'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-12"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>App</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>f</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>a</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-definition'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>note</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-15"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>note</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>expr</span>
<a name="line-16"></a>
<a name="line-17"></a><span class='hs-definition'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-18"></a>    <span class='hs-varid'>new_expr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>expr</span>
<a name="line-19"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>new_expr</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-20"></a>
<a name="line-21"></a><span class='hs-definition'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-22"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLets</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>wwBind</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>bind</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>expr</span>
<a name="line-23"></a>
<a name="line-24"></a><span class='hs-definition'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>binder</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-25"></a>    <span class='hs-varid'>new_expr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>expr</span>
<a name="line-26"></a>    <span class='hs-varid'>new_alts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>ww_alt</span> <span class='hs-varid'>alts</span>
<a name="line-27"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>new_expr</span> <span class='hs-varid'>binder</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>new_alts</span><span class='hs-layout'>)</span>
<a name="line-28"></a>  <span class='hs-keyword'>where</span>
<a name="line-29"></a>    <span class='hs-varid'>ww_alt</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>binders</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-30"></a>        <span class='hs-varid'>new_rhs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>wwExpr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>rhs</span>
<a name="line-31"></a>        <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>binders</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span>
</pre>\end{code}

%************************************************************************
%*									*
\subsection[tryWW]{@tryWW@: attempt a worker/wrapper pair}
%*									*
%************************************************************************

@tryWW@ just accumulates arguments, converts strictness info from the
front-end into the proper form, then calls @mkWwBodies@ to do
the business.

The only reason this is monadised is for the unique supply.

Note [Don't w/w INLINE things]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
It's very important to refrain from w/w-ing an INLINE function (ie one
with an InlineRule) because the wrapper will then overwrite the
InlineRule unfolding.

Furthermore, if the programmer has marked something as INLINE,
we may lose by w/w'ing it.

If the strictness analyser is run twice, this test also prevents
wrappers (which are INLINEd) from being re-done.  (You can end up with
several liked-named Ids bouncing around at the same time---absolute
mischief.)

Notice that we refrain from w/w'ing an INLINE function even if it is
in a recursive group.  It might not be the loop breaker.  (We could
test for loop-breaker-hood, but I'm not sure that ever matters.)

Note [Don't w/w INLINABLE things]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If we have
  {-# INLINABLE f #-}
  f x y = ....
then in principle we might get a more efficient loop by w/w'ing f.
But that would make a new unfolding which would overwrite the old
one.  So we leave INLINABLE things alone too.

This is a slight infelicity really, because it means that adding
an INLINABLE pragma could make a program a bit less efficient,
because you lose the worker/wrapper stuff.  But I don't see a way
to avoid that.

Note [Don't w/w inline small non-loop-breaker things]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In general, we refrain from w/w-ing *small* functions, which are not
loop breakers, because they'll inline anyway.  But we must take care:
it may look small now, but get to be big later after other inlining
has happened.  So we take the precaution of adding an INLINE pragma to
any such functions.

I made this change when I observed a big function at the end of
compilation with a useful strictness signature but no w-w.  (It was
small during demand analysis, we refrained from w/w, and then got big
when something was inlined in its rhs.) When I measured it on nofib,
it didn't make much difference; just a few percent improved allocation
on one benchmark (bspt/Euclid.space).  But nothing got worse.

There is an infelicity though.  We may get something like
      f = g val
==>
      g x = case gw x of r -> I# r

      f {- InlineStable, Template = g val -}
      f = case gw x of r -> I# r

The code for f duplicates that for g, without any real benefit. It
won't really be executed, because calls to f will go via the inlining.

Note [Wrapper activation]
~~~~~~~~~~~~~~~~~~~~~~~~~
When should the wrapper inlining be active?  It must not be active
earlier than the current Activation of the Id (eg it might have a
NOINLINE pragma).  But in fact strictness analysis happens fairly
late in the pipeline, and we want to prioritise specialisations over
strictness.  Eg if we have
  module Foo where
    f :: Num a => a -> Int -> a
    f n 0 = n  	       	   -- Strict in the Int, hence wrapper
    f n x = f (n+n) (x-1)

    g :: Int -> Int
    g x = f x x		   -- Provokes a specialisation for f

  module Bsr where
    import Foo

    h :: Int -> Int
    h x = f 3 x

Then we want the specialisation for 'f' to kick in before the wrapper does.

Now in fact the 'gentle' simplification pass encourages this, by
having rules on, but inlinings off.  But that's kind of lucky. It seems
more robust to give the wrapper an Activation of (ActiveAfter 0),
so that it becomes active in an importing module at the same time that
it appears in the first place in the defining module.

\begin{code}
<pre><a name="line-1"></a><a name="tryWW"></a><span class='hs-definition'>tryWW</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-2"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-3"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RecFlag</span>
<a name="line-4"></a>	<span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>				<span class='hs-comment'>-- The fn binder</span>
<a name="line-5"></a>	<span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>			<span class='hs-comment'>-- The bound rhs; its innards</span>
<a name="line-6"></a>					<span class='hs-comment'>--   are already ww'd</span>
<a name="line-7"></a>	<span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>	<span class='hs-comment'>-- either *one* or *two* pairs;</span>
<a name="line-8"></a>					<span class='hs-comment'>-- if one, then no worker (only</span>
<a name="line-9"></a>					<span class='hs-comment'>-- the orig "wrapper" lives on);</span>
<a name="line-10"></a>					<span class='hs-comment'>-- if two, then a worker and a</span>
<a name="line-11"></a>					<span class='hs-comment'>-- wrapper.</span>
<a name="line-12"></a><span class='hs-definition'>tryWW</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>fn_id</span> <span class='hs-varid'>rhs</span>
<a name="line-13"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNeverActive</span> <span class='hs-varid'>inline_act</span>
<a name="line-14"></a>	<span class='hs-comment'>-- No point in worker/wrappering if the thing is never inlined!</span>
<a name="line-15"></a>	<span class='hs-comment'>-- Because the no-inline prag will prevent the wrapper ever</span>
<a name="line-16"></a>	<span class='hs-comment'>-- being inlined at a call site.</span>
<a name="line-17"></a>	<span class='hs-comment'>--</span>
<a name="line-18"></a>	<span class='hs-comment'>-- Furthermore, don't even expose strictness info</span>
<a name="line-19"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>fn_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-20"></a>
<a name="line-21"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-22"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-23"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>doSplit</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_fun</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitFun</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>new_fn_id</span> <span class='hs-varid'>fn_info</span> <span class='hs-varid'>wrap_dmds</span> <span class='hs-varid'>res_info</span> <span class='hs-varid'>rhs</span>
<a name="line-24"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_thunk</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitThunk</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>new_fn_id</span> <span class='hs-varid'>rhs</span>
<a name="line-25"></a>	                                        <span class='hs-comment'>-- See Note [Thunk splitting]</span>
<a name="line-26"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
<a name="line-27"></a>    <span class='hs-varid'>try</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>doSplit</span>
<a name="line-28"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>try</span> <span class='hs-keyword'>of</span>
<a name="line-29"></a>        <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span>    <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_fn_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-30"></a>        <span class='hs-conid'>Just</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>checkSize</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>new_fn_id</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>binds</span>
<a name="line-31"></a>
<a name="line-32"></a>  <span class='hs-keyword'>where</span>
<a name="line-33"></a>    <span class='hs-varid'>fn_info</span>	 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idInfo</span> <span class='hs-varid'>fn_id</span>
<a name="line-34"></a>    <span class='hs-varid'>inline_act</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inlinePragmaActivation</span> <span class='hs-layout'>(</span><span class='hs-varid'>inlinePragInfo</span> <span class='hs-varid'>fn_info</span><span class='hs-layout'>)</span>
<a name="line-35"></a>
<a name="line-36"></a>	<span class='hs-comment'>-- In practice it always will have a strictness</span>
<a name="line-37"></a>	<span class='hs-comment'>-- signature, even if it's a uninformative one</span>
<a name="line-38"></a>    <span class='hs-varid'>strict_sig</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strictnessInfo</span> <span class='hs-varid'>fn_info</span>
<a name="line-39"></a>    <span class='hs-conid'>StrictSig</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>wrap_dmds</span> <span class='hs-varid'>res_info</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strict_sig</span>
<a name="line-40"></a>
<a name="line-41"></a>	<span class='hs-comment'>-- new_fn_id has the DmdEnv zapped.</span>
<a name="line-42"></a>	<span class='hs-comment'>--	(a) it is never used again</span>
<a name="line-43"></a>	<span class='hs-comment'>--	(b) it wastes space</span>
<a name="line-44"></a>	<span class='hs-comment'>--	(c) it becomes incorrect as things are cloned, because</span>
<a name="line-45"></a>	<span class='hs-comment'>--	    we don't push the substitution into it</span>
<a name="line-46"></a>    <span class='hs-varid'>new_fn_id</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyVarEnv</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn_id</span>
<a name="line-47"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn_id</span> <span class='hs-varop'>`setIdStrictness`</span>
<a name="line-48"></a>                                     <span class='hs-varid'>mkClosedStrictSig</span> <span class='hs-varid'>wrap_dmds</span> <span class='hs-varid'>res_info</span>
<a name="line-49"></a>
<a name="line-50"></a>    <span class='hs-varid'>is_fun</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>notNull</span> <span class='hs-varid'>wrap_dmds</span>
<a name="line-51"></a>    <span class='hs-varid'>is_thunk</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-varid'>is_fun</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprIsHNF</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-52"></a>
<a name="line-53"></a><a name="checkSize"></a><span class='hs-comment'>---------------------</span>
<a name="line-54"></a><span class='hs-definition'>checkSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-55"></a><span class='hs-definition'>checkSize</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fn_id</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>thing_inside</span>
<a name="line-56"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>realIdUnfolding</span> <span class='hs-varid'>fn_id</span><span class='hs-layout'>)</span>
<a name="line-57"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>fn_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-58"></a>      <span class='hs-comment'>-- See Note [Don't w/w INLINE things]</span>
<a name="line-59"></a>      <span class='hs-comment'>-- and Note [Don't w/w INLINABLE things]</span>
<a name="line-60"></a>      <span class='hs-comment'>-- NB: use realIdUnfolding because we want to see the unfolding</span>
<a name="line-61"></a>      <span class='hs-comment'>--     even if it's a loop breaker!</span>
<a name="line-62"></a>
<a name="line-63"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>certainlyWillInline</span> <span class='hs-varid'>dflags</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>fn_id</span><span class='hs-layout'>)</span>
<a name="line-64"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>fn_id</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>inline_rule</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-65"></a>	<span class='hs-comment'>-- Note [Don't w/w inline small non-loop-breaker things]</span>
<a name="line-66"></a>	<span class='hs-comment'>-- NB: use idUnfolding because we don't want to apply</span>
<a name="line-67"></a>	<span class='hs-comment'>--     this criterion to a loop breaker!</span>
<a name="line-68"></a>
<a name="line-69"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>thing_inside</span>
<a name="line-70"></a>  <span class='hs-keyword'>where</span>
<a name="line-71"></a>    <span class='hs-varid'>inline_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInlineUnfolding</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>rhs</span>
<a name="line-72"></a>
<a name="line-73"></a><a name="splitFun"></a><span class='hs-comment'>---------------------</span>
<a name="line-74"></a><span class='hs-definition'>splitFun</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IdInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdResult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-75"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-76"></a><span class='hs-definition'>splitFun</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>fn_id</span> <span class='hs-varid'>fn_info</span> <span class='hs-varid'>wrap_dmds</span> <span class='hs-varid'>res_info</span> <span class='hs-varid'>rhs</span>
<a name="line-77"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_dmds</span> <span class='hs-varop'>`lengthIs`</span> <span class='hs-varid'>arity</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fn_id</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>arity</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wrap_dmds</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>res_info</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>do</span>
<a name="line-78"></a>    <span class='hs-comment'>-- The arity should match the signature</span>
<a name="line-79"></a>    <span class='hs-varid'>stuff</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWwBodies</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>wrap_dmds</span> <span class='hs-varid'>res_info</span> <span class='hs-varid'>one_shots</span>
<a name="line-80"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>stuff</span> <span class='hs-keyword'>of</span>
<a name="line-81"></a>      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_demands</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-82"></a>        <span class='hs-varid'>work_uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-83"></a>        <span class='hs-keyword'>let</span> <span class='hs-varid'>work_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>work_fn</span> <span class='hs-varid'>rhs</span>
<a name="line-84"></a>	    <span class='hs-varid'>work_id</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWorkerId</span> <span class='hs-varid'>work_uniq</span> <span class='hs-varid'>fn_id</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>work_rhs</span><span class='hs-layout'>)</span>
<a name="line-85"></a>		        <span class='hs-varop'>`setIdOccInfo`</span> <span class='hs-varid'>occInfo</span> <span class='hs-varid'>fn_info</span>
<a name="line-86"></a>				<span class='hs-comment'>-- Copy over occurrence info from parent</span>
<a name="line-87"></a>				<span class='hs-comment'>-- Notably whether it's a loop breaker</span>
<a name="line-88"></a>				<span class='hs-comment'>-- Doesn't matter much, since we will simplify next, but</span>
<a name="line-89"></a>				<span class='hs-comment'>-- seems right-er to do so</span>
<a name="line-90"></a>
<a name="line-91"></a>			<span class='hs-varop'>`setInlineActivation`</span> <span class='hs-layout'>(</span><span class='hs-varid'>inlinePragmaActivation</span> <span class='hs-varid'>inl_prag</span><span class='hs-layout'>)</span>
<a name="line-92"></a>				<span class='hs-comment'>-- Any inline activation (which sets when inlining is active)</span>
<a name="line-93"></a>				<span class='hs-comment'>-- on the original function is duplicated on the worker</span>
<a name="line-94"></a>				<span class='hs-comment'>-- It *matters* that the pragma stays on the wrapper</span>
<a name="line-95"></a>				<span class='hs-comment'>-- It seems sensible to have it on the worker too, although we</span>
<a name="line-96"></a>				<span class='hs-comment'>-- can't think of a compelling reason. (In ptic, INLINE things are</span>
<a name="line-97"></a>				<span class='hs-comment'>-- not w/wd). However, the RuleMatchInfo is not transferred since</span>
<a name="line-98"></a>                                <span class='hs-comment'>-- it does not make sense for workers to be constructorlike.</span>
<a name="line-99"></a>
<a name="line-100"></a>			<span class='hs-varop'>`setIdStrictness`</span> <span class='hs-varid'>mkClosedStrictSig</span> <span class='hs-varid'>work_demands</span> <span class='hs-varid'>work_res_info</span>
<a name="line-101"></a>				<span class='hs-comment'>-- Even though we may not be at top level,</span>
<a name="line-102"></a>				<span class='hs-comment'>-- it's ok to give it an empty DmdEnv</span>
<a name="line-103"></a>
<a name="line-104"></a>                        <span class='hs-varop'>`setIdArity`</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprArity</span> <span class='hs-varid'>work_rhs</span><span class='hs-layout'>)</span>
<a name="line-105"></a>                                <span class='hs-comment'>-- Set the arity so that the Core Lint check that the</span>
<a name="line-106"></a>                                <span class='hs-comment'>-- arity is consistent with the demand type goes through</span>
<a name="line-107"></a>
<a name="line-108"></a>	    <span class='hs-varid'>wrap_rhs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrap_fn</span> <span class='hs-varid'>work_id</span>
<a name="line-109"></a>	    <span class='hs-varid'>wrap_prag</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InlinePragma</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inl_inline</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Inline</span>
<a name="line-110"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>inl_sat</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-111"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>inl_act</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ActiveAfter</span> <span class='hs-num'>0</span>
<a name="line-112"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>inl_rule</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule_match_info</span> <span class='hs-layout'>}</span>
<a name="line-113"></a>		<span class='hs-comment'>-- See Note [Wrapper activation]</span>
<a name="line-114"></a>		<span class='hs-comment'>-- The RuleMatchInfo is (and must be) unaffected</span>
<a name="line-115"></a>		<span class='hs-comment'>-- The inl_inline is bound to be False, else we would not be</span>
<a name="line-116"></a>		<span class='hs-comment'>--    making a wrapper</span>
<a name="line-117"></a>
<a name="line-118"></a>            <span class='hs-varid'>wrap_id</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn_id</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>mkWwInlineRule</span> <span class='hs-varid'>wrap_rhs</span> <span class='hs-varid'>arity</span>
<a name="line-119"></a>			      <span class='hs-varop'>`setInlinePragma`</span> <span class='hs-varid'>wrap_prag</span>
<a name="line-120"></a>		              <span class='hs-varop'>`setIdOccInfo`</span> <span class='hs-conid'>NoOccInfo</span>
<a name="line-121"></a>			        <span class='hs-comment'>-- Zap any loop-breaker-ness, to avoid bleating from Lint</span>
<a name="line-122"></a>				<span class='hs-comment'>-- about a loop breaker with an INLINE rule</span>
<a name="line-123"></a>        <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Just</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>work_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_rhs</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-124"></a>            <span class='hs-comment'>-- Worker first, because wrapper mentions it</span>
<a name="line-125"></a>            <span class='hs-comment'>-- mkWwBodies has already built a wrap_rhs with an INLINE pragma wrapped around it</span>
<a name="line-126"></a>
<a name="line-127"></a>      <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-128"></a>        <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
<a name="line-129"></a>  <span class='hs-keyword'>where</span>
<a name="line-130"></a>    <span class='hs-varid'>fun_ty</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>fn_id</span>
<a name="line-131"></a>    <span class='hs-varid'>inl_prag</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inlinePragInfo</span> <span class='hs-varid'>fn_info</span>
<a name="line-132"></a>    <span class='hs-varid'>rule_match_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inlinePragmaRuleMatchInfo</span> <span class='hs-varid'>inl_prag</span>
<a name="line-133"></a>    <span class='hs-varid'>arity</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityInfo</span> <span class='hs-varid'>fn_info</span>
<a name="line-134"></a>    		    <span class='hs-comment'>-- The arity is set by the simplifier using exprEtaExpandArity</span>
<a name="line-135"></a>		    <span class='hs-comment'>-- So it may be more than the number of top-level-visible lambdas</span>
<a name="line-136"></a>
<a name="line-137"></a>    <span class='hs-varid'>work_res_info</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isBotRes</span> <span class='hs-varid'>res_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>botRes</span>	<span class='hs-comment'>-- Cpr stuff done by wrapper</span>
<a name="line-138"></a>		  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>	      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topRes</span>
<a name="line-139"></a>
<a name="line-140"></a>    <span class='hs-varid'>one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>get_one_shots</span> <span class='hs-varid'>rhs</span>
<a name="line-141"></a>
<a name="line-142"></a><a name="get_one_shots"></a><span class='hs-comment'>-- If the original function has one-shot arguments, it is important to</span>
<a name="line-143"></a><span class='hs-comment'>-- make the wrapper and worker have corresponding one-shot arguments too.</span>
<a name="line-144"></a><span class='hs-comment'>-- Otherwise we spuriously float stuff out of case-expression join points,</span>
<a name="line-145"></a><span class='hs-comment'>-- which is very annoying.</span>
<a name="line-146"></a><span class='hs-definition'>get_one_shots</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShotInfo</span><span class='hs-keyglyph'>]</span>
<a name="line-147"></a><span class='hs-definition'>get_one_shots</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-148"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>b</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idOneShotInfo</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>get_one_shots</span> <span class='hs-varid'>e</span>
<a name="line-149"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>get_one_shots</span> <span class='hs-varid'>e</span>
<a name="line-150"></a><span class='hs-definition'>get_one_shots</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>get_one_shots</span> <span class='hs-varid'>e</span>
<a name="line-151"></a><span class='hs-definition'>get_one_shots</span> <span class='hs-keyword'>_</span>    	 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
</pre>\end{code}

Note [Do not split void functions]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider this rather common form of binding:
        $j = \x:Void# -> ...no use of x...

Since x is not used it'll be marked as absent.  But there is no point
in w/w-ing because we'll simply add (\y:Void#), see WwLib.mkWorerArgs.

If x has a more interesting type (eg Int, or Int#), there *is* a point
in w/w so that we don't pass the argument at all.

Note [Thunk splitting]
~~~~~~~~~~~~~~~~~~~~~~
Suppose x is used strictly (never mind whether it has the CPR
property).

      let
	x* = x-rhs
      in body

splitThunk transforms like this:

      let
	x* = case x-rhs of { I# a -> I# a }
      in body

Now simplifier will transform to

      case x-rhs of
	I# a ->	let x* = I# a
	        in body

which is what we want. Now suppose x-rhs is itself a case:

	x-rhs = case e of { T -> I# a; F -> I# b }

The join point will abstract over a, rather than over (which is
what would have happened before) which is fine.

Notice that x certainly has the CPR property now!

In fact, splitThunk uses the function argument w/w splitting
function, so that if x's demand is deeper (say U(U(L,L),L))
then the splitting will go deeper too.

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>-- See Note [Thunk splitting]</span>
<a name="line-2"></a><span class='hs-comment'>-- splitThunk converts the *non-recursive* binding</span>
<a name="line-3"></a><span class='hs-comment'>--	x = e</span>
<a name="line-4"></a><span class='hs-comment'>-- into</span>
<a name="line-5"></a><span class='hs-comment'>--	x = let x = e</span>
<a name="line-6"></a><span class='hs-comment'>--	    in case x of</span>
<a name="line-7"></a><span class='hs-comment'>--		 I# y -&gt; let x = I# y in x }</span>
<a name="line-8"></a><span class='hs-comment'>-- See comments above. Is it not beautifully short?</span>
<a name="line-9"></a><span class='hs-comment'>-- Moreover, it works just as well when there are</span>
<a name="line-10"></a><span class='hs-comment'>-- several binders, and if the binders are lifted</span>
<a name="line-11"></a><span class='hs-comment'>-- E.g.     x = e</span>
<a name="line-12"></a><span class='hs-comment'>--     --&gt;  x = let x = e in</span>
<a name="line-13"></a><span class='hs-comment'>--              case x of (a,b) -&gt; let x = (a,b)  in x</span>
<a name="line-14"></a>
<a name="line-15"></a><a name="splitThunk"></a><span class='hs-definition'>splitThunk</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RecFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>Expr</span> <span class='hs-conid'>Var</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-16"></a><span class='hs-definition'>splitThunk</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>fn_id</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-17"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>useful</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>fn_id</span><span class='hs-keyglyph'>]</span>
<a name="line-18"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>fn_id</span><span class='hs-layout'>,</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>fn_id</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_fn</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_fn</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>fn_id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-19"></a>    <span class='hs-keyword'>if</span> <span class='hs-varid'>useful</span> <span class='hs-keyword'>then</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>isNonRec</span> <span class='hs-varid'>is_rec</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fn_id</span> <span class='hs-layout'>)</span> <span class='hs-comment'>-- The thunk must be non-recursive</span>
<a name="line-20"></a>                   <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>
<a name="line-21"></a>              <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
</pre>\end{code}
</body>
</html>
