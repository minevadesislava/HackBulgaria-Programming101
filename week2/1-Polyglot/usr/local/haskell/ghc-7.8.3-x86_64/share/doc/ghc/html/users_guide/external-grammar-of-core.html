<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>10.2. External Grammar of Core</title><link rel="stylesheet" type="text/css" href="fptools.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.8.3"><link rel="up" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html" title="Chapter 10. An External Representation for the GHC Core Language (For GHC 6.10)"><link rel="prev" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html" title="Chapter 10. An External Representation for the GHC Core Language (For GHC 6.10)"><link rel="next" href="informal-semantics.html" title="10.3. Informal Semantics"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">10.2. External Grammar of Core</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html">Prev</a> </td><th width="60%" align="center">Chapter 10. An External Representation for the GHC Core Language (For GHC 6.10)</th><td width="20%" align="right"> <a accesskey="n" href="informal-semantics.html">Next</a></td></tr></table><hr></div><div class="section" title="10.2. External Grammar of Core"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="external-grammar-of-core"></a>10.2. External Grammar of Core</h2></div></div></div><p>In designing the external grammar, we have tried to strike a
    balance among a number of competing goals, including easy
    parseability by machines, easy readability by humans, and adequate
    structural simplicity to allow straightforward presentations of
    the semantics. Thus, we had to make some compromises.
    Specifically:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">In order to avoid explosion of parentheses, we support
      standard precedences and short-cuts for expressions, types,
      and kinds. Thus we had to introduce multiple non-terminals for
      each of these syntactic categories, and as a result, the
      concrete grammar is longer and more complex than the
      underlying abstract syntax.</li><li class="listitem">On the other hand, we have kept the grammar simpler by
      avoiding special syntax for tuple types and terms. Tuples
      (both boxed and unboxed) are treated as ordinary constructors.</li><li class="listitem">All type abstractions and applications are given in full, even
      though some of them (e.g., for tuples) could be reconstructed;
      this means a parser for Core does not have to reconstruct
      types.<sup>[<a name="idp33028656" href="#ftn.idp33028656" class="footnote">17</a>]</sup></li><li class="listitem">The syntax of identifiers is heavily restricted (to just
      alphanumerics and underscores); this again makes Core easier
      to parse but harder to read.</li></ul></div><p>We use the following notational conventions for syntax:

    </p><div class="informaltable"><table border="0"><colgroup><col><col></colgroup><tbody><tr><td align="left">[ pat ]</td><td align="left">optional</td></tr><tr><td align="left">{ pat }</td><td align="left">zero or more repetitions</td></tr><tr><td align="left">
              { pat }<sup>+</sup>
            </td><td align="left">one or more repetitions</td></tr><tr><td align="left">
              pat<sub>1</sub> &#8739; pat<sub>2</sub>
            </td><td align="left">choice</td></tr><tr><td align="left">
              <code class="code">fibonacci</code>
            </td><td align="left">terminal syntax in typewriter font</td></tr></tbody></table></div><p>
    </p><div class="informaltable"><table border="0"><colgroup><col align="left" class="cat"><col align="right" class="lhs"><col align="center"><col align="left" class="rhs"><col align="right" class="name"></colgroup><tbody><tr><td align="left">Module</td><td align="right">module</td><td align="center">&#8594;</td><td align="left">
              <code class="code">%module</code> mident { tdef ; }{ vdefg ; }
            </td><td align="right"> </td></tr><tr><td rowspan="2" align="left" valign="top">Type defn.</td><td rowspan="2" align="right" valign="top">tdef</td><td align="center">&#8594;</td><td align="left">
              <code class="code">%data</code> qtycon { tbind } <code class="code">= {</code>  [ cdef {<code class="code">;</code> cdef } ] <code class="code">}</code>
            </td><td align="right">algebraic type</td></tr><tr><td align="center">&#8739;</td><td align="left">
              <code class="code">%newtype</code> qtycon qtycon { tbind } <code class="code">=</code> ty
            </td><td align="right">newtype</td></tr><tr><td align="left">Constr. defn.</td><td align="right">cdef</td><td align="center">&#8594;</td><td align="left">
              qdcon { <code class="code">@</code> tbind }{ aty }<sup>+</sup>
            </td><td class="auto-generated"> </td></tr><tr><td rowspan="3" align="left" valign="top">Value defn.</td><td rowspan="2" align="right" valign="top">vdefg</td><td align="center">&#8594;</td><td align="left"><code class="code">%rec {</code> vdef { <code class="code">;</code> vdef } <code class="code">}</code></td><td align="right">recursive</td></tr><tr><td align="center">&#8739;</td><td align="left">vdef</td><td align="right">non-recursive</td></tr><tr><td align="right">vdef</td><td align="center">&#8594;</td><td align="left">qvar <code class="code">::</code> ty <code class="code">=</code> exp</td><td align="right"> </td></tr><tr><td rowspan="4" align="left" valign="top">Atomic expr.</td><td rowspan="4" align="right" valign="top">aexp</td><td align="center">&#8594;</td><td align="left">qvar</td><td align="right">variable</td></tr><tr><td align="center">&#8739;</td><td align="left">qdcon</td><td align="right">data constructor</td></tr><tr><td align="center">&#8739;</td><td align="left">lit</td><td align="right">literal</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">(</code> exp <code class="code">)</code></td><td align="right">nested expr.</td></tr><tr><td rowspan="10" align="left" valign="top">Expression</td><td rowspan="10" align="right" valign="top">exp</td><td align="center">&#8594;</td><td align="left">aexp</td><td align="right">atomic expresion</td></tr><tr><td align="center">&#8739;</td><td align="left">aexp { arg }<sup>+</sup></td><td align="right">application</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">\</code> { binder }<sup>+</sup> -&gt; exp</td><td align="right">abstraction</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%let</code> vdefg <code class="code">%in</code> exp</td><td align="right">local definition</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%case (</code> aty <code class="code">)</code> exp <code class="code">%of</code> vbind <code class="code">{</code> alt { <code class="code">;</code> alt } <code class="code">}</code></td><td align="right">case expression</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%cast</code> exp aty</td><td align="right">type coercion</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%note</code> " { char } " exp</td><td align="right">expression note</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%external ccall "</code> { char } <code class="code">"</code> aty</td><td align="right">external reference</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%dynexternal ccall</code> aty</td><td align="right">external reference (dynamic)</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%label "</code> { char } <code class="code">"</code></td><td align="right">external label</td></tr><tr><td rowspan="2" align="left" valign="top">Argument</td><td rowspan="2" align="right" valign="top">arg</td><td align="center">&#8594;</td><td align="left"><code class="code">@</code> aty</td><td align="right">type argument</td></tr><tr><td align="center">&#8739;</td><td align="left">aexp</td><td align="right">value argument</td></tr><tr><td rowspan="3" align="left" valign="top">Case alt.</td><td rowspan="3" align="right" valign="top">alt</td><td align="center">&#8594;</td><td align="left">qdcon { <code class="code">@</code> tbind }{ vbind } <code class="code">-&gt;</code> exp</td><td align="right">constructor alternative</td></tr><tr><td align="center">&#8739;</td><td align="left">lit <code class="code">-&gt;</code> exp</td><td align="right">literal alternative</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%_ -&gt;</code> exp</td><td align="right">default alternative</td></tr><tr><td rowspan="2" align="left" valign="top">Binder</td><td rowspan="2" align="right" valign="top">binder</td><td align="center">&#8594;</td><td align="left"><code class="code">@</code> tbind</td><td align="right">type binder</td></tr><tr><td align="center">&#8739;</td><td align="left">vbind</td><td align="right">value binder</td></tr><tr><td rowspan="2" align="left" valign="top">Type binder</td><td rowspan="2" align="right" valign="top">tbind</td><td align="center">&#8594;</td><td align="left">tyvar</td><td align="right">implicitly of kind *</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">(</code> tyvar <code class="code">::</code> kind <code class="code">)</code></td><td align="right">explicitly kinded</td></tr><tr><td align="left">Value binder</td><td align="right">vbind</td><td align="center">&#8594;</td><td align="left"><code class="code">(</code> var <code class="code">::</code> ty <code class="code">)</code></td><td align="right"> </td></tr><tr><td rowspan="4" align="left" valign="top">Literal</td><td rowspan="4" align="right" valign="top">lit</td><td align="center">&#8594;</td><td align="left"><code class="code">(</code> [<code class="code">-</code>] { digit }<sup>+</sup> <code class="code">::</code> ty <code class="code">)</code></td><td align="right">integer</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">(</code> [<code class="code">-</code>] { digit }<sup>+</sup> <code class="code">%</code> { digit }<sup>+</sup> <code class="code">::</code> ty <code class="code">)</code></td><td align="right">rational</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">( '</code> char <code class="code">' ::</code> ty <code class="code">)</code></td><td align="right">character</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">( "</code> { char } <code class="code">" ::</code> ty <code class="code">)</code></td><td align="right">string</td></tr><tr><td rowspan="3" align="left" valign="top">Character</td><td rowspan="2" align="right" valign="top">char</td><td align="center">&#8594;</td><td colspan="2" align="left"><span class="emphasis"><em>any ASCII character in range 0x20-0x7E except 0x22,0x27,0x5c</em></span></td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">\x</code> hex hex</td><td align="right">ASCII code escape sequence</td></tr><tr><td align="right">hex</td><td align="center">&#8594;</td><td align="left">0&#8739;&#8230;&#8739;9 &#8739;a &#8739;&#8230;&#8739;f</td><td align="right"> </td></tr><tr><td rowspan="3" align="left" valign="top">Atomic type</td><td rowspan="3" align="right" valign="top">aty</td><td align="center">&#8594;</td><td align="left">tyvar</td><td align="right">type variable</td></tr><tr><td align="center">&#8739;</td><td align="left">qtycon</td><td align="right">type constructor</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">(</code> ty <code class="code">)</code></td><td align="right">nested type</td></tr><tr><td rowspan="8" align="left" valign="top">Basic type</td><td rowspan="8" align="right" valign="top">bty</td><td align="center">&#8594;</td><td align="left">aty</td><td align="right">atomic type</td></tr><tr><td align="center">&#8739;</td><td align="left">bty aty</td><td align="right">type application</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%trans</code> aty aty</td><td align="right">transitive coercion</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%sym</code> aty</td><td align="right">symmetric coercion</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%unsafe</code> aty aty</td><td align="right">unsafe coercion</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%left</code> aty</td><td align="right">left coercion</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%right</code> aty</td><td align="right">right coercion</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%inst</code> aty aty</td><td align="right">instantiation coercion</td></tr><tr><td rowspan="3" align="left" valign="top">Type</td><td rowspan="3" align="right" valign="top">ty</td><td align="center">&#8594;</td><td align="left">bty</td><td align="right">basic type</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">%forall</code> { tbind }<sup>+</sup> <code class="code">.</code> ty</td><td align="right">type abstraction</td></tr><tr><td align="center">&#8739;</td><td align="left">bty <code class="code">-&gt;</code> ty</td><td align="right">arrow type construction</td></tr><tr><td rowspan="5" align="left" valign="top">Atomic kind</td><td rowspan="5" align="right" valign="top">akind</td><td align="center">&#8594;</td><td align="left"><code class="code">*</code></td><td align="right">lifted kind</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">#</code></td><td align="right">unlifted kind</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">?</code></td><td align="right">open kind</td></tr><tr><td align="center">&#8739;</td><td align="left">bty <code class="code">:=:</code> bty</td><td align="right">equality kind</td></tr><tr><td align="center">&#8739;</td><td align="left"><code class="code">(</code> kind <code class="code">)</code></td><td align="right">nested kind</td></tr><tr><td rowspan="2" align="left" valign="top">Kind</td><td rowspan="2" align="right" valign="top">kind</td><td align="center">&#8594;</td><td align="left">akind</td><td align="right">atomic kind</td></tr><tr><td align="center">&#8739;</td><td align="left">akind <code class="code">-&gt;</code> kind</td><td align="right">arrow kind</td></tr><tr><td rowspan="8" align="left" valign="top">Identifier</td><td align="right">mident</td><td align="center">&#8594;</td><td align="left">pname <code class="code">:</code> uname</td><td align="right">module</td></tr><tr><td align="right">tycon</td><td align="center">&#8594;</td><td align="left">uname</td><td align="right">type constr.</td></tr><tr><td align="right">qtycon</td><td align="center">&#8594;</td><td align="left">mident <code class="code">.</code> tycon</td><td align="right">qualified type constr.</td></tr><tr><td align="right">tyvar</td><td align="center">&#8594;</td><td align="left">lname</td><td align="right">type variable</td></tr><tr><td align="right">dcon</td><td align="center">&#8594;</td><td align="left">uname</td><td align="right">data constr.</td></tr><tr><td align="right">qdcon</td><td align="center">&#8594;</td><td align="left">mident <code class="code">.</code> dcon</td><td align="right">qualified data constr.</td></tr><tr><td align="right">var</td><td align="center">&#8594;</td><td align="left">lname</td><td align="right">variable</td></tr><tr><td align="right">qvar</td><td align="center">&#8594;</td><td align="left">[ mident <code class="code">.</code> ] var</td><td align="right">optionally qualified variable</td></tr><tr><td rowspan="7" align="left" valign="top">Name</td><td align="right">lname</td><td align="center">&#8594;</td><td align="left">lower { namechar }</td><td align="right"> </td></tr><tr><td align="right">uname</td><td align="center">&#8594;</td><td align="left">upper { namechar }</td><td align="right"> </td></tr><tr><td align="right">pname</td><td align="center">&#8594;</td><td align="left">{ namechar }<sup>+</sup></td><td align="right"> </td></tr><tr><td align="right">namechar</td><td align="center">&#8594;</td><td align="left">lower &#8739; upper &#8739; digit</td><td align="right"> </td></tr><tr><td align="right">lower</td><td align="center">&#8594;</td><td align="left"><code class="code">a</code> &#8739; <code class="code">b</code> &#8739; &#8230; &#8739; <code class="code">z</code> &#8739; <code class="code">_</code></td><td align="right"> </td></tr><tr><td align="right">upper</td><td align="center">&#8594;</td><td align="left"><code class="code">A</code> &#8739; <code class="code">B</code> &#8739; &#8230; &#8739; <code class="code">Z</code></td><td align="right"> </td></tr><tr><td align="right">digit</td><td align="center">&#8594;</td><td align="left"><code class="code">0</code> &#8739; <code class="code">1</code> &#8739; &#8230; &#8739; <code class="code">9</code></td><td align="right"> </td></tr></tbody></table></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="informal-semantics.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 10. An External Representation for the GHC Core Language (For GHC 6.10) </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 10.3. Informal Semantics</td></tr></table></div></body></html>
