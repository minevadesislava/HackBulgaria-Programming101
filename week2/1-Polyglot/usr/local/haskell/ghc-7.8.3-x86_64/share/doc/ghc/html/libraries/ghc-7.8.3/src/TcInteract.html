<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcInteract.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
\begin{code}
<pre><a name="line-1"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcInteract</span> <span class='hs-layout'>(</span>
<a name="line-2"></a>     <span class='hs-varid'>solveInteractGiven</span><span class='hs-layout'>,</span>  <span class='hs-comment'>-- Solves [EvVar],GivenLoc</span>
<a name="line-3"></a>     <span class='hs-varid'>solveInteract</span><span class='hs-layout'>,</span>       <span class='hs-comment'>-- Solves Cts</span>
<a name="line-4"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span> <span class='hs-conid'>()</span>
<a name="line-9"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcCanonical</span>
<a name="line-10"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-11"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-12"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unify</span>
<a name="line-13"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>InstEnv</span><span class='hs-layout'>(</span> <span class='hs-varid'>lookupInstEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>instanceDFunId</span> <span class='hs-layout'>)</span>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoAxiom</span><span class='hs-layout'>(</span><span class='hs-varid'>sfInteractTop</span><span class='hs-layout'>,</span> <span class='hs-varid'>sfInteractInert</span><span class='hs-layout'>)</span>
<a name="line-15"></a>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelNames</span> <span class='hs-layout'>(</span><span class='hs-varid'>knownNatClassName</span><span class='hs-layout'>,</span> <span class='hs-varid'>knownSymbolClassName</span><span class='hs-layout'>,</span> <span class='hs-varid'>ipClassNameKey</span> <span class='hs-layout'>)</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TysWiredIn</span> <span class='hs-layout'>(</span> <span class='hs-varid'>coercibleClass</span> <span class='hs-layout'>)</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Id</span><span class='hs-layout'>(</span> <span class='hs-varid'>idType</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkSysLocalM</span> <span class='hs-layout'>)</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DataCon</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>RdrName</span> <span class='hs-layout'>(</span> <span class='hs-conid'>GlobalRdrEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>lookupGRE_Name</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkRdrQual</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_as</span><span class='hs-layout'>,</span>
<a name="line-26"></a>                 <span class='hs-varid'>is_decl</span><span class='hs-layout'>,</span> <span class='hs-conid'>Provenance</span><span class='hs-layout'>(</span><span class='hs-conid'>Imported</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>gre_prov</span> <span class='hs-layout'>)</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FunDeps</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FamInstEnv</span> <span class='hs-layout'>(</span> <span class='hs-conid'>FamInstEnvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>instNewTyConTF_maybe</span> <span class='hs-layout'>)</span>
<a name="line-29"></a>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-32"></a>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnTypes</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcErrors</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSMonad</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-37"></a>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span> <span class='hs-varid'>foldM</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span> <span class='hs-varid'>catMaybes</span> <span class='hs-layout'>)</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span><span class='hs-layout'>(</span> <span class='hs-varid'>partition</span> <span class='hs-layout'>)</span>
<a name="line-41"></a>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-43"></a>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-layout'>(</span> <span class='hs-varid'>when</span><span class='hs-layout'>,</span> <span class='hs-varid'>unless</span><span class='hs-layout'>,</span> <span class='hs-varid'>forM</span> <span class='hs-layout'>)</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Pair</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unique</span><span class='hs-layout'>(</span> <span class='hs-varid'>hasKey</span> <span class='hs-layout'>)</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span> <span class='hs-layout'>(</span> <span class='hs-varid'>sLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsLit</span> <span class='hs-layout'>)</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
</pre>\end{code}

**********************************************************************
*                                                                    *
*                      Main Interaction Solver                       *
*                                                                    *
**********************************************************************

Note [Basic Simplifier Plan]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Pick an element from the WorkList if there exists one with depth
   less than our context-stack depth.

2. Run it down the 'stage' pipeline. Stages are:
      - canonicalization
      - inert reactions
      - spontaneous reactions
      - top-level intreactions
   Each stage returns a StopOrContinue and may have sideffected
   the inerts or worklist.

   The threading of the stages is as follows:
      - If (Stop) is returned by a stage then we start again from Step 1.
      - If (ContinueWith ct) is returned by a stage, we feed 'ct' on to
        the next stage in the pipeline.
4. If the element has survived (i.e. ContinueWith x) the last stage
   then we add him in the inerts and jump back to Step 1.

If in Step 1 no such element exists, we have exceeded our context-stack
depth and will simply fail.

\begin{code}
<pre><a name="line-1"></a><a name="solveInteractGiven"></a><span class='hs-definition'>solveInteractGiven</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-definition'>solveInteractGiven</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>old_fsks</span> <span class='hs-varid'>givens</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>givens</span>  <span class='hs-comment'>-- Shortcut for common case</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>old_fsks</span><span class='hs-layout'>)</span>
<a name="line-5"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-6"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>implics1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveInteract</span> <span class='hs-varid'>fsk_bag</span>
<a name="line-7"></a>
<a name="line-8"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>no_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>more_fsks</span><span class='hs-layout'>,</span> <span class='hs-varid'>implics2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getGivenInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveInteract</span> <span class='hs-varid'>given_bag</span><span class='hs-layout'>)</span>
<a name="line-9"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implics1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implics2</span> <span class='hs-layout'>)</span>
<a name="line-10"></a>           <span class='hs-comment'>-- empty implics because we discard Given equalities between</span>
<a name="line-11"></a>           <span class='hs-comment'>-- foralls (see Note [Do not decompose given polytype equalities]</span>
<a name="line-12"></a>           <span class='hs-comment'>-- in TcCanonical), and those are the ones that can give</span>
<a name="line-13"></a>           <span class='hs-comment'>-- rise to new implications</span>
<a name="line-14"></a>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>no_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>more_fsks</span> <span class='hs-varop'>++</span> <span class='hs-varid'>old_fsks</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-16"></a>  <span class='hs-keyword'>where</span>
<a name="line-17"></a>    <span class='hs-varid'>given_bag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>listToBag</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mkNonCanonical</span> <span class='hs-varop'>$</span> <span class='hs-conid'>CtGiven</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evtm</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvId</span> <span class='hs-varid'>ev_id</span>
<a name="line-18"></a>                                                     <span class='hs-layout'>,</span> <span class='hs-varid'>ctev_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evVarPred</span> <span class='hs-varid'>ev_id</span>
<a name="line-19"></a>                                                     <span class='hs-layout'>,</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span>
<a name="line-20"></a>                          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ev_id</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>givens</span> <span class='hs-keyglyph'>]</span>
<a name="line-21"></a>
<a name="line-22"></a>    <span class='hs-varid'>fsk_bag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>listToBag</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mkNonCanonical</span> <span class='hs-varop'>$</span> <span class='hs-conid'>CtGiven</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evtm</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>tv_ty</span><span class='hs-layout'>)</span>
<a name="line-23"></a>                                                   <span class='hs-layout'>,</span> <span class='hs-varid'>ctev_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pred</span>
<a name="line-24"></a>                                                   <span class='hs-layout'>,</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span>
<a name="line-25"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>old_fsks</span>
<a name="line-26"></a>                        <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-conid'>FlatSkol</span> <span class='hs-varid'>fam_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcTyVarDetails</span> <span class='hs-varid'>tv</span>
<a name="line-27"></a>                              <span class='hs-varid'>tv_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span>
<a name="line-28"></a>                              <span class='hs-varid'>pred</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcEqPred</span> <span class='hs-varid'>fam_ty</span> <span class='hs-varid'>tv_ty</span>
<a name="line-29"></a>                        <span class='hs-keyglyph'>]</span>
<a name="line-30"></a>
<a name="line-31"></a><a name="solveInteract"></a><span class='hs-comment'>-- The main solver loop implements Note [Basic Simplifier Plan]</span>
<a name="line-32"></a><span class='hs-comment'>---------------------------------------------------------------</span>
<a name="line-33"></a><span class='hs-definition'>solveInteract</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-34"></a><span class='hs-comment'>-- Returns the final InertSet in TcS</span>
<a name="line-35"></a><span class='hs-comment'>-- Has no effect on work-list or residual-iplications</span>
<a name="line-36"></a><span class='hs-definition'>solveInteract</span> <span class='hs-varid'>cts</span>
<a name="line-37"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "solveInteract" #-}</span>
<a name="line-38"></a>    <span class='hs-varid'>withWorkList</span> <span class='hs-varid'>cts</span> <span class='hs-varop'>$</span>
<a name="line-39"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dyn_flags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-40"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solve_loop</span> <span class='hs-layout'>(</span><span class='hs-varid'>maxSubGoalDepth</span> <span class='hs-varid'>dyn_flags</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-41"></a>  <span class='hs-keyword'>where</span>
<a name="line-42"></a>    <span class='hs-varid'>solve_loop</span> <span class='hs-varid'>max_depth</span>
<a name="line-43"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "solve_loop" #-}</span>
<a name="line-44"></a>        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>selectNextWorkItem</span> <span class='hs-varid'>max_depth</span>
<a name="line-45"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>sel</span> <span class='hs-keyword'>of</span>
<a name="line-46"></a>              <span class='hs-conid'>NoWorkRemaining</span>     <span class='hs-comment'>-- Done, successfuly (modulo frozen)</span>
<a name="line-47"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-48"></a>              <span class='hs-conid'>MaxDepthExceeded</span> <span class='hs-varid'>cnt</span> <span class='hs-varid'>ct</span> <span class='hs-comment'>-- Failure, depth exceeded</span>
<a name="line-49"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>wrapErrTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>solverDepthErrorTcS</span> <span class='hs-varid'>cnt</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-50"></a>              <span class='hs-conid'>NextWorkItem</span> <span class='hs-varid'>ct</span>     <span class='hs-comment'>-- More work, loop around!</span>
<a name="line-51"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>runSolverPipeline</span> <span class='hs-varid'>thePipeline</span> <span class='hs-varid'>ct</span><span class='hs-layout'>;</span> <span class='hs-varid'>solve_loop</span> <span class='hs-varid'>max_depth</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-52"></a>
<a name="line-53"></a><a name="WorkItem"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Ct</span>
<a name="line-54"></a><a name="SimplifierStage"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>SimplifierStage</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-55"></a>
<a name="line-56"></a><a name="SelectWorkItem"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>SelectWorkItem</span>
<a name="line-57"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoWorkRemaining</span>      <span class='hs-comment'>-- No more work left (effectively we're done!)</span>
<a name="line-58"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>MaxDepthExceeded</span> <span class='hs-conid'>SubGoalCounter</span> <span class='hs-conid'>Ct</span>
<a name="line-59"></a>                              <span class='hs-comment'>-- More work left to do but this constraint has exceeded</span>
<a name="line-60"></a>                              <span class='hs-comment'>-- the maximum depth for one of the subgoal counters and we</span>
<a name="line-61"></a>                              <span class='hs-comment'>-- must stop</span>
<a name="line-62"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NextWorkItem</span> <span class='hs-conid'>Ct</span>      <span class='hs-comment'>-- More work left, here's the next item to look at</span>
<a name="line-63"></a>
<a name="line-64"></a><a name="selectNextWorkItem"></a><span class='hs-definition'>selectNextWorkItem</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SubGoalDepth</span> <span class='hs-comment'>-- Max depth allowed</span>
<a name="line-65"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>SelectWorkItem</span>
<a name="line-66"></a><span class='hs-definition'>selectNextWorkItem</span> <span class='hs-varid'>max_depth</span>
<a name="line-67"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updWorkListTcS_return</span> <span class='hs-varid'>pick_next</span>
<a name="line-68"></a>  <span class='hs-keyword'>where</span>
<a name="line-69"></a>    <span class='hs-varid'>pick_next</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WorkList</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>SelectWorkItem</span><span class='hs-layout'>,</span> <span class='hs-conid'>WorkList</span><span class='hs-layout'>)</span>
<a name="line-70"></a>    <span class='hs-varid'>pick_next</span> <span class='hs-varid'>wl</span>
<a name="line-71"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>selectWorkItem</span> <span class='hs-varid'>wl</span> <span class='hs-keyword'>of</span>
<a name="line-72"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-73"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>NoWorkRemaining</span><span class='hs-layout'>,</span><span class='hs-varid'>wl</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- No more work</span>
<a name="line-74"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_wl</span><span class='hs-layout'>)</span>
<a name="line-75"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>cnt</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>subGoalDepthExceeded</span> <span class='hs-varid'>max_depth</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctLocDepth</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctLoc</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Depth exceeded</span>
<a name="line-76"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>MaxDepthExceeded</span> <span class='hs-varid'>cnt</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span><span class='hs-varid'>new_wl</span><span class='hs-layout'>)</span>
<a name="line-77"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_wl</span><span class='hs-layout'>)</span>
<a name="line-78"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>NextWorkItem</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_wl</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- New workitem and worklist</span>
<a name="line-79"></a>
<a name="line-80"></a><a name="runSolverPipeline"></a><span class='hs-definition'>runSolverPipeline</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>String</span><span class='hs-layout'>,</span><span class='hs-conid'>SimplifierStage</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- The pipeline</span>
<a name="line-81"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WorkItem</span>                   <span class='hs-comment'>-- The work item</span>
<a name="line-82"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-83"></a><span class='hs-comment'>-- Run this item down the pipeline, leaving behind new work and inerts</span>
<a name="line-84"></a><span class='hs-definition'>runSolverPipeline</span> <span class='hs-varid'>pipeline</span> <span class='hs-varid'>workItem</span>
<a name="line-85"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>initial_is</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-86"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Start solver pipeline {"</span> <span class='hs-varop'>$</span>
<a name="line-87"></a>                  <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"work item = "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>workItem</span>
<a name="line-88"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"inerts    = "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>initial_is</span><span class='hs-keyglyph'>]</span>
<a name="line-89"></a>
<a name="line-90"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>bumpStepCountTcS</span>    <span class='hs-comment'>-- One step for each constraint processed</span>
<a name="line-91"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>final_res</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>run_pipeline</span> <span class='hs-varid'>pipeline</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span>
<a name="line-92"></a>
<a name="line-93"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>final_is</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-94"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>final_res</span> <span class='hs-keyword'>of</span>
<a name="line-95"></a>           <span class='hs-conid'>Stop</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"End solver pipeline (discharged) }"</span>
<a name="line-96"></a>                                       <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"inerts    = "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>final_is</span><span class='hs-layout'>)</span>
<a name="line-97"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-98"></a>           <span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-varid'>ct</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Kept as inert"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-99"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"End solver pipeline (not discharged) }"</span> <span class='hs-varop'>$</span>
<a name="line-100"></a>                                       <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"final_item = "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span>
<a name="line-101"></a>                                            <span class='hs-layout'>,</span> <span class='hs-varid'>pprTvBndrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>varSetElems</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-102"></a>                                            <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"inerts     = "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>final_is</span><span class='hs-keyglyph'>]</span>
<a name="line-103"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>insertInertItemTcS</span> <span class='hs-varid'>ct</span> <span class='hs-layout'>}</span>
<a name="line-104"></a>       <span class='hs-layout'>}</span>
<a name="line-105"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>run_pipeline</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>String</span><span class='hs-layout'>,</span><span class='hs-conid'>SimplifierStage</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StopOrContinue</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-106"></a>        <span class='hs-varid'>run_pipeline</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>res</span>
<a name="line-107"></a>        <span class='hs-varid'>run_pipeline</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Stop</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-108"></a>        <span class='hs-varid'>run_pipeline</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>stg_name</span><span class='hs-layout'>,</span><span class='hs-varid'>stg</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>stgs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-109"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-layout'>(</span><span class='hs-str'>"runStage "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>stg_name</span> <span class='hs-varop'>++</span> <span class='hs-str'>" {"</span><span class='hs-layout'>)</span>
<a name="line-110"></a>                          <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"workitem   = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-111"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>stg</span> <span class='hs-varid'>ct</span>
<a name="line-112"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-layout'>(</span><span class='hs-str'>"end stage "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>stg_name</span> <span class='hs-varop'>++</span> <span class='hs-str'>" }"</span><span class='hs-layout'>)</span> <span class='hs-varid'>empty</span>
<a name="line-113"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>run_pipeline</span> <span class='hs-varid'>stgs</span> <span class='hs-varid'>res</span>
<a name="line-114"></a>               <span class='hs-layout'>}</span>
</pre>\end{code}

Example 1:
  Inert:   {c ~ d, F a ~ t, b ~ Int, a ~ ty} (all given)
  Reagent: a ~ [b] (given)

React with (c~d)     ==> IR (ContinueWith (a~[b]))  True    []
React with (F a ~ t) ==> IR (ContinueWith (a~[b]))  False   [F [b] ~ t]
React with (b ~ Int) ==> IR (ContinueWith (a~[Int]) True    []

Example 2:
  Inert:  {c ~w d, F a ~g t, b ~w Int, a ~w ty}
  Reagent: a ~w [b]

React with (c ~w d)   ==> IR (ContinueWith (a~[b]))  True    []
React with (F a ~g t) ==> IR (ContinueWith (a~[b]))  True    []    (can't rewrite given with wanted!)
etc.

Example 3:
  Inert:  {a ~ Int, F Int ~ b} (given)
  Reagent: F a ~ b (wanted)

React with (a ~ Int)   ==> IR (ContinueWith (F Int ~ b)) True []
React with (F Int ~ b) ==> IR Stop True []    -- after substituting we re-canonicalize and get nothing

\begin{code}
<pre><a name="line-1"></a><a name="thePipeline"></a><span class='hs-definition'>thePipeline</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>String</span><span class='hs-layout'>,</span><span class='hs-conid'>SimplifierStage</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-2"></a><span class='hs-definition'>thePipeline</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-str'>"canonicalization"</span><span class='hs-layout'>,</span>        <span class='hs-conid'>TcCanonical</span><span class='hs-varop'>.</span><span class='hs-varid'>canonicalize</span><span class='hs-layout'>)</span>
<a name="line-3"></a>              <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"interact with inerts"</span><span class='hs-layout'>,</span>    <span class='hs-varid'>interactWithInertsStage</span><span class='hs-layout'>)</span>
<a name="line-4"></a>              <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"top-level reactions"</span><span class='hs-layout'>,</span>     <span class='hs-varid'>topReactionsStage</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
</pre>\end{code}


*********************************************************************************
*                                                                               *
                       The interact-with-inert Stage
*                                                                               *
*********************************************************************************

Note [The Solver Invariant]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
We always add Givens first.  So you might think that the solver has
the invariant

   If the work-item is Given,
   then the inert item must Given

But this isn't quite true.  Suppose we have,
    c1: [W] beta ~ [alpha], c2 : [W] blah, c3 :[W] alpha ~ Int
After processing the first two, we get
     c1: [G] beta ~ [alpha], c2 : [W] blah
Now, c3 does not interact with the the given c1, so when we spontaneously
solve c3, we must re-react it with the inert set.  So we can attempt a
reaction between inert c2 [W] and work-item c3 [G].

It *is* true that [Solver Invariant]
   If the work-item is Given,
   AND there is a reaction
   then the inert item must Given
or, equivalently,
   If the work-item is Given,
   and the inert item is Wanted/Derived
   then there is no reaction

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>-- Interaction result of  WorkItem &lt;~&gt; Ct</span>
<a name="line-2"></a>
<a name="line-3"></a><a name="StopNowFlag"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>StopNowFlag</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bool</span>    <span class='hs-comment'>-- True &lt;=&gt; stop after this interaction</span>
<a name="line-4"></a>
<a name="line-5"></a><a name="interactWithInertsStage"></a><span class='hs-definition'>interactWithInertsStage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-6"></a><span class='hs-comment'>-- Precondition: if the workitem is a CTyEqCan then it will not be able to</span>
<a name="line-7"></a><span class='hs-comment'>-- react with anything at this stage.</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-definition'>interactWithInertsStage</span> <span class='hs-varid'>wi</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inerts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ics</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inert_cans</span> <span class='hs-varid'>inerts</span>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>mb_ics'</span><span class='hs-layout'>,</span> <span class='hs-varid'>stop</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>wi</span> <span class='hs-keyword'>of</span>
<a name="line-13"></a>             <span class='hs-conid'>CTyEqCan</span>    <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>interactTyVarEq</span> <span class='hs-varid'>ics</span> <span class='hs-varid'>wi</span>
<a name="line-14"></a>             <span class='hs-conid'>CFunEqCan</span>   <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>interactFunEq</span>   <span class='hs-varid'>ics</span> <span class='hs-varid'>wi</span>
<a name="line-15"></a>             <span class='hs-conid'>CIrredEvCan</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>interactIrred</span>   <span class='hs-varid'>ics</span> <span class='hs-varid'>wi</span>
<a name="line-16"></a>             <span class='hs-conid'>CDictCan</span>    <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>interactDict</span>    <span class='hs-varid'>ics</span> <span class='hs-varid'>wi</span>
<a name="line-17"></a>             <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"interactWithInerts"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span>
<a name="line-18"></a>                <span class='hs-comment'>-- CHoleCan are put straight into inert_frozen, so never get here</span>
<a name="line-19"></a>                <span class='hs-comment'>-- CNonCanonical have been canonicalised</span>
<a name="line-20"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ics'</span> <span class='hs-keyword'>of</span>
<a name="line-21"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>ics'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setTcSInerts</span> <span class='hs-layout'>(</span><span class='hs-varid'>inerts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_cans</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ics'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-22"></a>           <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>stop</span> <span class='hs-keyword'>of</span>
<a name="line-24"></a>            <span class='hs-conid'>True</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-25"></a>            <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

\begin{code}
<pre><a name="line-1"></a><a name="InteractResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>InteractResult</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IRKeep</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>IRReplace</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>IRDelete</span>
<a name="line-2"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>InteractResult</span> <span class='hs-keyword'>where</span>
<a name="line-3"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>IRKeep</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"keep"</span><span class='hs-layout'>)</span>
<a name="line-4"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>IRReplace</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"replace"</span><span class='hs-layout'>)</span>
<a name="line-5"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>IRDelete</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"delete"</span><span class='hs-layout'>)</span>
<a name="line-6"></a>
<a name="line-7"></a><a name="solveOneFromTheOther"></a><span class='hs-definition'>solveOneFromTheOther</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>  <span class='hs-comment'>-- Inert</span>
<a name="line-8"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>  <span class='hs-comment'>-- WorkItem</span>
<a name="line-9"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>InteractResult</span><span class='hs-layout'>,</span> <span class='hs-conid'>StopNowFlag</span><span class='hs-layout'>)</span>
<a name="line-10"></a><span class='hs-comment'>-- Preconditions:</span>
<a name="line-11"></a><span class='hs-comment'>-- 1) inert and work item represent evidence for the /same/ predicate</span>
<a name="line-12"></a><span class='hs-comment'>-- 2) ip/class/irred evidence (no coercions) only</span>
<a name="line-13"></a><span class='hs-definition'>solveOneFromTheOther</span> <span class='hs-varid'>ev_i</span> <span class='hs-varid'>ev_w</span>
<a name="line-14"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDerived</span> <span class='hs-varid'>ev_w</span>
<a name="line-15"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>IRKeep</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>
<a name="line-16"></a>
<a name="line-17"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDerived</span> <span class='hs-varid'>ev_i</span> <span class='hs-comment'>-- The inert item is Derived, we can just throw it away,</span>
<a name="line-18"></a>                   <span class='hs-comment'>-- The ev_w is inert wrt earlier inert-set items,</span>
<a name="line-19"></a>                   <span class='hs-comment'>-- so it's safe to continue on from this point</span>
<a name="line-20"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>IRDelete</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-21"></a>
<a name="line-22"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtWanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_id</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ev_w</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setEvBind</span> <span class='hs-varid'>ev_id</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>ev_i</span><span class='hs-layout'>)</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>IRKeep</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-25"></a>
<a name="line-26"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtWanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_id</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ev_i</span>
<a name="line-27"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setEvBind</span> <span class='hs-varid'>ev_id</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>ev_w</span><span class='hs-layout'>)</span>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>IRReplace</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-29"></a>
<a name="line-30"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-comment'>-- If both are Given, we already have evidence; no need to duplicate</span>
<a name="line-31"></a>                   <span class='hs-comment'>-- But the work item *overrides* the inert item (hence IRReplace)</span>
<a name="line-32"></a>                   <span class='hs-comment'>-- See Note [Shadowing of Implicit Parameters]</span>
<a name="line-33"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>IRReplace</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>
</pre>\end{code}

*********************************************************************************
*                                                                               *
                   interactIrred
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="interactIrred"></a><span class='hs-comment'>-- Two pieces of irreducible evidence: if their types are *exactly identical*</span>
<a name="line-2"></a><span class='hs-comment'>-- we can rewrite them. We can never improve using this:</span>
<a name="line-3"></a><span class='hs-comment'>-- if we want ty1 :: Constraint and have ty2 :: Constraint it clearly does not</span>
<a name="line-4"></a><span class='hs-comment'>-- mean that (ty1 ~ ty2)</span>
<a name="line-5"></a><span class='hs-definition'>interactIrred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertCans</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>InertCans</span><span class='hs-layout'>,</span> <span class='hs-conid'>StopNowFlag</span><span class='hs-layout'>)</span>
<a name="line-6"></a>
<a name="line-7"></a><span class='hs-definition'>interactIrred</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CIrredEvCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_w</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev_w</span>
<a name="line-9"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>matching_irreds</span><span class='hs-layout'>,</span> <span class='hs-varid'>others</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-10"></a>                                                 <span class='hs-layout'>(</span><span class='hs-varid'>inert_irreds</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span>
<a name="line-11"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct_i</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>matching_irreds</span>
<a name="line-12"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ctev_i</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>ct_i</span>
<a name="line-13"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>)</span>
<a name="line-14"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_effect</span><span class='hs-layout'>,</span> <span class='hs-varid'>stop_now</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveOneFromTheOther</span> <span class='hs-varid'>ctev_i</span> <span class='hs-varid'>ev_w</span>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>inerts'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>inert_effect</span> <span class='hs-keyword'>of</span>
<a name="line-16"></a>                          <span class='hs-conid'>IRKeep</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-17"></a>                          <span class='hs-conid'>IRDelete</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>inerts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_irreds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>others</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-18"></a>                          <span class='hs-conid'>IRReplace</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>inerts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_irreds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendCts</span> <span class='hs-varid'>others</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-varid'>stop_now</span> <span class='hs-varop'>$</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-varid'>workItem</span> <span class='hs-varop'>$</span>
<a name="line-20"></a>         <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Irred equal"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>inert_effect</span><span class='hs-layout'>)</span>
<a name="line-21"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>inerts'</span><span class='hs-layout'>,</span> <span class='hs-varid'>stop_now</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-22"></a>
<a name="line-23"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-24"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-25"></a>
<a name="line-26"></a><span class='hs-definition'>interactIrred</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>wi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"interactIrred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span>
</pre>\end{code}

*********************************************************************************
*                                                                               *
                   interactDict
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="interactDict"></a><span class='hs-definition'>interactDict</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertCans</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>InertCans</span><span class='hs-layout'>,</span> <span class='hs-conid'>StopNowFlag</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-definition'>interactDict</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_w</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>dicts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inert_dicts</span> <span class='hs-varid'>inerts</span>
<a name="line-4"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ct_i</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>findDict</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_dicts</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-5"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ctev_i</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>ct_i</span>
<a name="line-6"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_effect</span><span class='hs-layout'>,</span> <span class='hs-varid'>stop_now</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveOneFromTheOther</span> <span class='hs-varid'>ctev_i</span> <span class='hs-varid'>ev_w</span>
<a name="line-7"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>inerts'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>inert_effect</span> <span class='hs-keyword'>of</span>
<a name="line-8"></a>                          <span class='hs-conid'>IRKeep</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-9"></a>                          <span class='hs-conid'>IRDelete</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>inerts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_dicts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>delDict</span> <span class='hs-varid'>dicts</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-10"></a>                          <span class='hs-conid'>IRReplace</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>inerts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_dicts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addDict</span> <span class='hs-varid'>dicts</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-varid'>stop_now</span> <span class='hs-varop'>$</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-varid'>workItem</span> <span class='hs-varop'>$</span>
<a name="line-12"></a>         <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Dict equal"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>inert_effect</span><span class='hs-layout'>)</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>inerts'</span><span class='hs-layout'>,</span> <span class='hs-varid'>stop_now</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-14"></a>
<a name="line-15"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>ipClassNameKey</span>
<a name="line-16"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isGiven</span> <span class='hs-varid'>ev_w</span>
<a name="line-17"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interactGivenIP</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>workItem</span>
<a name="line-18"></a>
<a name="line-19"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-20"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mapBagM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>addFunDepWork</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>findDictsByClass</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_dicts</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span>
<a name="line-21"></a>               <span class='hs-comment'>-- Standard thing: create derived fds and keep on going. Importantly we don't</span>
<a name="line-22"></a>               <span class='hs-comment'>-- throw workitem back in the worklist because this can cause loops (see #5236)</span>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-24"></a>
<a name="line-25"></a><span class='hs-definition'>interactDict</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>wi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"interactDict"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span>
<a name="line-26"></a>
<a name="line-27"></a><a name="interactGivenIP"></a><span class='hs-definition'>interactGivenIP</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertCans</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>InertCans</span><span class='hs-layout'>,</span> <span class='hs-conid'>StopNowFlag</span><span class='hs-layout'>)</span>
<a name="line-28"></a><span class='hs-comment'>-- Work item is Given (?x:ty)</span>
<a name="line-29"></a><span class='hs-comment'>-- See Note [Shadowing of Implicit Parameters]</span>
<a name="line-30"></a><span class='hs-definition'>interactGivenIP</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>ip_str</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-31"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-varid'>workItem</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Given IP"</span><span class='hs-layout'>)</span>
<a name="line-32"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>inerts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_dicts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addDict</span> <span class='hs-varid'>filtered_dicts</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-33"></a>  <span class='hs-keyword'>where</span>
<a name="line-34"></a>    <span class='hs-varid'>dicts</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inert_dicts</span> <span class='hs-varid'>inerts</span>
<a name="line-35"></a>    <span class='hs-varid'>ip_dicts</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findDictsByClass</span> <span class='hs-varid'>dicts</span> <span class='hs-varid'>cls</span>
<a name="line-36"></a>    <span class='hs-varid'>other_ip_dicts</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>is_this_ip</span><span class='hs-layout'>)</span> <span class='hs-varid'>ip_dicts</span>
<a name="line-37"></a>    <span class='hs-varid'>filtered_dicts</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addDictsByClass</span> <span class='hs-varid'>dicts</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>other_ip_dicts</span>
<a name="line-38"></a>
<a name="line-39"></a>    <span class='hs-comment'>-- Pick out any Given constraints for the same implicit parameter</span>
<a name="line-40"></a>    <span class='hs-varid'>is_this_ip</span> <span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ip_str'</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-41"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isGiven</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>ip_str</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>ip_str'</span>
<a name="line-42"></a>    <span class='hs-varid'>is_this_ip</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-43"></a>
<a name="line-44"></a><span class='hs-definition'>interactGivenIP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>wi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"interactGivenIP"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span>
<a name="line-45"></a>
<a name="line-46"></a><a name="addFunDepWork"></a><span class='hs-definition'>addFunDepWork</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-47"></a><span class='hs-definition'>addFunDepWork</span> <span class='hs-varid'>work_ct</span> <span class='hs-varid'>inert_ct</span>
<a name="line-48"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>  <span class='hs-keyword'>let</span> <span class='hs-varid'>fd_eqns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>improveFromAnother</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>inert_ct</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>work_ct</span><span class='hs-layout'>)</span>
<a name="line-49"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>fd_work</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteWithFunDeps</span> <span class='hs-varid'>fd_eqns</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctLoc</span> <span class='hs-varid'>work_ct</span><span class='hs-layout'>)</span>
<a name="line-50"></a>                <span class='hs-comment'>-- We don't really rewrite tys2, see below _rewritten_tys2, so that's ok</span>
<a name="line-51"></a>                <span class='hs-comment'>-- NB: We do create FDs for given to report insoluble equations that arise</span>
<a name="line-52"></a>                <span class='hs-comment'>-- from pairs of Givens, and also because of floating when we approximate</span>
<a name="line-53"></a>                <span class='hs-comment'>-- implications. The relevant test is: typecheck/should_fail/FDsFromGivens.hs</span>
<a name="line-54"></a>                <span class='hs-comment'>-- Also see Note [When improvement happens]</span>
<a name="line-55"></a>
<a name="line-56"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"addFuNDepWork"</span>
<a name="line-57"></a>                  <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"inertItem ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inert_ct</span>
<a name="line-58"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"workItem  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>work_ct</span>
<a name="line-59"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"fundeps ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fd_work</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-60"></a>
<a name="line-61"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fd_work</span> <span class='hs-keyword'>of</span>
<a name="line-62"></a>           <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-63"></a>           <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEqs</span> <span class='hs-varid'>fd_work</span><span class='hs-layout'>)</span>    <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Shadowing of Implicit Parameters]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider the following example:

f :: (?x :: Char) => Char
f = let ?x = 'a' in ?x

The "let ?x = ..." generates an implication constraint of the form:

?x :: Char => ?x :: Char

Furthermore, the signature for `f` also generates an implication
constraint, so we end up with the following nested implication:

?x :: Char => (?x :: Char => ?x :: Char)

Note that the wanted (?x :: Char) constraint may be solved in
two incompatible ways:  either by using the parameter from the
signature, or by using the local definition.  Our intention is
that the local definition should "shadow" the parameter of the
signature, and we implement this as follows: when we add a new
*given* implicit parameter to the inert set, it replaces any existing
givens for the same implicit parameter.

This works for the normal cases but it has an odd side effect
in some pathological programs like this:

-- This is accepted, the second parameter shadows
f1 :: (?x :: Int, ?x :: Char) => Char
f1 = ?x

-- This is rejected, the second parameter shadows
f2 :: (?x :: Int, ?x :: Char) => Int
f2 = ?x

Both of these are actually wrong:  when we try to use either one,
we'll get two incompatible wnated constraints (?x :: Int, ?x :: Char),
which would lead to an error.

I can think of two ways to fix this:

  1. Simply disallow multiple constratits for the same implicit
    parameter---this is never useful, and it can be detected completely
    syntactically.

  2. Move the shadowing machinery to the location where we nest
     implications, and add some code here that will produce an
     error if we get multiple givens for the same implicit parameter.


*********************************************************************************
*                                                                               *
                   interactFunEq
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="interactFunEq"></a><span class='hs-definition'>interactFunEq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertCans</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>InertCans</span><span class='hs-layout'>,</span> <span class='hs-conid'>StopNowFlag</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-definition'>interactFunEq</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span>
<a name="line-3"></a>                                         <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_i</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_i</span> <span class='hs-layout'>}</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matching_inerts</span>
<a name="line-5"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>ev_i</span> <span class='hs-varop'>`canRewrite`</span> <span class='hs-varid'>ev</span>
<a name="line-6"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"interact with inerts: FunEq/FunEq"</span> <span class='hs-varop'>$</span>
<a name="line-7"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"workItem ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>workItem</span>
<a name="line-8"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"inertItem="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev_i</span> <span class='hs-keyglyph'>]</span>
<a name="line-9"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solveFunEq</span> <span class='hs-varid'>ev_i</span> <span class='hs-varid'>rhs_i</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>rhs</span>
<a name="line-10"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-11"></a>
<a name="line-12"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev_i</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ev_i</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_i</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_i</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matching_inerts</span>
<a name="line-13"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>rhs_i</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>rhs</span>    <span class='hs-comment'>-- Duplicates</span>
<a name="line-14"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>ev_i</span> <span class='hs-varop'>`canRewriteOrSame`</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>]</span>
<a name="line-15"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev_evar</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>ev_i</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-17"></a>
<a name="line-18"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>eq_is</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>eq_i</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matching_inerts</span>
<a name="line-19"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>`canRewrite`</span> <span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>eq_i</span>   <span class='hs-comment'>-- This is unusual</span>
<a name="line-20"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>solve</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_i</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_i</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-21"></a>                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solveFunEq</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>ev_i</span> <span class='hs-varid'>rhs_i</span>
<a name="line-22"></a>             <span class='hs-varid'>solve</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"interactFunEq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>solve</span> <span class='hs-varid'>eq_is</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>inerts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_funeqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>replaceFunEqs</span> <span class='hs-varid'>funeqs</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>args</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-25"></a>
<a name="line-26"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_i</span> <span class='hs-layout'>}</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matching_inerts</span>
<a name="line-27"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- We have  F ty ~ r1, F ty ~ r2, but neither can rewrite the other;</span>
<a name="line-28"></a>    <span class='hs-comment'>-- for example, they might both be Derived, or both Wanted</span>
<a name="line-29"></a>    <span class='hs-comment'>-- So we generate a new derived equality r1~r2</span>
<a name="line-30"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newDerived</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcEqPred</span> <span class='hs-varid'>rhs_i</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-31"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-32"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-33"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-34"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-35"></a>
<a name="line-36"></a>   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ops</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isBuiltInSynFamTyCon_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-37"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>is</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findFunEqsByTyCon</span> <span class='hs-varid'>funeqs</span> <span class='hs-varid'>tc</span>
<a name="line-38"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"builtInCandidates: "</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>is</span>
<a name="line-39"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>interact</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sfInteractInert</span> <span class='hs-varid'>ops</span> <span class='hs-varid'>args</span> <span class='hs-varid'>rhs</span>
<a name="line-40"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>impMbs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>sequence</span>
<a name="line-41"></a>                 <span class='hs-keyglyph'>[</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newDerived</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev_loc</span> <span class='hs-varid'>iev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcEqPred</span> <span class='hs-varid'>lhs_ty</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>)</span>
<a name="line-42"></a>                      <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-43"></a>                        <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>x</span>
<a name="line-44"></a>                        <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
<a name="line-45"></a>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>iargs</span>
<a name="line-46"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ixi</span>
<a name="line-47"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>iev</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>is</span>
<a name="line-48"></a>                 <span class='hs-layout'>,</span> <span class='hs-conid'>Pair</span> <span class='hs-varid'>lhs_ty</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>interact</span> <span class='hs-varid'>iargs</span> <span class='hs-varid'>ixi</span>
<a name="line-49"></a>                 <span class='hs-keyglyph'>]</span>
<a name="line-50"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>imps</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>catMaybes</span> <span class='hs-varid'>impMbs</span>
<a name="line-51"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>imps</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEqs</span> <span class='hs-varid'>imps</span><span class='hs-layout'>)</span>
<a name="line-52"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-53"></a>
<a name="line-54"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-55"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-56"></a>  <span class='hs-keyword'>where</span>
<a name="line-57"></a>    <span class='hs-varid'>funeqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inert_funeqs</span> <span class='hs-varid'>inerts</span>
<a name="line-58"></a>    <span class='hs-varid'>matching_inerts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findFunEqs</span> <span class='hs-varid'>funeqs</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>args</span>
<a name="line-59"></a>    <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-varid'>ev</span>
<a name="line-60"></a>
<a name="line-61"></a><span class='hs-definition'>interactFunEq</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>wi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"interactFunEq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span>
<a name="line-62"></a>
<a name="line-63"></a>
<a name="line-64"></a><a name="solveFunEq"></a><span class='hs-definition'>solveFunEq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>    <span class='hs-comment'>-- From this  :: F tys ~ xi1</span>
<a name="line-65"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-66"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>    <span class='hs-comment'>-- Solve this :: F tys ~ xi2</span>
<a name="line-67"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-68"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-69"></a><span class='hs-definition'>solveFunEq</span> <span class='hs-varid'>from_this</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>solve_this</span> <span class='hs-varid'>xi2</span>
<a name="line-70"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctevs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xCtEvidence</span> <span class='hs-varid'>solve_this</span> <span class='hs-varid'>xev</span>
<a name="line-71"></a>             <span class='hs-comment'>-- No caching!  See Note [Cache-caused loops]</span>
<a name="line-72"></a>             <span class='hs-comment'>-- Why not (mkTcEqPred xi1 xi2)? See Note [Efficient orientation]</span>
<a name="line-73"></a>
<a name="line-74"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitWorkNC</span> <span class='hs-varid'>ctevs</span> <span class='hs-layout'>}</span>
<a name="line-75"></a>  <span class='hs-keyword'>where</span>
<a name="line-76"></a>    <span class='hs-varid'>from_this_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evTermCoercion</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>from_this</span>
<a name="line-77"></a>
<a name="line-78"></a>    <span class='hs-varid'>xev</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XEvTerm</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>mkTcEqPred</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>xi1</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xcomp</span> <span class='hs-varid'>xdecomp</span>
<a name="line-79"></a>
<a name="line-80"></a>    <span class='hs-comment'>-- xcomp : [(xi2 ~ xi1)] -&gt; (F tys ~ xi2)</span>
<a name="line-81"></a>    <span class='hs-varid'>xcomp</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>from_this_co</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mk_sym_co</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-82"></a>    <span class='hs-varid'>xcomp</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"No more goals!"</span>
<a name="line-83"></a>
<a name="line-84"></a>    <span class='hs-comment'>-- xdecomp : (F tys ~ xi2) -&gt; [(xi2 ~ xi1)]</span>
<a name="line-85"></a>    <span class='hs-varid'>xdecomp</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_sym_co</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>from_this_co</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-86"></a>
<a name="line-87"></a>    <span class='hs-varid'>mk_sym_co</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>evTermCoercion</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Cache-caused loops]
~~~~~~~~~~~~~~~~~~~~~~~~~
It is very dangerous to cache a rewritten wanted family equation as 'solved' in our
solved cache (which is the default behaviour or xCtEvidence), because the interaction
may not be contributing towards a solution. Here is an example:

Initial inert set:
  [W] g1 : F a ~ beta1
Work item:
  [W] g2 : F a ~ beta2
The work item will react with the inert yielding the _same_ inert set plus:
    i)   Will set g2 := g1 `cast` g3
    ii)  Will add to our solved cache that [S] g2 : F a ~ beta2
    iii) Will emit [W] g3 : beta1 ~ beta2
Now, the g3 work item will be spontaneously solved to [G] g3 : beta1 ~ beta2
and then it will react the item in the inert ([W] g1 : F a ~ beta1). So it
will set
      g1 := g ; sym g3
and what is g? Well it would ideally be a new goal of type (F a ~ beta2) but
remember that we have this in our solved cache, and it is ... g2! In short we
created the evidence loop:

        g2 := g1 ; g3
        g3 := refl
        g1 := g2 ; sym g3

To avoid this situation we do not cache as solved any workitems (or inert)
which did not really made a 'step' towards proving some goal. Solved's are
just an optimization so we don't lose anything in terms of completeness of
solving.


Note [Efficient Orientation]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose we are interacting two FunEqCans with the same LHS:
          (inert)  ci :: (F ty ~ xi_i)
          (work)   cw :: (F ty ~ xi_w)
We prefer to keep the inert (else we pass the work item on down
the pipeline, which is a bit silly).  If we keep the inert, we
will (a) discharge 'cw'
     (b) produce a new equality work-item (xi_w ~ xi_i)
Notice the orientation (xi_w ~ xi_i) NOT (xi_i ~ xi_w):
    new_work :: xi_w ~ xi_i
    cw := ci ; sym new_work
Why?  Consider the simplest case when xi1 is a type variable.  If
we generate xi1~xi2, porcessing that constraint will kick out 'ci'.
If we generate xi2~xi1, there is less chance of that happening.
Of course it can and should still happen if xi1=a, xi1=Int, say.
But we want to avoid it happening needlessly.

Similarly, if we *can't* keep the inert item (because inert is Wanted,
and work is Given, say), we prefer to orient the new equality (xi_i ~
xi_w).

Note [Carefully solve the right CFunEqCan]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   ---- OLD COMMENT, NOW NOT NEEDED
   ---- because we now allow multiple
   ---- wanted FunEqs with the same head
Consider the constraints
  c1 :: F Int ~ a      -- Arising from an application line 5
  c2 :: F Int ~ Bool   -- Arising from an application line 10
Suppose that 'a' is a unification variable, arising only from
flattening.  So there is no error on line 5; it's just a flattening
variable.  But there is (or might be) an error on line 10.

Two ways to combine them, leaving either (Plan A)
  c1 :: F Int ~ a      -- Arising from an application line 5
  c3 :: a ~ Bool       -- Arising from an application line 10
or (Plan B)
  c2 :: F Int ~ Bool   -- Arising from an application line 10
  c4 :: a ~ Bool       -- Arising from an application line 5

Plan A will unify c3, leaving c1 :: F Int ~ Bool as an error
on the *totally innocent* line 5.  An example is test SimpleFail16
where the expected/actual message comes out backwards if we use
the wrong plan.

The second is the right thing to do.  Hence the isMetaTyVarTy
test when solving pairwise CFunEqCan.


*********************************************************************************
*                                                                               *
                   interactTyVarEq
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="interactTyVarEq"></a><span class='hs-definition'>interactTyVarEq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertCans</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>InertCans</span><span class='hs-layout'>,</span> <span class='hs-conid'>StopNowFlag</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-comment'>-- CTyEqCans are always consumed, returning Stop</span>
<a name="line-3"></a><span class='hs-definition'>interactTyVarEq</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>,</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev_i</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ev_i</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_i</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_i</span> <span class='hs-layout'>}</span>
<a name="line-5"></a>                             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>findTyEqs</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_eqs</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span> <span class='hs-varid'>tv</span>
<a name="line-6"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>ev_i</span> <span class='hs-varop'>`canRewriteOrSame`</span> <span class='hs-varid'>ev</span>
<a name="line-7"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>rhs_i</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>]</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>=</span>  <span class='hs-comment'>-- Inert:     a ~ b</span>
<a name="line-9"></a>     <span class='hs-comment'>-- Work item: a ~ b</span>
<a name="line-10"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev_evar</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>ev_i</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Solved from inert"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-13"></a>
<a name="line-14"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv_rhs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTyVar_maybe</span> <span class='hs-varid'>rhs</span>
<a name="line-15"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev_i</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ev_i</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_i</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_i</span> <span class='hs-layout'>}</span>
<a name="line-16"></a>                             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>findTyEqs</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_eqs</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span> <span class='hs-varid'>tv_rhs</span>
<a name="line-17"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>ev_i</span> <span class='hs-varop'>`canRewriteOrSame`</span> <span class='hs-varid'>ev</span>
<a name="line-18"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>rhs_i</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>]</span>
<a name="line-19"></a>  <span class='hs-keyglyph'>=</span>  <span class='hs-comment'>-- Inert:     a ~ b</span>
<a name="line-20"></a>     <span class='hs-comment'>-- Work item: b ~ a</span>
<a name="line-21"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev_evar</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-22"></a>                                <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>evTermCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>ev_i</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Solved from inert (r)"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-25"></a>
<a name="line-26"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-27"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_solved</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>trySpontaneousSolve</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs</span>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_solved</span> <span class='hs-keyword'>of</span>
<a name="line-29"></a>           <span class='hs-conid'>SPCantSolve</span>   <span class='hs-comment'>-- Includes givens</span>
<a name="line-30"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUntouchables</span>
<a name="line-31"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Can't solve tyvar equality"</span>
<a name="line-32"></a>                          <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"LHS:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-33"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>ppWhen</span> <span class='hs-layout'>(</span><span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-34"></a>                                  <span class='hs-varid'>nest</span> <span class='hs-num'>4</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Untouchable level of"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span>
<a name="line-35"></a>                                          <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"is"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>metaTyVarUntouchables</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-36"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"RHS:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-37"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Untouchables ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-38"></a>                    <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>n_kicked</span><span class='hs-layout'>,</span> <span class='hs-varid'>inerts'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>kickOutRewritable</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>inerts</span>
<a name="line-39"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-varid'>workItem</span> <span class='hs-varop'>$</span>
<a name="line-40"></a>                      <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Kept as inert"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr_kicked</span> <span class='hs-varid'>n_kicked</span>
<a name="line-41"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>addInertCan</span> <span class='hs-varid'>inerts'</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-42"></a>
<a name="line-43"></a>
<a name="line-44"></a>           <span class='hs-conid'>SPSolved</span> <span class='hs-varid'>new_tv</span>
<a name="line-45"></a>              <span class='hs-comment'>-- Post: tv ~ xi is now in TyBinds, no need to put in inerts as well</span>
<a name="line-46"></a>              <span class='hs-comment'>-- see Note [Spontaneously solved in TyBinds]</span>
<a name="line-47"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>n_kicked</span><span class='hs-layout'>,</span> <span class='hs-varid'>inerts'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>kickOutRewritable</span> <span class='hs-varid'>givenFlavour</span> <span class='hs-varid'>new_tv</span> <span class='hs-varid'>inerts</span>
<a name="line-48"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-varid'>workItem</span> <span class='hs-varop'>$</span>
<a name="line-49"></a>                      <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Spontaneously solved"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr_kicked</span> <span class='hs-varid'>n_kicked</span>
<a name="line-50"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>inerts'</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-51"></a>
<a name="line-52"></a><span class='hs-definition'>interactTyVarEq</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>wi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"interactTyVarEq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span>
<a name="line-53"></a>
<a name="line-54"></a><a name="givenFlavour"></a><span class='hs-definition'>givenFlavour</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-55"></a><span class='hs-comment'>-- Used just to pass to kickOutRewritable</span>
<a name="line-56"></a><span class='hs-definition'>givenFlavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CtGiven</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"givenFlavour:ev"</span>
<a name="line-57"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>ctev_evtm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"givenFlavour:tm"</span>
<a name="line-58"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>ctev_loc</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"givenFlavour:loc"</span> <span class='hs-layout'>}</span>
<a name="line-59"></a>
<a name="line-60"></a><a name="ppr_kicked"></a><span class='hs-definition'>ppr_kicked</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-61"></a><span class='hs-definition'>ppr_kicked</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>empty</span>
<a name="line-62"></a><span class='hs-definition'>ppr_kicked</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>int</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"kicked out"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Spontaneously solved in TyBinds]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When we encounter a constraint ([W] alpha ~ tau) which can be spontaneously solved,
we record the equality on the TyBinds of the TcSMonad. In the past, we used to also
add a /given/ version of the constraint ([G] alpha ~ tau) to the inert
canonicals -- and potentially kick out other equalities that mention alpha.

Then, the flattener only had to look in the inert equalities during flattening of a
type (TcCanonical.flattenTyVar).

However it is a bit silly to record these equalities /both/ in the inerts AND the
TyBinds, so we have now eliminated spontaneously solved equalities from the inerts,
and only record them in the TyBinds of the TcS monad. The flattener is now consulting
these binds /and/ the inerts for potentially unsolved or other given equalities.

\begin{code}
<pre><a name="line-1"></a><a name="kickOutRewritable"></a><span class='hs-definition'>kickOutRewritable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>   <span class='hs-comment'>-- Flavour of the equality that is</span>
<a name="line-2"></a>                                  <span class='hs-comment'>-- being added to the inert set</span>
<a name="line-3"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span>      <span class='hs-comment'>-- The new equality is tv ~ ty</span>
<a name="line-4"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InertCans</span>
<a name="line-5"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>InertCans</span><span class='hs-layout'>)</span>
<a name="line-6"></a><span class='hs-definition'>kickOutRewritable</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>new_tv</span>
<a name="line-7"></a>                  <span class='hs-layout'>(</span><span class='hs-conid'>IC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv_eqs</span>
<a name="line-8"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>inert_dicts</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dictmap</span>
<a name="line-9"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>inert_funeqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>funeqmap</span>
<a name="line-10"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>inert_irreds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irreds</span>
<a name="line-11"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>inert_insols</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span>
<a name="line-12"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>inert_no_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>no_eqs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-13"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"kickOutRewritable"</span> <span class='hs-varop'>$</span>
<a name="line-14"></a>            <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"tv = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>new_tv</span>
<a name="line-15"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Kicked out ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>kicked_out</span><span class='hs-keyglyph'>]</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>appendWorkList</span> <span class='hs-varid'>kicked_out</span><span class='hs-layout'>)</span>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>workListSize</span> <span class='hs-varid'>kicked_out</span><span class='hs-layout'>,</span> <span class='hs-varid'>inert_cans_in</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-18"></a>  <span class='hs-keyword'>where</span>
<a name="line-19"></a>                <span class='hs-comment'>-- NB: Notice that don't rewrite</span>
<a name="line-20"></a>                <span class='hs-comment'>-- inert_solved_dicts, and inert_solved_funeqs</span>
<a name="line-21"></a>                <span class='hs-comment'>-- optimistically. But when we lookup we have to</span>
<a name="line-22"></a>                <span class='hs-comment'>-- take the subsitution into account</span>
<a name="line-23"></a>    <span class='hs-varid'>inert_cans_in</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv_eqs_in</span>
<a name="line-24"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>inert_dicts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dicts_in</span>
<a name="line-25"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>inert_funeqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>feqs_in</span>
<a name="line-26"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>inert_irreds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irs_in</span>
<a name="line-27"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>inert_insols</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols_in</span>
<a name="line-28"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>inert_no_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>no_eqs</span> <span class='hs-layout'>}</span>
<a name="line-29"></a>
<a name="line-30"></a>    <span class='hs-varid'>kicked_out</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WorkList</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wl_eqs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv_eqs_out</span>
<a name="line-31"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>wl_funeqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-varid'>insertDeque</span> <span class='hs-varid'>emptyDeque</span> <span class='hs-varid'>feqs_out</span>
<a name="line-32"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>wl_rest</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bagToList</span> <span class='hs-layout'>(</span><span class='hs-varid'>dicts_out</span> <span class='hs-varop'>`andCts`</span> <span class='hs-varid'>irs_out</span>
<a name="line-33"></a>                                                   <span class='hs-varop'>`andCts`</span> <span class='hs-varid'>insols_out</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-34"></a>
<a name="line-35"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tv_eqs_out</span><span class='hs-layout'>,</span>  <span class='hs-varid'>tv_eqs_in</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldVarEnv</span> <span class='hs-varid'>kick_out_eqs</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyVarEnv</span><span class='hs-layout'>)</span> <span class='hs-varid'>tv_eqs</span>
<a name="line-36"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>feqs_out</span><span class='hs-layout'>,</span>   <span class='hs-varid'>feqs_in</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionFunEqs</span>  <span class='hs-varid'>kick_out_ct</span>    <span class='hs-varid'>funeqmap</span>
<a name="line-37"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>dicts_out</span><span class='hs-layout'>,</span>  <span class='hs-varid'>dicts_in</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionDicts</span>   <span class='hs-varid'>kick_out_ct</span>    <span class='hs-varid'>dictmap</span>
<a name="line-38"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>irs_out</span><span class='hs-layout'>,</span>    <span class='hs-varid'>irs_in</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span>     <span class='hs-varid'>kick_out_irred</span> <span class='hs-varid'>irreds</span>
<a name="line-39"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>insols_out</span><span class='hs-layout'>,</span> <span class='hs-varid'>insols_in</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span>     <span class='hs-varid'>kick_out_ct</span>    <span class='hs-varid'>insols</span>
<a name="line-40"></a>      <span class='hs-comment'>-- Kick out even insolubles; see Note [Kick out insolubles]</span>
<a name="line-41"></a>
<a name="line-42"></a>    <span class='hs-varid'>kick_out_ct</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-43"></a>    <span class='hs-varid'>kick_out_ct</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>new_ev</span> <span class='hs-varop'>`canRewrite`</span> <span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>ct</span>
<a name="line-44"></a>                   <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>new_tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span>
<a name="line-45"></a>         <span class='hs-comment'>-- See Note [Kicking out inert constraints]</span>
<a name="line-46"></a>
<a name="line-47"></a>    <span class='hs-varid'>kick_out_irred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-48"></a>    <span class='hs-varid'>kick_out_irred</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>new_ev</span> <span class='hs-varop'>`canRewrite`</span> <span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>ct</span>
<a name="line-49"></a>                      <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>new_tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>closeOverKinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-50"></a>          <span class='hs-comment'>-- See Note [Kicking out Irreds]</span>
<a name="line-51"></a>
<a name="line-52"></a>    <span class='hs-varid'>kick_out_eqs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>EqualCtList</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>TyVarEnv</span> <span class='hs-conid'>EqualCtList</span><span class='hs-layout'>)</span> 
<a name="line-53"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>TyVarEnv</span> <span class='hs-conid'>EqualCtList</span><span class='hs-layout'>)</span>
<a name="line-54"></a>    <span class='hs-varid'>kick_out_eqs</span> <span class='hs-varid'>eqs</span> <span class='hs-layout'>(</span><span class='hs-varid'>acc_out</span><span class='hs-layout'>,</span> <span class='hs-varid'>acc_in</span><span class='hs-layout'>)</span>
<a name="line-55"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqs_out</span> <span class='hs-varop'>++</span> <span class='hs-varid'>acc_out</span><span class='hs-layout'>,</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>eqs_in</span> <span class='hs-keyword'>of</span>
<a name="line-56"></a>                               <span class='hs-conid'>[]</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>acc_in</span>
<a name="line-57"></a>                               <span class='hs-layout'>(</span><span class='hs-varid'>eq1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-varid'>acc_in</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_tyvar</span> <span class='hs-varid'>eq1</span><span class='hs-layout'>)</span> <span class='hs-varid'>eqs_in</span><span class='hs-layout'>)</span>
<a name="line-58"></a>      <span class='hs-keyword'>where</span>
<a name="line-59"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>eqs_out</span><span class='hs-layout'>,</span> <span class='hs-varid'>eqs_in</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partition</span> <span class='hs-varid'>kick_out_eq</span> <span class='hs-varid'>eqs</span>
<a name="line-60"></a>
<a name="line-61"></a>
<a name="line-62"></a>    <span class='hs-varid'>kick_out_eq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-63"></a>    <span class='hs-varid'>kick_out_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-64"></a>      <span class='hs-keyglyph'>=</span>  <span class='hs-layout'>(</span><span class='hs-varid'>new_ev</span> <span class='hs-varop'>`canRewrite`</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See Note [Delicate equality kick-out]</span>
<a name="line-65"></a>      <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>kind_vars</span> <span class='hs-varop'>||</span>    <span class='hs-comment'>-- (1)</span>
<a name="line-66"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev</span> <span class='hs-varop'>`canRewrite`</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span>    <span class='hs-comment'>-- (2)</span>
<a name="line-67"></a>           <span class='hs-varid'>new_tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-68"></a>      <span class='hs-keyword'>where</span>
<a name="line-69"></a>        <span class='hs-varid'>kind_vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfType</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varop'>`unionVarSet`</span>
<a name="line-70"></a>                    <span class='hs-varid'>tyVarsOfType</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-71"></a>
<a name="line-72"></a>    <span class='hs-varid'>kick_out_eq</span> <span class='hs-varid'>other_ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"kick_out_eq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>other_ct</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Kicking out inert constraints]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Given a new (a -> ty) inert, we want to kick out an existing inert
constraint if
  a) the new constraint can rewrite the inert one
  b) 'a' is free in the inert constraint (so that it *will*)
     rewrite it if we kick it out.

For (b) we use tyVarsOfCt, which returns the type variables /and
the kind variables/ that are directly visible in the type. Hence we
will have exposed all the rewriting we care about to make the most
precise kinds visible for matching classes etc. No need to kick out
constraints that mention type variables whose kinds contain this
variable!  (Except see Note [Kicking out Irreds].)

Note [Kicking out Irreds]
~~~~~~~~~~~~~~~~~~~~~~~~~
There is an awkward special case for Irreds.  When we have a
kind-mis-matched equality constraint (a:k1) ~ (ty:k2), we turn it into
an Irred (see Note [Equalities with incompatible kinds] in
TcCanonical). So in this case the free kind variables of k1 and k2
are not visible.  More precisely, the type looks like
   (~) k1 (a:k1) (ty:k2)
because (~) has kind forall k. k -> k -> Constraint.  So the constraint
itself is ill-kinded.  We can "see" k1 but not k2.  That's why we use
closeOverKinds to make sure we see k2.

This is not pretty. Maybe (~) should have kind 
   (~) :: forall k1 k1. k1 -> k2 -> Constraint


Note [Kick out insolubles]
~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose we have an insoluble alpha ~ [alpha], which is insoluble
because an occurs check.  And then we unify alpha := [Int].
Then we really want to rewrite the insouluble to [Int] ~ [[Int]].
Now it can be decomposed.  Otherwise we end up with a "Can't match
[Int] ~ [[Int]]" which is true, but a bit confusing because the
outer type constructors match.

Note [Delicate equality kick-out]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When adding an equality (a ~ xi), we kick out an inert type-variable
equality (b ~ phi) in two cases

(1) If the new tyvar appears in the kind vars of the LHS or RHS of
    the inert.  Example:
    Work item: [G] k ~ *
    Inert:     [W] (a:k) ~ ty
               [W] (b:*) ~ c :: k
    We must kick out those blocked inerts so that we rewrite them
    and can subsequently unify.

(2) If the new tyvar appears in the RHS of the inert
    AND the inert cannot rewrite the work item
          Work item:  [G] a ~ b
          Inert:      [W] b ~ [a]
    Now at this point the work item cannot be further rewritten by the
    inert (due to the weaker inert flavor). But we can't add the work item
    as-is because the inert set would then have a cyclic substitution,
    when rewriting a wanted type mentioning 'a'. So we must kick the inert out.

    We have to do this only if the inert *cannot* rewrite the work item;
    it it can, then the work item will have been fully rewritten by the
    inert set during canonicalisation.  So for example:
         Work item: [W] a ~ Int
         Inert:     [W] b ~ [a]
    No need to kick out the inert, beause the inert substitution is not
    necessarily idemopotent.  See Note [Non-idempotent inert substitution].

See also Note [Detailed InertCans Invariants]

\begin{code}
<pre><a name="line-1"></a><a name="SPSolveResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>SPSolveResult</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SPCantSolve</span>
<a name="line-2"></a>                   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SPSolved</span> <span class='hs-conid'>TcTyVar</span>
<a name="line-3"></a>                     <span class='hs-comment'>-- We solved this /unification/ variable to some type using reflexivity</span>
<a name="line-4"></a>
<a name="line-5"></a><span class='hs-comment'>-- SPCantSolve means that we can't do the unification because e.g. the variable is untouchable</span>
<a name="line-6"></a><span class='hs-comment'>-- SPSolved workItem' gives us a new *given* to go on</span>
<a name="line-7"></a>
<a name="line-8"></a><a name="trySpontaneousSolve"></a><span class='hs-comment'>-- @trySpontaneousSolve wi@ solves equalities where one side is a</span>
<a name="line-9"></a><span class='hs-comment'>-- touchable unification variable.</span>
<a name="line-10"></a><span class='hs-definition'>trySpontaneousSolve</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Xi</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>SPSolveResult</span>
<a name="line-11"></a><span class='hs-definition'>trySpontaneousSolve</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>xi</span>
<a name="line-12"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGiven</span> <span class='hs-varid'>gw</span>   <span class='hs-comment'>-- See Note [Touchables and givens]</span>
<a name="line-13"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span>
<a name="line-14"></a>
<a name="line-15"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>xi</span>
<a name="line-16"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tch1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isTouchableMetaTyVarTcS</span> <span class='hs-varid'>tv1</span>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tch2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isTouchableMetaTyVarTcS</span> <span class='hs-varid'>tv2</span>
<a name="line-18"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>tch1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tch2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-19"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span>  <span class='hs-conid'>True</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>trySpontaneousEqTwoWay</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>tv2</span>
<a name="line-20"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span>  <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>trySpontaneousEqOneWay</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>xi</span>
<a name="line-21"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>trySpontaneousEqOneWay</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv2</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span>
<a name="line-22"></a>           <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span> <span class='hs-layout'>}</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-24"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tch1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isTouchableMetaTyVarTcS</span> <span class='hs-varid'>tv1</span>
<a name="line-25"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>tch1</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>trySpontaneousEqOneWay</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>xi</span>
<a name="line-26"></a>                 <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span> <span class='hs-layout'>}</span>
<a name="line-27"></a>
<a name="line-28"></a><a name="trySpontaneousEqOneWay"></a><span class='hs-comment'>----------------</span>
<a name="line-29"></a><span class='hs-definition'>trySpontaneousEqOneWay</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Xi</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>SPSolveResult</span>
<a name="line-30"></a><span class='hs-comment'>-- tv is a MetaTyVar, not untouchable</span>
<a name="line-31"></a><span class='hs-definition'>trySpontaneousEqOneWay</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>xi</span>
<a name="line-32"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSigTyVar</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isTyVarTy</span> <span class='hs-varid'>xi</span>
<a name="line-33"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>xi</span> <span class='hs-varop'>`tcIsSubKind`</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span>
<a name="line-34"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solveWithIdentity</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>xi</span>
<a name="line-35"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-comment'>-- Still can't solve, sig tyvar and non-variable rhs</span>
<a name="line-36"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span>
<a name="line-37"></a>
<a name="line-38"></a><a name="trySpontaneousEqTwoWay"></a><span class='hs-comment'>----------------</span>
<a name="line-39"></a><span class='hs-definition'>trySpontaneousEqTwoWay</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>SPSolveResult</span>
<a name="line-40"></a><span class='hs-comment'>-- Both tyvars are *touchable* MetaTyvars so there is only a chance for kind error here</span>
<a name="line-41"></a>
<a name="line-42"></a><span class='hs-definition'>trySpontaneousEqTwoWay</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>tv2</span>
<a name="line-43"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k1</span> <span class='hs-varop'>`tcIsSubKind`</span> <span class='hs-varid'>k2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>nicer_to_update_tv2</span>
<a name="line-44"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solveWithIdentity</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv2</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span>
<a name="line-45"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k2</span> <span class='hs-varop'>`tcIsSubKind`</span> <span class='hs-varid'>k1</span>
<a name="line-46"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solveWithIdentity</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span>
<a name="line-47"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-48"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span>
<a name="line-49"></a>  <span class='hs-keyword'>where</span>
<a name="line-50"></a>    <span class='hs-varid'>k1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv1</span>
<a name="line-51"></a>    <span class='hs-varid'>k2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv2</span>
<a name="line-52"></a>    <span class='hs-varid'>nicer_to_update_tv2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isSigTyVar</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isSystemName</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-varop'>.</span><span class='hs-varid'>varName</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Avoid double unifications]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The spontaneous solver has to return a given which mentions the unified unification
variable *on the left* of the equality. Here is what happens if not:
  Original wanted:  (a ~ alpha),  (alpha ~ Int)
We spontaneously solve the first wanted, without changing the order!
      given : a ~ alpha      [having unified alpha := a]
Now the second wanted comes along, but he cannot rewrite the given, so we simply continue.
At the end we spontaneously solve that guy, *reunifying*  [alpha := Int]

We avoid this problem by orienting the resulting given so that the unification
variable is on the left.  [Note that alternatively we could attempt to
enforce this at canonicalization]

See also Note [No touchables as FunEq RHS] in TcSMonad; avoiding
double unifications is the main reason we disallow touchable
unification variables as RHS of type family equations: F xis ~ alpha.

\begin{code}
<pre><a name="line-1"></a><a name="solveWithIdentity"></a><span class='hs-definition'>solveWithIdentity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Xi</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>SPSolveResult</span>
<a name="line-2"></a><span class='hs-comment'>-- Solve with the identity coercion</span>
<a name="line-3"></a><span class='hs-comment'>-- Precondition: kind(xi) is a sub-kind of kind(tv)</span>
<a name="line-4"></a><span class='hs-comment'>-- Precondition: CtEvidence is Wanted or Derived</span>
<a name="line-5"></a><span class='hs-comment'>-- See [New Wanted Superclass Work] to see why solveWithIdentity</span>
<a name="line-6"></a><span class='hs-comment'>--     must work for Derived as well as Wanted</span>
<a name="line-7"></a><span class='hs-comment'>-- Returns: workItem where</span>
<a name="line-8"></a><span class='hs-comment'>--        workItem = the new Given constraint</span>
<a name="line-9"></a><span class='hs-comment'>--</span>
<a name="line-10"></a><span class='hs-comment'>-- NB: No need for an occurs check here, because solveWithIdentity always</span>
<a name="line-11"></a><span class='hs-comment'>--     arises from a CTyEqCan, a *canonical* constraint.  Its invariants</span>
<a name="line-12"></a><span class='hs-comment'>--     say that in (a ~ xi), the type variable a does not appear in xi.</span>
<a name="line-13"></a><span class='hs-comment'>--     See TcRnTypes.Ct invariants.</span>
<a name="line-14"></a><span class='hs-definition'>solveWithIdentity</span> <span class='hs-varid'>wd</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>xi</span>
<a name="line-15"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tv_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Sneaky unification:"</span> <span class='hs-varop'>$</span>
<a name="line-17"></a>                       <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"Unifies:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>":="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span>
<a name="line-18"></a>                             <span class='hs-varid'>text</span> <span class='hs-str'>"Coercion:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprEq</span> <span class='hs-varid'>tv_ty</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span>
<a name="line-19"></a>                             <span class='hs-varid'>text</span> <span class='hs-str'>"Left Kind is:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-varid'>tv_ty</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-20"></a>                             <span class='hs-varid'>text</span> <span class='hs-str'>"Right Kind is:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-varid'>xi</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-21"></a>
<a name="line-22"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>xi'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultKind</span> <span class='hs-varid'>xi</span>
<a name="line-23"></a>               <span class='hs-comment'>-- We only instantiate kind unification variables</span>
<a name="line-24"></a>               <span class='hs-comment'>-- with simple kinds like *, not OpenKind or ArgKind</span>
<a name="line-25"></a>               <span class='hs-comment'>-- cf TcUnify.uUnboundKVar</span>
<a name="line-26"></a>
<a name="line-27"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>xi'</span>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>refl_evtm</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>xi'</span><span class='hs-layout'>)</span>
<a name="line-29"></a>
<a name="line-30"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>wd</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-31"></a>              <span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev_evar</span> <span class='hs-varid'>wd</span><span class='hs-layout'>)</span> <span class='hs-varid'>refl_evtm</span>
<a name="line-32"></a>
<a name="line-33"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>SPSolved</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}



Note [Superclasses and recursive dictionaries]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Overlaps with Note [SUPERCLASS-LOOP 1]
                  Note [SUPERCLASS-LOOP 2]
                  Note [Recursive instances and superclases]
    ToDo: check overlap and delete redundant stuff

Right before adding a given into the inert set, we must
produce some more work, that will bring the superclasses
of the given into scope. The superclass constraints go into
our worklist.

When we simplify a wanted constraint, if we first see a matching
instance, we may produce new wanted work. To (1) avoid doing this work
twice in the future and (2) to handle recursive dictionaries we may ``cache''
this item as given into our inert set WITHOUT adding its superclass constraints,
otherwise we'd be in danger of creating a loop [In fact this was the exact reason
for doing the isGoodRecEv check in an older version of the type checker].

But now we have added partially solved constraints to the worklist which may
interact with other wanteds. Consider the example:

Example 1:

    class Eq b => Foo a b        --- 0-th selector
    instance Eq a => Foo [a] a   --- fooDFun

and wanted (Foo [t] t). We are first going to see that the instance matches
and create an inert set that includes the solved (Foo [t] t) but not its superclasses:
       d1 :_g Foo [t] t                 d1 := EvDFunApp fooDFun d3
Our work list is going to contain a new *wanted* goal
       d3 :_w Eq t

Ok, so how do we get recursive dictionaries, at all:

Example 2:

    data D r = ZeroD | SuccD (r (D r));

    instance (Eq (r (D r))) => Eq (D r) where
        ZeroD     == ZeroD     = True
        (SuccD a) == (SuccD b) = a == b
        _         == _         = False;

    equalDC :: D [] -> D [] -> Bool;
    equalDC = (==);

We need to prove (Eq (D [])). Here's how we go:

        d1 :_w Eq (D [])

by instance decl, holds if
        d2 :_w Eq [D []]
        where   d1 = dfEqD d2

*BUT* we have an inert set which gives us (no superclasses):
        d1 :_g Eq (D [])
By the instance declaration of Eq we can show the 'd2' goal if
        d3 :_w Eq (D [])
        where   d2 = dfEqList d3
                d1 = dfEqD d2
Now, however this wanted can interact with our inert d1 to set:
        d3 := d1
and solve the goal. Why was this interaction OK? Because, if we chase the
evidence of d1 ~~> dfEqD d2 ~~-> dfEqList d3, so by setting d3 := d1 we
are really setting
        d3 := dfEqD2 (dfEqList d3)
which is FINE because the use of d3 is protected by the instance function
applications.

So, our strategy is to try to put solved wanted dictionaries into the
inert set along with their superclasses (when this is meaningful,
i.e. when new wanted goals are generated) but solve a wanted dictionary
from a given only in the case where the evidence variable of the
wanted is mentioned in the evidence of the given (recursively through
the evidence binds) in a protected way: more instance function applications
than superclass selectors.

Here are some more examples from GHC's previous type checker


Example 3:
This code arises in the context of "Scrap Your Boilerplate with Class"

    class Sat a
    class Data ctx a
    instance  Sat (ctx Char)             => Data ctx Char       -- dfunData1
    instance (Sat (ctx [a]), Data ctx a) => Data ctx [a]        -- dfunData2

    class Data Maybe a => Foo a

    instance Foo t => Sat (Maybe t)                             -- dfunSat

    instance Data Maybe a => Foo a                              -- dfunFoo1
    instance Foo a        => Foo [a]                            -- dfunFoo2
    instance                 Foo [Char]                         -- dfunFoo3

Consider generating the superclasses of the instance declaration
         instance Foo a => Foo [a]

So our problem is this
    d0 :_g Foo t
    d1 :_w Data Maybe [t]

We may add the given in the inert set, along with its superclasses
[assuming we don't fail because there is a matching instance, see
 topReactionsStage, given case ]
  Inert:
    d0 :_g Foo t
  WorkList
    d01 :_g Data Maybe t  -- d2 := EvDictSuperClass d0 0
    d1 :_w Data Maybe [t]
Then d2 can readily enter the inert, and we also do solving of the wanted
  Inert:
    d0 :_g Foo t
    d1 :_s Data Maybe [t]           d1 := dfunData2 d2 d3
  WorkList
    d2 :_w Sat (Maybe [t])
    d3 :_w Data Maybe t
    d01 :_g Data Maybe t
Now, we may simplify d2 more:
  Inert:
      d0 :_g Foo t
      d1 :_s Data Maybe [t]           d1 := dfunData2 d2 d3
      d1 :_g Data Maybe [t]
      d2 :_g Sat (Maybe [t])          d2 := dfunSat d4
  WorkList:
      d3 :_w Data Maybe t
      d4 :_w Foo [t]
      d01 :_g Data Maybe t

Now, we can just solve d3.
  Inert
      d0 :_g Foo t
      d1 :_s Data Maybe [t]           d1 := dfunData2 d2 d3
      d2 :_g Sat (Maybe [t])          d2 := dfunSat d4
  WorkList
      d4 :_w Foo [t]
      d01 :_g Data Maybe t
And now we can simplify d4 again, but since it has superclasses we *add* them to the worklist:
  Inert
      d0 :_g Foo t
      d1 :_s Data Maybe [t]           d1 := dfunData2 d2 d3
      d2 :_g Sat (Maybe [t])          d2 := dfunSat d4
      d4 :_g Foo [t]                  d4 := dfunFoo2 d5
  WorkList:
      d5 :_w Foo t
      d6 :_g Data Maybe [t]           d6 := EvDictSuperClass d4 0
      d01 :_g Data Maybe t
Now, d5 can be solved! (and its superclass enter scope)
  Inert
      d0 :_g Foo t
      d1 :_s Data Maybe [t]           d1 := dfunData2 d2 d3
      d2 :_g Sat (Maybe [t])          d2 := dfunSat d4
      d4 :_g Foo [t]                  d4 := dfunFoo2 d5
      d5 :_g Foo t                    d5 := dfunFoo1 d7
  WorkList:
      d7 :_w Data Maybe t
      d6 :_g Data Maybe [t]
      d8 :_g Data Maybe t            d8 := EvDictSuperClass d5 0
      d01 :_g Data Maybe t

Now, two problems:
   [1] Suppose we pick d8 and we react him with d01. Which of the two givens should
       we keep? Well, we *MUST NOT* drop d01 because d8 contains recursive evidence
       that must not be used (look at case interactInert where both inert and workitem
       are givens). So we have several options:
       - Drop the workitem always (this will drop d8)
              This feels very unsafe -- what if the work item was the "good" one
              that should be used later to solve another wanted?
       - Don't drop anyone: the inert set may contain multiple givens!
              [This is currently implemented]

The "don't drop anyone" seems the most safe thing to do, so now we come to problem 2:
  [2] We have added both d6 and d01 in the inert set, and we are interacting our wanted
      d7. Now the [isRecDictEv] function in the ineration solver
      [case inert-given workitem-wanted] will prevent us from interacting d7 := d8
      precisely because chasing the evidence of d8 leads us to an unguarded use of d7.

      So, no interaction happens there. Then we meet d01 and there is no recursion
      problem there [isRectDictEv] gives us the OK to interact and we do solve d7 := d01!

Note [SUPERCLASS-LOOP 1]
~~~~~~~~~~~~~~~~~~~~~~~~
We have to be very, very careful when generating superclasses, lest we
accidentally build a loop. Here's an example:

  class S a

  class S a => C a where { opc :: a -> a }
  class S b => D b where { opd :: b -> b }

  instance C Int where
     opc = opd

  instance D Int where
     opd = opc

From (instance C Int) we get the constraint set {ds1:S Int, dd:D Int}
Simplifying, we may well get:
        $dfCInt = :C ds1 (opd dd)
        dd  = $dfDInt
        ds1 = $p1 dd
Notice that we spot that we can extract ds1 from dd.

Alas!  Alack! We can do the same for (instance D Int):

        $dfDInt = :D ds2 (opc dc)
        dc  = $dfCInt
        ds2 = $p1 dc

And now we've defined the superclass in terms of itself.
Two more nasty cases are in
        tcrun021
        tcrun033

Solution:
  - Satisfy the superclass context *all by itself*
    (tcSimplifySuperClasses)
  - And do so completely; i.e. no left-over constraints
    to mix with the constraints arising from method declarations


Note [SUPERCLASS-LOOP 2]
~~~~~~~~~~~~~~~~~~~~~~~~
We need to be careful when adding "the constaint we are trying to prove".
Suppose we are *given* d1:Ord a, and want to deduce (d2:C [a]) where

        class Ord a => C a where
        instance Ord [a] => C [a] where ...

Then we'll use the instance decl to deduce C [a] from Ord [a], and then add the
superclasses of C [a] to avails.  But we must not overwrite the binding
for Ord [a] (which is obtained from Ord a) with a superclass selection or we'll just
build a loop!

Here's another variant, immortalised in tcrun020
        class Monad m => C1 m
        class C1 m => C2 m x
        instance C2 Maybe Bool
For the instance decl we need to build (C1 Maybe), and it's no good if
we run around and add (C2 Maybe Bool) and its superclasses to the avails
before we search for C1 Maybe.

Here's another example
        class Eq b => Foo a b
        instance Eq a => Foo [a] a
If we are reducing
        (Foo [t] t)

we'll first deduce that it holds (via the instance decl).  We must not
then overwrite the Eq t constraint with a superclass selection!

At first I had a gross hack, whereby I simply did not add superclass constraints
in addWanted, though I did for addGiven and addIrred.  This was sub-optimal,
because it lost legitimate superclass sharing, and it still didn't do the job:
I found a very obscure program (now tcrun021) in which improvement meant the
simplifier got two bites a the cherry... so something seemed to be an Stop
first time, but reducible next time.

Now we implement the Right Solution, which is to check for loops directly
when adding superclasses.  It's a bit like the occurs check in unification.

Note [Recursive instances and superclases]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider this code, which arises in the context of "Scrap Your
Boilerplate with Class".

    class Sat a
    class Data ctx a
    instance  Sat (ctx Char)             => Data ctx Char
    instance (Sat (ctx [a]), Data ctx a) => Data ctx [a]

    class Data Maybe a => Foo a

    instance Foo t => Sat (Maybe t)

    instance Data Maybe a => Foo a
    instance Foo a        => Foo [a]
    instance                 Foo [Char]

In the instance for Foo [a], when generating evidence for the superclasses
(ie in tcSimplifySuperClasses) we need a superclass (Data Maybe [a]).
Using the instance for Data, we therefore need
        (Sat (Maybe [a], Data Maybe a)
But we are given (Foo a), and hence its superclass (Data Maybe a).
So that leaves (Sat (Maybe [a])).  Using the instance for Sat means
we need (Foo [a]).  And that is the very dictionary we are bulding
an instance for!  So we must put that in the "givens".  So in this
case we have
        Given:  Foo a, Foo [a]
        Wanted: Data Maybe [a]

BUT we must *not not not* put the *superclasses* of (Foo [a]) in
the givens, which is what 'addGiven' would normally do. Why? Because
(Data Maybe [a]) is the superclass, so we'd "satisfy" the wanted
by selecting a superclass from Foo [a], which simply makes a loop.

On the other hand we *must* put the superclasses of (Foo a) in
the givens, as you can see from the derivation described above.

Conclusion: in the very special case of tcSimplifySuperClasses
we have one 'given' (namely the "this" dictionary) whose superclasses
must not be added to 'givens' by addGiven.

There is a complication though.  Suppose there are equalities
      instance (Eq a, a~b) => Num (a,b)
Then we normalise the 'givens' wrt the equalities, so the original
given "this" dictionary is cast to one of a different type.  So it's a
bit trickier than before to identify the "special" dictionary whose
superclasses must not be added. See test
   indexed-types/should_run/EqInInstance

We need a persistent property of the dictionary to record this
special-ness.  Current I'm using the InstLocOrigin (a bit of a hack,
but cool), which is maintained by dictionary normalisation.
Specifically, the InstLocOrigin is
             NoScOrigin
then the no-superclass thing kicks in.  WATCH OUT if you fiddle
with InstLocOrigin!


%************************************************************************
%*                                                                      *
%*          Functional dependencies, instantiation of equations
%*                                                                      *
%************************************************************************

When we spot an equality arising from a functional dependency,
we now use that equality (a "wanted") to rewrite the work-item
constraint right away.  This avoids two dangers

 Danger 1: If we send the original constraint on down the pipeline
           it may react with an instance declaration, and in delicate
           situations (when a Given overlaps with an instance) that
           may produce new insoluble goals: see Trac #4952

 Danger 2: If we don't rewrite the constraint, it may re-react
           with the same thing later, and produce the same equality
           again --> termination worries.

To achieve this required some refactoring of FunDeps.lhs (nicer
now!).

\begin{code}
<pre><a name="line-1"></a><a name="rewriteWithFunDeps"></a><span class='hs-definition'>rewriteWithFunDeps</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Equation</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>
<a name="line-2"></a><span class='hs-comment'>-- NB: The returned constraints are all Derived</span>
<a name="line-3"></a><span class='hs-comment'>-- Post: returns no trivial equalities (identities) and all EvVars returned are fresh</span>
<a name="line-4"></a><span class='hs-definition'>rewriteWithFunDeps</span> <span class='hs-varid'>eqn_pred_locs</span> <span class='hs-varid'>loc</span>
<a name="line-5"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fd_cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>instFunDepEqn</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span> <span class='hs-varid'>eqn_pred_locs</span>
<a name="line-6"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span> <span class='hs-varid'>fd_cts</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-7"></a>
<a name="line-8"></a><a name="instFunDepEqn"></a><span class='hs-definition'>instFunDepEqn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Equation</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>
<a name="line-9"></a><span class='hs-comment'>-- Post: Returns the position index as well as the corresponding FunDep equality</span>
<a name="line-10"></a><span class='hs-definition'>instFunDepEqn</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-conid'>FDEqn</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fd_qtvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>fd_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-11"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instFlexiTcS</span> <span class='hs-varid'>tvs</span>  <span class='hs-comment'>-- Takes account of kind substitution</span>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>foldM</span> <span class='hs-layout'>(</span><span class='hs-varid'>do_one</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>eqs</span> <span class='hs-layout'>}</span>
<a name="line-13"></a>  <span class='hs-keyword'>where</span>
<a name="line-14"></a>    <span class='hs-varid'>do_one</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>ievs</span> <span class='hs-layout'>(</span><span class='hs-conid'>FDEq</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fd_ty_left</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>fd_ty_right</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-15"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tcEqType</span> <span class='hs-varid'>sty1</span> <span class='hs-varid'>sty2</span>
<a name="line-16"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>ievs</span> <span class='hs-comment'>-- Return no trivial equalities</span>
<a name="line-17"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-18"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_eqv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newDerived</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcEqPred</span> <span class='hs-varid'>sty1</span> <span class='hs-varid'>sty2</span><span class='hs-layout'>)</span>
<a name="line-19"></a>            <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_eqv</span> <span class='hs-keyword'>of</span>
<a name="line-20"></a>                 <span class='hs-conid'>Just</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev</span> <span class='hs-layout'>{</span><span class='hs-varid'>ctev_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ievs</span><span class='hs-layout'>)</span>
<a name="line-21"></a>                 <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>ievs</span> <span class='hs-layout'>}</span>
<a name="line-22"></a>                   <span class='hs-comment'>-- We are eventually going to emit FD work back in the work list so</span>
<a name="line-23"></a>                   <span class='hs-comment'>-- it is important that we only return the /freshly created/ and not</span>
<a name="line-24"></a>                   <span class='hs-comment'>-- some existing equality!</span>
<a name="line-25"></a>       <span class='hs-keyword'>where</span>
<a name="line-26"></a>         <span class='hs-varid'>sty1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span><span class='hs-varop'>.</span><span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>ty1</span>
<a name="line-27"></a>         <span class='hs-varid'>sty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span><span class='hs-varop'>.</span><span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>ty2</span>
</pre>\end{code}




*********************************************************************************
*                                                                               *
                       The top-reaction Stage
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="topReactionsStage"></a><span class='hs-definition'>topReactionsStage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-2"></a><span class='hs-definition'>topReactionsStage</span> <span class='hs-varid'>wi</span>
<a name="line-3"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inerts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-4"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>tir</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>doTopReact</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>wi</span>
<a name="line-5"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tir</span> <span class='hs-keyword'>of</span>
<a name="line-6"></a>          <span class='hs-conid'>NoTopInt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span>
<a name="line-7"></a>          <span class='hs-conid'>SomeTopInt</span> <span class='hs-varid'>rule</span> <span class='hs-varid'>what_next</span>
<a name="line-8"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-varid'>wi</span> <span class='hs-varop'>$</span>
<a name="line-9"></a>                           <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Top react:"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-varid'>rule</span>
<a name="line-10"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>what_next</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-11"></a>
<a name="line-12"></a><a name="TopInteractResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TopInteractResult</span>
<a name="line-13"></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoTopInt</span>
<a name="line-14"></a> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span><span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StopOrContinue</span> <span class='hs-layout'>}</span>
<a name="line-15"></a>
<a name="line-16"></a>
<a name="line-17"></a><a name="doTopReact"></a><span class='hs-definition'>doTopReact</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>TopInteractResult</span>
<a name="line-18"></a><span class='hs-comment'>-- The work item does not react with the inert set, so try interaction with top-level</span>
<a name="line-19"></a><span class='hs-comment'>-- instances. Note:</span>
<a name="line-20"></a><span class='hs-comment'>--</span>
<a name="line-21"></a><span class='hs-comment'>--   (a) The place to add superclasses in not here in doTopReact stage.</span>
<a name="line-22"></a><span class='hs-comment'>--       Instead superclasses are added in the worklist as part of the</span>
<a name="line-23"></a><span class='hs-comment'>--       canonicalization process. See Note [Adding superclasses].</span>
<a name="line-24"></a><span class='hs-comment'>--</span>
<a name="line-25"></a><span class='hs-comment'>--   (b) See Note [Given constraint that matches an instance declaration]</span>
<a name="line-26"></a><span class='hs-comment'>--       for some design decisions for given dictionaries.</span>
<a name="line-27"></a>
<a name="line-28"></a><span class='hs-definition'>doTopReact</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>workItem</span>
<a name="line-29"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"doTopReact"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span>
<a name="line-30"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>workItem</span> <span class='hs-keyword'>of</span>
<a name="line-31"></a>           <span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span> <span class='hs-layout'>}</span>
<a name="line-32"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>doTopReactDict</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span>
<a name="line-33"></a>
<a name="line-34"></a>           <span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span> <span class='hs-layout'>}</span>
<a name="line-35"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>doTopReactFunEq</span> <span class='hs-varid'>workItem</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>args</span> <span class='hs-varid'>xi</span>
<a name="line-36"></a>
<a name="line-37"></a>           <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Any other work item does not react with any top-level equations</span>
<a name="line-38"></a>                 <span class='hs-varid'>return</span> <span class='hs-conid'>NoTopInt</span>  <span class='hs-layout'>}</span>
<a name="line-39"></a>
<a name="line-40"></a><a name="doTopReactDict"></a><span class='hs-comment'>--------------------</span>
<a name="line-41"></a><span class='hs-definition'>doTopReactDict</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>TopInteractResult</span>
<a name="line-42"></a><span class='hs-comment'>-- Try to use type-class instance declarations to simplify the constraint</span>
<a name="line-43"></a><span class='hs-definition'>doTopReactDict</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span>
<a name="line-44"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>fl</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- Never use instances for Given or Derived constraints</span>
<a name="line-45"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>try_fundeps_and_return</span>
<a name="line-46"></a>
<a name="line-47"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupSolvedDict</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span>   <span class='hs-comment'>-- Cached</span>
<a name="line-48"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>ctEvCheckDepth</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctLocDepth</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev_loc</span> <span class='hs-varid'>fl</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>ev</span>
<a name="line-49"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setEvBind</span> <span class='hs-varid'>dict_id</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span><span class='hs-layout'>;</span>
<a name="line-50"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Dict/Top (cached)"</span>
<a name="line-51"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-52"></a>
<a name="line-53"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- Not cached</span>
<a name="line-54"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>lkup_inst_res</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchClassInst</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span> <span class='hs-varid'>loc</span>
<a name="line-55"></a>         <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lkup_inst_res</span> <span class='hs-keyword'>of</span>
<a name="line-56"></a>               <span class='hs-conid'>GenInst</span> <span class='hs-varid'>wtvs</span> <span class='hs-varid'>ev_term</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>addSolvedDict</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span>
<a name="line-57"></a>                                          <span class='hs-layout'>;</span> <span class='hs-varid'>solve_from_instance</span> <span class='hs-varid'>wtvs</span> <span class='hs-varid'>ev_term</span> <span class='hs-layout'>}</span>
<a name="line-58"></a>               <span class='hs-conid'>NoInstance</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>try_fundeps_and_return</span> <span class='hs-layout'>}</span>
<a name="line-59"></a>   <span class='hs-keyword'>where</span>
<a name="line-60"></a>     <span class='hs-varid'>dict_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvId</span> <span class='hs-varid'>fl</span>
<a name="line-61"></a>     <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span>
<a name="line-62"></a>     <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-varid'>fl</span>
<a name="line-63"></a>
<a name="line-64"></a>     <span class='hs-varid'>solve_from_instance</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CtEvidence</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EvTerm</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>TopInteractResult</span>
<a name="line-65"></a>      <span class='hs-comment'>-- Precondition: evidence term matches the predicate workItem</span>
<a name="line-66"></a>     <span class='hs-varid'>solve_from_instance</span> <span class='hs-varid'>evs</span> <span class='hs-varid'>ev_term</span>
<a name="line-67"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>evs</span>
<a name="line-68"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"doTopReact/found nullary instance for"</span> <span class='hs-varop'>$</span>
<a name="line-69"></a>               <span class='hs-varid'>ppr</span> <span class='hs-varid'>dict_id</span>
<a name="line-70"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>setEvBind</span> <span class='hs-varid'>dict_id</span> <span class='hs-varid'>ev_term</span>
<a name="line-71"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span>
<a name="line-72"></a>               <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Dict/Top (solved, no new work)"</span>
<a name="line-73"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-74"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-75"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"doTopReact/found non-nullary instance for"</span> <span class='hs-varop'>$</span>
<a name="line-76"></a>               <span class='hs-varid'>ppr</span> <span class='hs-varid'>dict_id</span>
<a name="line-77"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>setEvBind</span> <span class='hs-varid'>dict_id</span> <span class='hs-varid'>ev_term</span>
<a name="line-78"></a>             <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>mk_new_wanted</span> <span class='hs-varid'>ev</span>
<a name="line-79"></a>                       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNonCanonical</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev</span> <span class='hs-layout'>{</span><span class='hs-varid'>ctev_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bumpCtLocDepth</span> <span class='hs-conid'>CountConstraints</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-80"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListCts</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mk_new_wanted</span> <span class='hs-varid'>evs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-81"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span>
<a name="line-82"></a>               <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span>     <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Dict/Top (solved, more work)"</span>
<a name="line-83"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-84"></a>
<a name="line-85"></a>     <span class='hs-comment'>-- We didn't solve it; so try functional dependencies with</span>
<a name="line-86"></a>     <span class='hs-comment'>-- the instance environment, and return</span>
<a name="line-87"></a>     <span class='hs-comment'>-- NB: even if there *are* some functional dependencies against the</span>
<a name="line-88"></a>     <span class='hs-comment'>-- instance environment, there might be a unique match, and if</span>
<a name="line-89"></a>     <span class='hs-comment'>-- so we make sure we get on and solve it first. See Note [Weird fundeps]</span>
<a name="line-90"></a>     <span class='hs-varid'>try_fundeps_and_return</span>
<a name="line-91"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>instEnvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getInstEnvs</span>
<a name="line-92"></a>            <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fd_eqns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>improveFromInstEnv</span> <span class='hs-varid'>instEnvs</span> <span class='hs-varid'>pred</span>
<a name="line-93"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>fd_work</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteWithFunDeps</span> <span class='hs-varid'>fd_eqns</span> <span class='hs-varid'>loc</span>
<a name="line-94"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>fd_work</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEqs</span> <span class='hs-varid'>fd_work</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-95"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoTopInt</span> <span class='hs-layout'>}</span>
<a name="line-96"></a>
<a name="line-97"></a><a name="doTopReactFunEq"></a><span class='hs-comment'>--------------------</span>
<a name="line-98"></a><span class='hs-definition'>doTopReactFunEq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Xi</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>TopInteractResult</span>
<a name="line-99"></a><span class='hs-definition'>doTopReactFunEq</span> <span class='hs-sel'>_ct</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>fun_tc</span> <span class='hs-varid'>args</span> <span class='hs-varid'>xi</span>
<a name="line-100"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span><span class='hs-varid'>isSynFamilyTyCon</span> <span class='hs-varid'>fun_tc</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- No associated data families have</span>
<a name="line-101"></a>                                     <span class='hs-comment'>-- reached this far</span>
<a name="line-102"></a>    <span class='hs-comment'>-- Look in the cache of solved funeqs</span>
<a name="line-103"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fun_eq_cache</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-varop'>.</span> <span class='hs-varid'>inert_solved_funeqs</span><span class='hs-layout'>)</span>
<a name="line-104"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>findFunEq</span> <span class='hs-varid'>fun_eq_cache</span> <span class='hs-varid'>fun_tc</span> <span class='hs-varid'>args</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span>
<a name="line-105"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>)</span>
<a name="line-106"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ctev</span> <span class='hs-varop'>`canRewriteOrSame`</span> <span class='hs-varid'>fl</span>  <span class='hs-comment'>-- See Note [Cached solved FunEqs]</span>
<a name="line-107"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDerived</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-108"></a>                <span class='hs-varid'>succeed_with</span> <span class='hs-str'>"Fun/Cache"</span> <span class='hs-layout'>(</span><span class='hs-varid'>evTermCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-layout'>;</span>
<a name="line-109"></a>           <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-110"></a>
<a name="line-111"></a>    <span class='hs-comment'>-- Look up in top-level instances, or built-in axiom</span>
<a name="line-112"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>match_res</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchFam</span> <span class='hs-varid'>fun_tc</span> <span class='hs-varid'>args</span>   <span class='hs-comment'>-- See Note [MATCHING-SYNONYMS]</span>
<a name="line-113"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>match_res</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span>
<a name="line-114"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>try_improvement</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoTopInt</span> <span class='hs-layout'>}</span> <span class='hs-layout'>;</span>
<a name="line-115"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-116"></a>
<a name="line-117"></a>    <span class='hs-comment'>-- Found a top-level instance</span>
<a name="line-118"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>    <span class='hs-comment'>-- Add it to the solved goals</span>
<a name="line-119"></a>         <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDerived</span> <span class='hs-varid'>fl</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>addSolvedFunEq</span> <span class='hs-varid'>fun_tc</span> <span class='hs-varid'>args</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>xi</span><span class='hs-layout'>)</span>
<a name="line-120"></a>
<a name="line-121"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>succeed_with</span> <span class='hs-str'>"Fun/Top"</span> <span class='hs-varid'>co</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-122"></a>  <span class='hs-keyword'>where</span>
<a name="line-123"></a>    <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-varid'>fl</span>
<a name="line-124"></a>
<a name="line-125"></a>    <span class='hs-varid'>try_improvement</span>
<a name="line-126"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ops</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isBuiltInSynFamTyCon_maybe</span> <span class='hs-varid'>fun_tc</span>
<a name="line-127"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>eqns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sfInteractTop</span> <span class='hs-varid'>ops</span> <span class='hs-varid'>args</span> <span class='hs-varid'>xi</span>
<a name="line-128"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>impsMb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>newDerived</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcEqPred</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>eqns</span>
<a name="line-129"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>work</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>mkNonCanonical</span> <span class='hs-layout'>(</span><span class='hs-varid'>catMaybes</span> <span class='hs-varid'>impsMb</span><span class='hs-layout'>)</span>
<a name="line-130"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>work</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEqs</span> <span class='hs-varid'>work</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-131"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-132"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-133"></a>
<a name="line-134"></a>    <span class='hs-varid'>succeed_with</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcCoercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>TopInteractResult</span>
<a name="line-135"></a>    <span class='hs-varid'>succeed_with</span> <span class='hs-varid'>str</span> <span class='hs-varid'>co</span> <span class='hs-varid'>rhs_ty</span>    <span class='hs-comment'>-- co :: fun_tc args ~ rhs_ty</span>
<a name="line-136"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctevs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xCtEvidence</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>xev</span>
<a name="line-137"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-layout'>(</span><span class='hs-str'>"doTopReactFunEq "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>str</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ctevs</span><span class='hs-layout'>)</span>
<a name="line-138"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctevs</span> <span class='hs-keyword'>of</span>
<a name="line-139"></a>               <span class='hs-keyglyph'>[</span><span class='hs-varid'>ctev</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>extendWorkListEq</span> <span class='hs-varop'>$</span>
<a name="line-140"></a>                         <span class='hs-varid'>mkNonCanonical</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bumpCtLocDepth</span> <span class='hs-conid'>CountTyFunApps</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-141"></a>               <span class='hs-varid'>ctevs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- No subgoal (because it's cached)</span>
<a name="line-142"></a>                        <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>ctevs</span><span class='hs-layout'>)</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-143"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>str</span>
<a name="line-144"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-145"></a>      <span class='hs-keyword'>where</span>
<a name="line-146"></a>        <span class='hs-varid'>xdecomp</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>co</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>evTermCoercion</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-147"></a>        <span class='hs-varid'>xcomp</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>evTermCoercion</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-148"></a>        <span class='hs-varid'>xcomp</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"No more goals!"</span>
<a name="line-149"></a>        <span class='hs-varid'>xev</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XEvTerm</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>mkTcEqPred</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>xi</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xcomp</span> <span class='hs-varid'>xdecomp</span>
</pre>\end{code}

Note [Cached solved FunEqs]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
When trying to solve, say (FunExpensive big-type ~ ty), it's important
to see if we have reduced (FunExpensive big-type) before, lest we
simply repeat it.  Hence the lookup in inert_solved_funeqs.  Moreover
we must use `canRewriteOrSame` because both uses might (say) be Wanteds,
and we *still* want to save the re-computation.

Note [MATCHING-SYNONYMS]
~~~~~~~~~~~~~~~~~~~~~~~~
When trying to match a dictionary (D tau) to a top-level instance, or a
type family equation (F taus_1 ~ tau_2) to a top-level family instance,
we do *not* need to expand type synonyms because the matcher will do that for us.


Note [RHS-FAMILY-SYNONYMS]
~~~~~~~~~~~~~~~~~~~~~~~~~~
The RHS of a family instance is represented as yet another constructor which is
like a type synonym for the real RHS the programmer declared. Eg:
    type instance F (a,a) = [a]
Becomes:
    :R32 a = [a]      -- internal type synonym introduced
    F (a,a) ~ :R32 a  -- instance

When we react a family instance with a type family equation in the work list
we keep the synonym-using RHS without expansion.

Note [FunDep and implicit parameter reactions]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Currently, our story of interacting two dictionaries (or a dictionary
and top-level instances) for functional dependencies, and implicit
paramters, is that we simply produce new Derived equalities.  So for example

        class D a b | a -> b where ...
    Inert:
        d1 :g D Int Bool
    WorkItem:
        d2 :w D Int alpha

    We generate the extra work item
        cv :d alpha ~ Bool
    where 'cv' is currently unused.  However, this new item can perhaps be
    spontaneously solved to become given and react with d2,
    discharging it in favour of a new constraint d2' thus:
        d2' :w D Int Bool
        d2 := d2' |> D Int cv
    Now d2' can be discharged from d1

We could be more aggressive and try to *immediately* solve the dictionary
using those extra equalities, but that requires those equalities to carry
evidence and derived do not carry evidence.

If that were the case with the same inert set and work item we might dischard
d2 directly:

        cv :w alpha ~ Bool
        d2 := d1 |> D Int cv

But in general it's a bit painful to figure out the necessary coercion,
so we just take the first approach. Here is a better example. Consider:
    class C a b c | a -> b
And:
     [Given]  d1 : C T Int Char
     [Wanted] d2 : C T beta Int
In this case, it's *not even possible* to solve the wanted immediately.
So we should simply output the functional dependency and add this guy
[but NOT its superclasses] back in the worklist. Even worse:
     [Given] d1 : C T Int beta
     [Wanted] d2: C T beta Int
Then it is solvable, but its very hard to detect this on the spot.

It's exactly the same with implicit parameters, except that the
"aggressive" approach would be much easier to implement.

Note [When improvement happens]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We fire an improvement rule when

  * Two constraints match (modulo the fundep)
      e.g. C t1 t2, C t1 t3    where C a b | a->b
    The two match because the first arg is identical

Note that we *do* fire the improvement if one is Given and one is Derived (e.g. a
superclass of a Wanted goal) or if both are Given.

Example (tcfail138)
    class L a b | a -> b
    class (G a, L a b) => C a b

    instance C a b' => G (Maybe a)
    instance C a b  => C (Maybe a) a
    instance L (Maybe a) a

When solving the superclasses of the (C (Maybe a) a) instance, we get
  Given:  C a b  ... and hance by superclasses, (G a, L a b)
  Wanted: G (Maybe a)
Use the instance decl to get
  Wanted: C a b'
The (C a b') is inert, so we generate its Derived superclasses (L a b'),
and now we need improvement between that derived superclass an the Given (L a b)

Test typecheck/should_fail/FDsFromGivens also shows why it's a good idea to
emit Derived FDs for givens as well.

Note [Weird fundeps]
~~~~~~~~~~~~~~~~~~~~
Consider   class Het a b | a -> b where
              het :: m (f c) -> a -> m b

           class GHet (a :: * -> *) (b :: * -> *) | a -> b
           instance            GHet (K a) (K [a])
           instance Het a b => GHet (K a) (K b)

The two instances don't actually conflict on their fundeps,
although it's pretty strange.  So they are both accepted. Now
try   [W] GHet (K Int) (K Bool)
This triggers fudeps from both instance decls; but it also
matches a *unique* instance decl, and we should go ahead and
pick that one right now.  Otherwise, if we don't, it ends up
unsolved in the inert set and is reported as an error.

Trac #7875 is a case in point.

Note [Overriding implicit parameters]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider
   f :: (?x::a) -> Bool -> a

   g v = let ?x::Int = 3
         in (f v, let ?x::Bool = True in f v)

This should probably be well typed, with
   g :: Bool -> (Int, Bool)

So the inner binding for ?x::Bool *overrides* the outer one.
Hence a work-item Given overrides an inert-item Given.

Note [Given constraint that matches an instance declaration]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
What should we do when we discover that one (or more) top-level
instances match a given (or solved) class constraint? We have
two possibilities:

  1. Reject the program. The reason is that there may not be a unique
     best strategy for the solver. Example, from the OutsideIn(X) paper:
       instance P x => Q [x]
       instance (x ~ y) => R [x] y

       wob :: forall a b. (Q [b], R b a) => a -> Int

       g :: forall a. Q [a] => [a] -> Int
       g x = wob x

       will generate the impliation constraint:
            Q [a] => (Q [beta], R beta [a])
       If we react (Q [beta]) with its top-level axiom, we end up with a
       (P beta), which we have no way of discharging. On the other hand,
       if we react R beta [a] with the top-level we get  (beta ~ a), which
       is solvable and can help us rewrite (Q [beta]) to (Q [a]) which is
       now solvable by the given Q [a].

     However, this option is restrictive, for instance [Example 3] from
     Note [Recursive instances and superclases] will fail to work.

  2. Ignore the problem, hoping that the situations where there exist indeed
     such multiple strategies are rare: Indeed the cause of the previous
     problem is that (R [x] y) yields the new work (x ~ y) which can be
     *spontaneously* solved, not using the givens.

We are choosing option 2 below but we might consider having a flag as well.


Note [New Wanted Superclass Work]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Even in the case of wanted constraints, we may add some superclasses
as new given work. The reason is:

        To allow FD-like improvement for type families. Assume that
        we have a class
             class C a b | a -> b
        and we have to solve the implication constraint:
             C a b => C a beta
        Then, FD improvement can help us to produce a new wanted (beta ~ b)

        We want to have the same effect with the type family encoding of
        functional dependencies. Namely, consider:
             class (F a ~ b) => C a b
        Now suppose that we have:
               given: C a b
               wanted: C a beta
        By interacting the given we will get given (F a ~ b) which is not
        enough by itself to make us discharge (C a beta). However, we
        may create a new derived equality from the super-class of the
        wanted constraint (C a beta), namely derived (F a ~ beta).
        Now we may interact this with given (F a ~ b) to get:
                  derived :  beta ~ b
        But 'beta' is a touchable unification variable, and hence OK to
        unify it with 'b', replacing the derived evidence with the identity.

        This requires trySpontaneousSolve to solve *derived*
        equalities that have a touchable in their RHS, *in addition*
        to solving wanted equalities.

We also need to somehow use the superclasses to quantify over a minimal,
constraint see note [Minimize by Superclasses] in TcSimplify.


Finally, here is another example where this is useful.

Example 1:
----------
   class (F a ~ b) => C a b
And we are given the wanteds:
      w1 : C a b
      w2 : C a c
      w3 : b ~ c
We surely do *not* want to quantify over (b ~ c), since if someone provides
dictionaries for (C a b) and (C a c), these dictionaries can provide a proof
of (b ~ c), hence no extra evidence is necessary. Here is what will happen:

     Step 1: We will get new *given* superclass work,
             provisionally to our solving of w1 and w2

               g1: F a ~ b, g2 : F a ~ c,
               w1 : C a b, w2 : C a c, w3 : b ~ c

             The evidence for g1 and g2 is a superclass evidence term:

               g1 := sc w1, g2 := sc w2

     Step 2: The givens will solve the wanted w3, so that
               w3 := sym (sc w1) ; sc w2

     Step 3: Now, one may naively assume that then w2 can be solve from w1
             after rewriting with the (now solved equality) (b ~ c).

             But this rewriting is ruled out by the isGoodRectDict!

Conclusion, we will (correctly) end up with the unsolved goals
    (C a b, C a c)

NB: The desugarer needs be more clever to deal with equalities
    that participate in recursive dictionary bindings.

\begin{code}
<pre><a name="line-1"></a><a name="LookupInstResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>LookupInstResult</span>
<a name="line-2"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoInstance</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GenInst</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CtEvidence</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>EvTerm</span>
<a name="line-4"></a>
<a name="line-5"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>LookupInstResult</span> <span class='hs-keyword'>where</span>
<a name="line-6"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>NoInstance</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"NoInstance"</span>
<a name="line-7"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenInst</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"GenInst"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>t</span>
<a name="line-8"></a>
<a name="line-9"></a>
<a name="line-10"></a><a name="matchClassInst"></a><span class='hs-definition'>matchClassInst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>LookupInstResult</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-definition'>matchClassInst</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>clas</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>]</span> <span class='hs-keyword'>_</span>
<a name="line-13"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>className</span> <span class='hs-varid'>clas</span> <span class='hs-varop'>==</span> <span class='hs-varid'>knownNatClassName</span>
<a name="line-14"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isNumLitTy</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>makeDict</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvNum</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-15"></a>
<a name="line-16"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>className</span> <span class='hs-varid'>clas</span> <span class='hs-varop'>==</span> <span class='hs-varid'>knownSymbolClassName</span>
<a name="line-17"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isStrLitTy</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>makeDict</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvStr</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-18"></a>
<a name="line-19"></a>  <span class='hs-keyword'>where</span>
<a name="line-20"></a>  <span class='hs-comment'>{- This adds a coercion that will convert the literal into a dictionary
<a name="line-21"></a>     of the appropriate type.  See Note [KnownNat &amp; KnownSymbol and EvLit]
<a name="line-22"></a>     in TcEvidence.  The coercion happens in 2 steps:
<a name="line-23"></a>
<a name="line-24"></a>     Integer -&gt; SNat n     -- representation of literal to singleton
<a name="line-25"></a>     SNat n  -&gt; KnownNat n -- singleton to dictionary
<a name="line-26"></a>
<a name="line-27"></a>     The process is mirrored for Symbols:
<a name="line-28"></a>     String    -&gt; SSymbol n
<a name="line-29"></a>     SSymbol n -&gt; KnownSymbol n
<a name="line-30"></a>  -}</span>
<a name="line-31"></a>  <span class='hs-varid'>makeDict</span> <span class='hs-varid'>evLit</span> <span class='hs-keyglyph'>=</span>
<a name="line-32"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>unwrapNewTyCon_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-33"></a>      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>axDict</span><span class='hs-layout'>)</span>
<a name="line-34"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>meth</span> <span class='hs-keyglyph'>]</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>classMethods</span> <span class='hs-varid'>clas</span>
<a name="line-35"></a>        <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tcRep</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConAppTyCon_maybe</span> <span class='hs-comment'>-- SNat</span>
<a name="line-36"></a>                      <span class='hs-varop'>$</span> <span class='hs-varid'>funResultTy</span>         <span class='hs-comment'>-- SNat n</span>
<a name="line-37"></a>                      <span class='hs-varop'>$</span> <span class='hs-varid'>dropForAlls</span>         <span class='hs-comment'>-- KnownNat n =&gt; SNat n</span>
<a name="line-38"></a>                      <span class='hs-varop'>$</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>meth</span>         <span class='hs-comment'>-- forall n. KnownNat n =&gt; SNat n</span>
<a name="line-39"></a>        <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>axRep</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unwrapNewTyCon_maybe</span> <span class='hs-varid'>tcRep</span>
<a name="line-40"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span>
<a name="line-41"></a>           <span class='hs-keyword'>let</span> <span class='hs-varid'>co1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkTcUnbranchedAxInstCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>axRep</span>  <span class='hs-keyglyph'>[</span><span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span>
<a name="line-42"></a>               <span class='hs-varid'>co2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkTcUnbranchedAxInstCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>axDict</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span>
<a name="line-43"></a>           <span class='hs-keyword'>in</span> <span class='hs-conid'>GenInst</span> <span class='hs-conid'>[]</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkEvCast</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvLit</span> <span class='hs-varid'>evLit</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcTransCo</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span>
<a name="line-44"></a>
<a name="line-45"></a>      <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>panicTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Unexpected evidence for"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>className</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span>
<a name="line-46"></a>                     <span class='hs-varop'>$$</span> <span class='hs-varid'>vcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>idType</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>classMethods</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-47"></a>
<a name="line-48"></a><span class='hs-definition'>matchClassInst</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>clas</span> <span class='hs-keyglyph'>[</span> <span class='hs-sel'>_k</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>]</span> <span class='hs-varid'>loc</span>
<a name="line-49"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>clas</span> <span class='hs-varop'>==</span> <span class='hs-varid'>coercibleClass</span> <span class='hs-keyglyph'>=</span>  <span class='hs-keyword'>do</span>
<a name="line-50"></a>      <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"matchClassInst for"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>clas</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"at depth"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctLocDepth</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span>
<a name="line-51"></a>      <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getCoercibleInst</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-52"></a>      <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"matchClassInst returned"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span>
<a name="line-53"></a>      <span class='hs-varid'>return</span> <span class='hs-varid'>ev</span>
<a name="line-54"></a>
<a name="line-55"></a><span class='hs-definition'>matchClassInst</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>loc</span>
<a name="line-56"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-57"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUntouchables</span>
<a name="line-58"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"matchClassInst"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"pred ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span>
<a name="line-59"></a>                                           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"inerts="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inerts</span>
<a name="line-60"></a>                                           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"untouchables="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>]</span>
<a name="line-61"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>instEnvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getInstEnvs</span>
<a name="line-62"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupInstEnv</span> <span class='hs-varid'>instEnvs</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span> <span class='hs-keyword'>of</span>
<a name="line-63"></a>            <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>               <span class='hs-comment'>-- Nothing matches</span>
<a name="line-64"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"matchClass not matching"</span> <span class='hs-varop'>$</span>
<a name="line-65"></a>                        <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"dict"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>]</span>
<a name="line-66"></a>                      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoInstance</span> <span class='hs-layout'>}</span>
<a name="line-67"></a>
<a name="line-68"></a>            <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>ispec</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- A single match</span>
<a name="line-69"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_IncoherentInstances</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-70"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>given_overlap</span> <span class='hs-varid'>untch</span>
<a name="line-71"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- See Note [Instance and Given overlap]</span>
<a name="line-72"></a>                   <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Delaying instance application"</span> <span class='hs-varop'>$</span>
<a name="line-73"></a>                          <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Workitem="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprType</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-74"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Relevant given dictionaries="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>givens_for_this_clas</span> <span class='hs-keyglyph'>]</span>
<a name="line-75"></a>                      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoInstance</span>  <span class='hs-layout'>}</span>
<a name="line-76"></a>
<a name="line-77"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-78"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>   <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>dfun_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>instanceDFunId</span> <span class='hs-varid'>ispec</span>
<a name="line-79"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"matchClass success"</span> <span class='hs-varop'>$</span>
<a name="line-80"></a>                          <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"dict"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>,</span>
<a name="line-81"></a>                                <span class='hs-varid'>text</span> <span class='hs-str'>"witness"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dfun_id</span>
<a name="line-82"></a>                                               <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>dfun_id</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-83"></a>                                  <span class='hs-comment'>-- Record that this dfun is needed</span>
<a name="line-84"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>match_one</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>inst_tys</span> <span class='hs-layout'>}</span>
<a name="line-85"></a>
<a name="line-86"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>matches</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- More than one matches</span>
<a name="line-87"></a>                               <span class='hs-comment'>-- Defer any reactions of a multitude</span>
<a name="line-88"></a>                               <span class='hs-comment'>-- until we learn more about the reagent</span>
<a name="line-89"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>   <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"matchClass multiple matches, deferring choice"</span> <span class='hs-varop'>$</span>
<a name="line-90"></a>                          <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"dict"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>,</span>
<a name="line-91"></a>                                <span class='hs-varid'>text</span> <span class='hs-str'>"matches"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>matches</span><span class='hs-keyglyph'>]</span>
<a name="line-92"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoInstance</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-93"></a>   <span class='hs-keyword'>where</span>
<a name="line-94"></a>     <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span>
<a name="line-95"></a>
<a name="line-96"></a>     <span class='hs-varid'>match_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DFunId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>LookupInstResult</span>
<a name="line-97"></a>                  <span class='hs-comment'>-- See Note [DFunInstType: instantiating types] in InstEnv</span>
<a name="line-98"></a>     <span class='hs-varid'>match_one</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>mb_inst_tys</span>
<a name="line-99"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkWellStagedDFun</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>loc</span>
<a name="line-100"></a>            <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>dfun_phi</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instDFunType</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>mb_inst_tys</span>
<a name="line-101"></a>            <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitPhiTy</span> <span class='hs-varid'>dfun_phi</span>
<a name="line-102"></a>            <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span> <span class='hs-keyword'>then</span>
<a name="line-103"></a>                  <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenInst</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvDFunApp</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>tys</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-104"></a>              <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-105"></a>            <span class='hs-layout'>{</span> <span class='hs-varid'>evc_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instDFunConstraints</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>theta</span>
<a name="line-106"></a>            <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>new_ev_vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>freshGoals</span> <span class='hs-varid'>evc_vars</span>
<a name="line-107"></a>                      <span class='hs-comment'>-- new_ev_vars are only the real new variables that can be emitted</span>
<a name="line-108"></a>                  <span class='hs-varid'>dfun_app</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvDFunApp</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>(</span><span class='hs-varid'>getEvTerms</span> <span class='hs-varid'>evc_vars</span><span class='hs-layout'>)</span>
<a name="line-109"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>GenInst</span> <span class='hs-varid'>new_ev_vars</span> <span class='hs-varid'>dfun_app</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-110"></a>
<a name="line-111"></a>     <span class='hs-varid'>givens_for_this_clas</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span>
<a name="line-112"></a>     <span class='hs-varid'>givens_for_this_clas</span>
<a name="line-113"></a>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterBag</span> <span class='hs-varid'>isGivenCt</span> <span class='hs-layout'>(</span><span class='hs-varid'>findDictsByClass</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_dicts</span> <span class='hs-varop'>$</span> <span class='hs-varid'>inert_cans</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span>
<a name="line-114"></a>
<a name="line-115"></a>     <span class='hs-varid'>given_overlap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Untouchables</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-116"></a>     <span class='hs-varid'>given_overlap</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anyBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>matchable</span> <span class='hs-varid'>untch</span><span class='hs-layout'>)</span> <span class='hs-varid'>givens_for_this_clas</span>
<a name="line-117"></a>
<a name="line-118"></a>     <span class='hs-varid'>matchable</span> <span class='hs-varid'>untch</span> <span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>clas_g</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sys</span>
<a name="line-119"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-120"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGiven</span> <span class='hs-varid'>fl</span>
<a name="line-121"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>clas_g</span> <span class='hs-varop'>==</span> <span class='hs-varid'>clas</span> <span class='hs-layout'>)</span>
<a name="line-122"></a>         <span class='hs-keyword'>case</span> <span class='hs-varid'>tcUnifyTys</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>tv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isTouchableMetaTyVar</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&amp;&amp;</span>
<a name="line-123"></a>                                    <span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>tys</span>
<a name="line-124"></a>                                 <span class='hs-keyword'>then</span> <span class='hs-conid'>BindMe</span> <span class='hs-keyword'>else</span> <span class='hs-conid'>Skolem</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>sys</span> <span class='hs-keyword'>of</span>
<a name="line-125"></a>       <span class='hs-comment'>-- We can't learn anything more about any variable at this point, so the only</span>
<a name="line-126"></a>       <span class='hs-comment'>-- cause of overlap can be by an instantiation of a touchable unification</span>
<a name="line-127"></a>       <span class='hs-comment'>-- variable. Hence we only bind touchable unification variables. In addition,</span>
<a name="line-128"></a>       <span class='hs-comment'>-- we use tcUnifyTys instead of tcMatchTys to rule out cyclic substitutions.</span>
<a name="line-129"></a>            <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-130"></a>            <span class='hs-conid'>Just</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-131"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- No overlap with a solved, already been taken care of</span>
<a name="line-132"></a>                           <span class='hs-comment'>-- by the overlap check with the instance environment.</span>
<a name="line-133"></a>     <span class='hs-varid'>matchable</span> <span class='hs-sel'>_tys</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"Expecting dictionary!"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-134"></a>
<a name="line-135"></a><a name="getCoercibleInst"></a><span class='hs-comment'>-- See Note [Coercible Instances]</span>
<a name="line-136"></a><span class='hs-comment'>-- Changes to this logic should likely be reflected in coercible_msg in TcErrors.</span>
<a name="line-137"></a><span class='hs-definition'>getCoercibleInst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>LookupInstResult</span>
<a name="line-138"></a><span class='hs-definition'>getCoercibleInst</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-139"></a>      <span class='hs-comment'>-- Get some global stuff in scope, for nice pattern-guard based code in `go`</span>
<a name="line-140"></a>      <span class='hs-varid'>rdr_env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getGlobalRdrEnvTcS</span>
<a name="line-141"></a>      <span class='hs-varid'>famenv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFamInstEnvs</span>
<a name="line-142"></a>      <span class='hs-varid'>go</span> <span class='hs-varid'>famenv</span> <span class='hs-varid'>rdr_env</span>
<a name="line-143"></a>  <span class='hs-keyword'>where</span>
<a name="line-144"></a>  <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>GlobalRdrEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>LookupInstResult</span>
<a name="line-145"></a>  <span class='hs-varid'>go</span> <span class='hs-varid'>famenv</span> <span class='hs-varid'>rdr_env</span>
<a name="line-146"></a>    <span class='hs-comment'>-- Coercible a a                             (see case 1 in [Coercible Instances])</span>
<a name="line-147"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>ty2</span>
<a name="line-148"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>GenInst</span> <span class='hs-conid'>[]</span>
<a name="line-149"></a>                <span class='hs-varop'>$</span> <span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcRefl</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span>
<a name="line-150"></a>
<a name="line-151"></a>    <span class='hs-comment'>-- Coercible (forall a. ty) (forall a. ty')  (see case 2 in [Coercible Instances])</span>
<a name="line-152"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tcIsForAllTy</span> <span class='hs-varid'>ty1</span>
<a name="line-153"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>tcIsForAllTy</span> <span class='hs-varid'>ty2</span>
<a name="line-154"></a>    <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs1</span><span class='hs-layout'>,</span><span class='hs-varid'>body1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitForAllTys</span> <span class='hs-varid'>ty1</span>
<a name="line-155"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>tvs2</span><span class='hs-layout'>,</span><span class='hs-varid'>body2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitForAllTys</span> <span class='hs-varid'>ty2</span>
<a name="line-156"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>equalLength</span> <span class='hs-varid'>tvs1</span> <span class='hs-varid'>tvs2</span>
<a name="line-157"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-158"></a>       <span class='hs-varid'>ev_term</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>deferTcSForAllEq</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs1</span><span class='hs-layout'>,</span><span class='hs-varid'>body1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs2</span><span class='hs-layout'>,</span><span class='hs-varid'>body2</span><span class='hs-layout'>)</span>
<a name="line-159"></a>       <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>GenInst</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>ev_term</span>
<a name="line-160"></a>
<a name="line-161"></a>    <span class='hs-comment'>-- Coercible (D ty1 ty2) (D ty1' ty2')       (see case 3 in [Coercible Instances])</span>
<a name="line-162"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc1</span><span class='hs-layout'>,</span><span class='hs-varid'>tyArgs1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span>
<a name="line-163"></a>      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc2</span><span class='hs-layout'>,</span><span class='hs-varid'>tyArgs2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>,</span>
<a name="line-164"></a>      <span class='hs-varid'>tc1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tc2</span><span class='hs-layout'>,</span>
<a name="line-165"></a>      <span class='hs-varid'>nominalArgsAgree</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tyArgs1</span> <span class='hs-varid'>tyArgs2</span>
<a name="line-166"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-comment'>-- We want evidence for all type arguments of role R</span>
<a name="line-167"></a>         <span class='hs-varid'>arg_stuff</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>forM</span> <span class='hs-layout'>(</span><span class='hs-varid'>zip3</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConRoles</span> <span class='hs-varid'>tc1</span><span class='hs-layout'>)</span> <span class='hs-varid'>tyArgs1</span> <span class='hs-varid'>tyArgs2</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>r</span><span class='hs-layout'>,</span><span class='hs-varid'>ta1</span><span class='hs-layout'>,</span><span class='hs-varid'>ta2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-168"></a>           <span class='hs-keyword'>case</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>of</span> <span class='hs-conid'>Nominal</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-169"></a>                          <span class='hs-varid'>return</span>
<a name="line-170"></a>                            <span class='hs-layout'>(</span> <span class='hs-conid'>Nothing</span>
<a name="line-171"></a>                            <span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span>
<a name="line-172"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>ta1</span> <span class='hs-comment'>{- == ta2, due to nominalArgsAgree -}</span>
<a name="line-173"></a>                            <span class='hs-layout'>)</span>
<a name="line-174"></a>                     <span class='hs-conid'>Representational</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-175"></a>                          <span class='hs-varid'>ct_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>requestCoercible</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>ta1</span> <span class='hs-varid'>ta2</span>
<a name="line-176"></a>                          <span class='hs-varid'>local_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkSysLocalM</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"coev"</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkCoerciblePred</span> <span class='hs-varid'>ta1</span> <span class='hs-varid'>ta2</span>
<a name="line-177"></a>                          <span class='hs-varid'>return</span>
<a name="line-178"></a>                            <span class='hs-layout'>(</span> <span class='hs-varid'>freshGoal</span> <span class='hs-varid'>ct_ev</span>
<a name="line-179"></a>                            <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvBind</span> <span class='hs-varid'>local_var</span> <span class='hs-layout'>(</span><span class='hs-varid'>getEvTerm</span> <span class='hs-varid'>ct_ev</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-180"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>local_var</span>
<a name="line-181"></a>                            <span class='hs-layout'>)</span>
<a name="line-182"></a>                     <span class='hs-conid'>Phantom</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-183"></a>                          <span class='hs-varid'>return</span>
<a name="line-184"></a>                            <span class='hs-layout'>(</span> <span class='hs-conid'>Nothing</span>
<a name="line-185"></a>                            <span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span>
<a name="line-186"></a>                            <span class='hs-layout'>,</span> <span class='hs-conid'>TcPhantomCo</span> <span class='hs-varid'>ta1</span> <span class='hs-varid'>ta2</span><span class='hs-layout'>)</span>
<a name="line-187"></a>         <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_new</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_binds</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip3</span> <span class='hs-varid'>arg_stuff</span>
<a name="line-188"></a>             <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvBinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>listToBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>catMaybes</span> <span class='hs-varid'>arg_binds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-189"></a>             <span class='hs-varid'>tcCo</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TcLetCo</span> <span class='hs-varid'>binds</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>arg_cos</span><span class='hs-layout'>)</span>
<a name="line-190"></a>         <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>GenInst</span> <span class='hs-layout'>(</span><span class='hs-varid'>catMaybes</span> <span class='hs-varid'>arg_new</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-varid'>tcCo</span><span class='hs-layout'>)</span>
<a name="line-191"></a>
<a name="line-192"></a>    <span class='hs-comment'>-- Coercible NT a                            (see case 4 in [Coercible Instances])</span>
<a name="line-193"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span><span class='hs-varid'>tyArgs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span>
<a name="line-194"></a>      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>concTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>ntCo</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instNewTyConTF_maybe</span> <span class='hs-varid'>famenv</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tyArgs</span><span class='hs-layout'>,</span>
<a name="line-195"></a>      <span class='hs-varid'>dataConsInScope</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>tc</span> <span class='hs-comment'>-- Do not look at all tyConsOfTyCon</span>
<a name="line-196"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>markDataConsAsUsed</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>tc</span>
<a name="line-197"></a>         <span class='hs-varid'>ct_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>requestCoercible</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>concTy</span> <span class='hs-varid'>ty2</span>
<a name="line-198"></a>         <span class='hs-varid'>local_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkSysLocalM</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"coev"</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkCoerciblePred</span> <span class='hs-varid'>concTy</span> <span class='hs-varid'>ty2</span>
<a name="line-199"></a>         <span class='hs-keyword'>let</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvBinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvBind</span> <span class='hs-varid'>local_var</span> <span class='hs-layout'>(</span><span class='hs-varid'>getEvTerm</span> <span class='hs-varid'>ct_ev</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-200"></a>             <span class='hs-varid'>tcCo</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TcLetCo</span> <span class='hs-varid'>binds</span> <span class='hs-varop'>$</span>
<a name="line-201"></a>                            <span class='hs-varid'>coercionToTcCoercion</span> <span class='hs-varid'>ntCo</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>local_var</span>
<a name="line-202"></a>         <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>GenInst</span> <span class='hs-layout'>(</span><span class='hs-varid'>freshGoals</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ct_ev</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-varid'>tcCo</span><span class='hs-layout'>)</span>
<a name="line-203"></a>
<a name="line-204"></a>    <span class='hs-comment'>-- Coercible a NT                            (see case 4 in [Coercible Instances])</span>
<a name="line-205"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span><span class='hs-varid'>tyArgs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>,</span>
<a name="line-206"></a>      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>concTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>ntCo</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instNewTyConTF_maybe</span> <span class='hs-varid'>famenv</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tyArgs</span><span class='hs-layout'>,</span>
<a name="line-207"></a>      <span class='hs-varid'>dataConsInScope</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>tc</span> <span class='hs-comment'>-- Do not look at all tyConsOfTyCon</span>
<a name="line-208"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>markDataConsAsUsed</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>tc</span>
<a name="line-209"></a>         <span class='hs-varid'>ct_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>requestCoercible</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>concTy</span>
<a name="line-210"></a>         <span class='hs-varid'>local_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkSysLocalM</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"coev"</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkCoerciblePred</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>concTy</span>
<a name="line-211"></a>         <span class='hs-keyword'>let</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvBinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvBind</span> <span class='hs-varid'>local_var</span> <span class='hs-layout'>(</span><span class='hs-varid'>getEvTerm</span> <span class='hs-varid'>ct_ev</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-212"></a>             <span class='hs-varid'>tcCo</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TcLetCo</span> <span class='hs-varid'>binds</span> <span class='hs-varop'>$</span>
<a name="line-213"></a>                            <span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>local_var</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionToTcCoercion</span> <span class='hs-varid'>ntCo</span><span class='hs-layout'>)</span>
<a name="line-214"></a>         <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>GenInst</span> <span class='hs-layout'>(</span><span class='hs-varid'>freshGoals</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ct_ev</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-varid'>tcCo</span><span class='hs-layout'>)</span>
<a name="line-215"></a>
<a name="line-216"></a>    <span class='hs-comment'>-- Cannot solve this one</span>
<a name="line-217"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-218"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoInstance</span>
<a name="line-219"></a>
<a name="line-220"></a><a name="nominalArgsAgree"></a><span class='hs-definition'>nominalArgsAgree</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-221"></a><span class='hs-definition'>nominalArgsAgree</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>ok</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zip3</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConRoles</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-222"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>ok</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span><span class='hs-layout'>,</span><span class='hs-varid'>t1</span><span class='hs-layout'>,</span><span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span> <span class='hs-varop'>/=</span> <span class='hs-conid'>Nominal</span> <span class='hs-varop'>||</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>t2</span>
<a name="line-223"></a>
<a name="line-224"></a><a name="dataConsInScope"></a><span class='hs-definition'>dataConsInScope</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GlobalRdrEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-225"></a><span class='hs-definition'>dataConsInScope</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-varid'>hidden_data_cons</span>
<a name="line-226"></a>  <span class='hs-keyword'>where</span>
<a name="line-227"></a>    <span class='hs-varid'>data_con_names</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>dataConName</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-228"></a>    <span class='hs-varid'>hidden_data_cons</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWiredInName</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span>
<a name="line-229"></a>                       <span class='hs-layout'>(</span><span class='hs-varid'>isAbstractTyCon</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>||</span> <span class='hs-varid'>any</span> <span class='hs-varid'>not_in_scope</span> <span class='hs-varid'>data_con_names</span><span class='hs-layout'>)</span>
<a name="line-230"></a>    <span class='hs-varid'>not_in_scope</span> <span class='hs-varid'>dc</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupGRE_Name</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-231"></a>
<a name="line-232"></a><a name="markDataConsAsUsed"></a><span class='hs-definition'>markDataConsAsUsed</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GlobalRdrEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-233"></a><span class='hs-definition'>markDataConsAsUsed</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addUsedRdrNamesTcS</span>
<a name="line-234"></a>  <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mkRdrQual</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_as</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_decl</span> <span class='hs-varid'>imp_spec</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>occ</span>
<a name="line-235"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>tc</span>
<a name="line-236"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>dc_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConName</span> <span class='hs-varid'>dc</span>
<a name="line-237"></a>        <span class='hs-varid'>occ</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nameOccName</span> <span class='hs-varid'>dc_name</span>
<a name="line-238"></a>        <span class='hs-varid'>gres</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupGRE_Name</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>dc_name</span>
<a name="line-239"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>gres</span><span class='hs-layout'>)</span>
<a name="line-240"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Imported</span> <span class='hs-layout'>(</span><span class='hs-varid'>imp_spec</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>gre_prov</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>gres</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>]</span>
<a name="line-241"></a>
<a name="line-242"></a><a name="requestCoercible"></a><span class='hs-definition'>requestCoercible</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>MaybeNew</span>
<a name="line-243"></a><span class='hs-definition'>requestCoercible</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span>
<a name="line-244"></a>    <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`tcEqKind`</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-245"></a>    <span class='hs-varid'>newWantedEvVarNonrec</span> <span class='hs-varid'>loc'</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCoerciblePred</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-246"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>loc'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bumpCtLocDepth</span> <span class='hs-conid'>CountConstraints</span> <span class='hs-varid'>loc</span>
<a name="line-247"></a>
</pre>\end{code}

Note [Coercible Instances]
~~~~~~~~~~~~~~~~~~~~~~~~~~
The class Coercible is special: There are no regular instances, and the user
cannot even define them (it is listed as an `abstractClass` in TcValidity).
Instead, the type checker will create instances and their evidence out of thin
air, in getCoercibleInst. The following “instances” are present:

 1. instance Coercible a a
    for any type a at any kind k.

 2. instance (forall a. Coercible t1 t2) => Coercible (forall a. t1) (forall a. t2)
    (which would be illegal to write like that in the source code, but we have
    it nevertheless).


 3. instance (Coercible t1_r t1'_r, Coercible t2_r t2_r',...) =>
       Coercible (C t1_r  t2_r  ... t1_p  t2_p  ... t1_n t2_n ...)
                 (C t1_r' t2_r' ... t1_p' t2_p' ... t1_n t2_n ...)
    for a type constructor C where
     * the nominal type arguments are not changed,
     * the phantom type arguments may change arbitrarily
     * the representational type arguments are again Coercible

    The type constructor can be used undersaturated; then the Coercible
    instance is at a higher kind. This does not cause problems.

 4. instance Coercible r b => Coercible (NT t1 t2 ...) b
    instance Coercible a r => Coercible a (NT t1 t2 ...)
    for a newtype constructor NT (or data family instance that resolves to a
    newtype) where
     * r is the concrete type of NT, instantiated with the arguments t1 t2 ...
     * the constructor of NT are in scope.

    Again, the newtype TyCon can appear undersaturated, but only if it has
    enough arguments to apply the newtype coercion (which is eta-reduced). Examples:
      newtype NT a = NT (Either a Int)
      Coercible (NT Int) (Either Int Int) -- ok
      newtype NT2 a b = NT2 (b -> a)
      newtype NT3 a b = NT3 (b -> a)
      Coercible (NT2 Int) (NT3 Int) -- cannot be derived

The type checker generates evidence in the form of EvCoercion, but the
TcCoercion therein has role Representational,  which are turned into Core
coercions by dsEvTerm in DsBinds.

The evidence for the first three instance is generated here by
getCoercibleInst, for the second instance deferTcSForAllEq is used.

When the constraint cannot be solved, it is treated as any other unsolved
constraint, i.e. it can turn up in an inferred type signature, or reported to
the user as a regular "Cannot derive instance ..." error. In the latter case,
coercible_msg in TcErrors gives additional explanations of why GHC could not
find a Coercible instance, so it duplicates some of the logic from
getCoercibleInst (in negated form).


Note [Instance and Given overlap]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Assume that we have an inert set that looks as follows:
       [Given] D [Int]
And an instance declaration:
       instance C a => D [a]
A new wanted comes along of the form:
       [Wanted] D [alpha]

One possibility is to apply the instance declaration which will leave us
with an unsolvable goal (C alpha). However, later on a new constraint may
arise (for instance due to a functional dependency between two later dictionaries),
that will add the equality (alpha ~ Int), in which case our ([Wanted] D [alpha])
will be transformed to [Wanted] D [Int], which could have been discharged by the given.

The solution is that in matchClassInst and eventually in topReact, we get back with
a matching instance, only when there is no Given in the inerts which is unifiable to
this particular dictionary.

The end effect is that, much as we do for overlapping instances, we delay choosing a
class instance if there is a possibility of another instance OR a given to match our
constraint later on. This fixes bugs #4981 and #5002.

This is arguably not easy to appear in practice due to our aggressive prioritization
of equality solving over other constraints, but it is possible. I've added a test case
in typecheck/should-compile/GivenOverlapping.hs

We ignore the overlap problem if -XIncoherentInstances is in force: see
Trac #6002 for a worked-out example where this makes a difference.

Moreover notice that our goals here are different than the goals of the top-level
overlapping checks. There we are interested in validating the following principle:

    If we inline a function f at a site where the same global instance environment
    is available as the instance environment at the definition site of f then we
    should get the same behaviour.

But for the Given Overlap check our goal is just related to completeness of
constraint solving.
</body>
</html>
