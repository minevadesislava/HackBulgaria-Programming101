<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcSimplify.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
\begin{code}
<pre><a name="line-1"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcSimplify</span><span class='hs-layout'>(</span>
<a name="line-2"></a>       <span class='hs-varid'>simplifyInfer</span><span class='hs-layout'>,</span> <span class='hs-varid'>quantifyPred</span><span class='hs-layout'>,</span>
<a name="line-3"></a>       <span class='hs-varid'>simplifyAmbiguityCheck</span><span class='hs-layout'>,</span>
<a name="line-4"></a>       <span class='hs-varid'>simplifyDefault</span><span class='hs-layout'>,</span>
<a name="line-5"></a>       <span class='hs-varid'>simplifyRule</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyTop</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyInteractive</span><span class='hs-layout'>,</span>
<a name="line-6"></a>       <span class='hs-varid'>solveWantedsTcM</span>
<a name="line-7"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnTypes</span>
<a name="line-12"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnMonad</span>
<a name="line-13"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcErrors</span>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcMType</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TcM</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSMonad</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TcS</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcInteract</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Kind</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>isKind</span><span class='hs-layout'>,</span> <span class='hs-varid'>defaultKind_maybe</span> <span class='hs-layout'>)</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Inst</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FunDeps</span>  <span class='hs-layout'>(</span> <span class='hs-varid'>growThetaTyVars</span> <span class='hs-layout'>)</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>classifyPredType</span><span class='hs-layout'>,</span> <span class='hs-conid'>PredTree</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>getClassPredTys_maybe</span> <span class='hs-layout'>)</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>    <span class='hs-layout'>(</span> <span class='hs-conid'>Class</span> <span class='hs-layout'>)</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unique</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ListSetOps</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelInfo</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelNames</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>)</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>         <span class='hs-layout'>(</span> <span class='hs-conid'>ExtensionFlag</span><span class='hs-layout'>(</span> <span class='hs-conid'>Opt_AllowAmbiguousTypes</span> <span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>            <span class='hs-layout'>(</span> <span class='hs-varid'>classKey</span> <span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>       <span class='hs-layout'>(</span> <span class='hs-conid'>RuleName</span> <span class='hs-layout'>)</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TrieMap</span> <span class='hs-conid'>()</span> <span class='hs-comment'>-- DV: for now</span>
</pre>\end{code}


*********************************************************************************
*                                                                               *
*                           External interface                                  *
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="simplifyTop"></a><span class='hs-definition'>simplifyTop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-comment'>-- Simplify top-level constraints</span>
<a name="line-3"></a><span class='hs-comment'>-- Usually these will be implications,</span>
<a name="line-4"></a><span class='hs-comment'>-- but when there is nothing to quantify we don't wrap</span>
<a name="line-5"></a><span class='hs-comment'>-- in a degenerate implication, so we do that here instead</span>
<a name="line-6"></a><span class='hs-definition'>simplifyTop</span> <span class='hs-varid'>wanteds</span>
<a name="line-7"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyTop {"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"wanted = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-8"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcEvBinds</span>
<a name="line-9"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_final_wc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcMWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wanteds</span> <span class='hs-varid'>simpl_top</span>
<a name="line-10"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>binds1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcRnMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>getTcEvBinds</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"End simplifyTop }"</span> <span class='hs-varid'>empty</span>
<a name="line-12"></a>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved {"</span> <span class='hs-varid'>empty</span>
<a name="line-14"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>binds2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>reportUnsolved</span> <span class='hs-varid'>zonked_final_wc</span>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved }"</span> <span class='hs-varid'>empty</span>
<a name="line-16"></a>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>binds1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>binds2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-18"></a>
<a name="line-19"></a><a name="simpl_top"></a><span class='hs-definition'>simpl_top</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-20"></a>    <span class='hs-comment'>-- See Note [Top-level Defaulting Plan]</span>
<a name="line-21"></a><span class='hs-definition'>simpl_top</span> <span class='hs-varid'>wanteds</span>
<a name="line-22"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_first_go</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>solve_wanteds_and_drop</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-23"></a>                            <span class='hs-comment'>-- This is where the main work happens</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>try_tyvar_defaulting</span> <span class='hs-varid'>wc_first_go</span> <span class='hs-layout'>}</span>
<a name="line-25"></a>  <span class='hs-keyword'>where</span>
<a name="line-26"></a>    <span class='hs-varid'>try_tyvar_defaulting</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-27"></a>    <span class='hs-varid'>try_tyvar_defaulting</span> <span class='hs-varid'>wc</span>
<a name="line-28"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wc</span>
<a name="line-29"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span>
<a name="line-30"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-31"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>free_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>zonkTyVarsAndFV</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfWC</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-32"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>meta_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>varSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>filterVarSet</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>free_tvs</span><span class='hs-layout'>)</span>
<a name="line-33"></a>                   <span class='hs-comment'>-- zonkTyVarsAndFV: the wc_first_go is not yet zonked</span>
<a name="line-34"></a>                   <span class='hs-comment'>-- filter isMetaTyVar: we might have runtime-skolems in GHCi,</span>
<a name="line-35"></a>                   <span class='hs-comment'>-- and we definitely don't want to try to assign to those!</span>
<a name="line-36"></a>
<a name="line-37"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>meta_tvs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>defaultTyVar</span> <span class='hs-varid'>meta_tvs</span>   <span class='hs-comment'>-- Has unification side effects</span>
<a name="line-38"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>meta_tvs'</span> <span class='hs-varop'>==</span> <span class='hs-varid'>meta_tvs</span>   <span class='hs-comment'>-- No defaulting took place;</span>
<a name="line-39"></a>                                        <span class='hs-comment'>-- (defaulting returns fresh vars)</span>
<a name="line-40"></a>             <span class='hs-keyword'>then</span> <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc</span>
<a name="line-41"></a>             <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_residual</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>solve_wanteds_and_drop</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-42"></a>                            <span class='hs-comment'>-- See Note [Must simplify after defaulting]</span>
<a name="line-43"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc_residual</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-44"></a>
<a name="line-45"></a>    <span class='hs-varid'>try_class_defaulting</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-46"></a>    <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc</span>
<a name="line-47"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wc</span> <span class='hs-varop'>||</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>wc</span>
<a name="line-48"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span>  <span class='hs-comment'>-- Don't do type-class defaulting if there are insolubles</span>
<a name="line-49"></a>                   <span class='hs-comment'>-- Doing so is not going to solve the insolubles</span>
<a name="line-50"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-51"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>something_happened</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>applyDefaultingRules</span> <span class='hs-layout'>(</span><span class='hs-varid'>approximateWC</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-52"></a>                                   <span class='hs-comment'>-- See Note [Top-level Defaulting Plan]</span>
<a name="line-53"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>something_happened</span>
<a name="line-54"></a>             <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_residual</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>solve_wanteds_and_drop</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-55"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc_residual</span> <span class='hs-layout'>}</span>
<a name="line-56"></a>             <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Must simplify after defaulting]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We may have a deeply buried constraint
    (t:*) ~ (a:Open)
which we couldn't solve because of the kind incompatibility, and 'a' is free.
Then when we default 'a' we can solve the constraint.  And we want to do
that before starting in on type classes.  We MUST do it before reporting
errors, because it isn't an error!  Trac #7967 was due to this.

Note [Top-level Defaulting Plan]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We have considered two design choices for where/when to apply defaulting.
   (i) Do it in SimplCheck mode only /whenever/ you try to solve some
       flat constraints, maybe deep inside the context of implications.
       This used to be the case in GHC 7.4.1.
   (ii) Do it in a tight loop at simplifyTop, once all other constraint has
        finished. This is the current story.

Option (i) had many disadvantages:
   a) First it was deep inside the actual solver,
   b) Second it was dependent on the context (Infer a type signature,
      or Check a type signature, or Interactive) since we did not want
      to always start defaulting when inferring (though there is an exception to
      this see Note [Default while Inferring])
   c) It plainly did not work. Consider typecheck/should_compile/DfltProb2.hs:
          f :: Int -> Bool
          f x = const True (\y -> let w :: a -> a
                                      w a = const a (y+1)
                                  in w y)
      We will get an implication constraint (for beta the type of y):
               [untch=beta] forall a. 0 => Num beta
      which we really cannot default /while solving/ the implication, since beta is
      untouchable.

Instead our new defaulting story is to pull defaulting out of the solver loop and
go with option (i), implemented at SimplifyTop. Namely:
     - First have a go at solving the residual constraint of the whole program
     - Try to approximate it with a flat constraint
     - Figure out derived defaulting equations for that flat constraint
     - Go round the loop again if you did manage to get some equations

Now, that has to do with class defaulting. However there exists type variable /kind/
defaulting. Again this is done at the top-level and the plan is:
     - At the top-level, once you had a go at solving the constraint, do
       figure out /all/ the touchable unification variables of the wanted constraints.
     - Apply defaulting to their kinds

More details in Note [DefaultTyVar].

\begin{code}
<pre><a name="line-1"></a><a name="simplifyAmbiguityCheck"></a><span class='hs-comment'>------------------</span>
<a name="line-2"></a><span class='hs-definition'>simplifyAmbiguityCheck</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-3"></a><span class='hs-definition'>simplifyAmbiguityCheck</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>wanteds</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyAmbiguityCheck {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"type = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"wanted = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-5"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcEvBinds</span>
<a name="line-6"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_final_wc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcMWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wanteds</span> <span class='hs-varid'>simpl_top</span>
<a name="line-7"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"End simplifyAmbiguityCheck }"</span> <span class='hs-varid'>empty</span>
<a name="line-8"></a>
<a name="line-9"></a>       <span class='hs-comment'>-- Normally report all errors; but with -XAllowAmbiguousTypes</span>
<a name="line-10"></a>       <span class='hs-comment'>-- report only insoluble ones, since they represent genuinely</span>
<a name="line-11"></a>       <span class='hs-comment'>-- inaccessible code</span>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>allow_ambiguous</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_AllowAmbiguousTypes</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved(ambig) {"</span> <span class='hs-varid'>empty</span>
<a name="line-14"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>allow_ambiguous</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>zonked_final_wc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-15"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>discardResult</span> <span class='hs-layout'>(</span><span class='hs-varid'>reportUnsolved</span> <span class='hs-varid'>zonked_final_wc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved(ambig) }"</span> <span class='hs-varid'>empty</span>
<a name="line-17"></a>
<a name="line-18"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-19"></a>
<a name="line-20"></a><a name="simplifyInteractive"></a><span class='hs-comment'>------------------</span>
<a name="line-21"></a><span class='hs-definition'>simplifyInteractive</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-22"></a><span class='hs-definition'>simplifyInteractive</span> <span class='hs-varid'>wanteds</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInteractive"</span> <span class='hs-varid'>empty</span> <span class='hs-varop'>&gt;&gt;</span>
<a name="line-24"></a>    <span class='hs-varid'>simplifyTop</span> <span class='hs-varid'>wanteds</span>
<a name="line-25"></a>
<a name="line-26"></a><a name="simplifyDefault"></a><span class='hs-comment'>------------------</span>
<a name="line-27"></a><span class='hs-definition'>simplifyDefault</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ThetaType</span>    <span class='hs-comment'>-- Wanted; has no type variables in it</span>
<a name="line-28"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>       <span class='hs-comment'>-- Succeeds iff the constraint is soluble</span>
<a name="line-29"></a><span class='hs-definition'>simplifyDefault</span> <span class='hs-varid'>theta</span>
<a name="line-30"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInteractive"</span> <span class='hs-varid'>empty</span>
<a name="line-31"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFlatWanteds</span> <span class='hs-conid'>DefaultOrigin</span> <span class='hs-varid'>theta</span>
<a name="line-32"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsolved</span><span class='hs-layout'>,</span> <span class='hs-sel'>_binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFlatWC</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-33"></a>
<a name="line-34"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved {"</span> <span class='hs-varid'>empty</span>
<a name="line-35"></a>       <span class='hs-comment'>-- See Note [Deferring coercion errors to runtime]</span>
<a name="line-36"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>reportAllUnsolved</span> <span class='hs-varid'>unsolved</span>
<a name="line-37"></a>         <span class='hs-comment'>-- Postcondition of solveWantedsTcM is that returned</span>
<a name="line-38"></a>         <span class='hs-comment'>-- constraints are zonked. So Precondition of reportUnsolved</span>
<a name="line-39"></a>         <span class='hs-comment'>-- is true.</span>
<a name="line-40"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved }"</span> <span class='hs-varid'>empty</span>
<a name="line-41"></a>
<a name="line-42"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
</pre>\end{code}


*********************************************************************************
*                                                                                 *
*                            Inference
*                                                                                 *
***********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="simplifyInfer"></a><span class='hs-definition'>simplifyInfer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-2"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>                  <span class='hs-comment'>-- Apply monomorphism restriction</span>
<a name="line-3"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTauType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Variables to be generalised,</span>
<a name="line-4"></a>                                       <span class='hs-comment'>-- and their tau-types</span>
<a name="line-5"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-6"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- Quantify over these type variables</span>
<a name="line-7"></a>                      <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- ... and these constraints</span>
<a name="line-8"></a>                      <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- The monomorphism restriction did something</span>
<a name="line-9"></a>                                    <span class='hs-comment'>--   so the results type is not as general as</span>
<a name="line-10"></a>                                    <span class='hs-comment'>--   it could be</span>
<a name="line-11"></a>                      <span class='hs-conid'>TcEvBinds</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- ... binding these evidence variables</span>
<a name="line-12"></a><span class='hs-definition'>simplifyInfer</span> <span class='hs-sel'>_top_lvl</span> <span class='hs-varid'>apply_mr</span> <span class='hs-varid'>name_taus</span> <span class='hs-varid'>wanteds</span>
<a name="line-13"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-14"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>qtkvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>quantifyTyVars</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInfer: empty WC"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>name_taus</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtkvs</span><span class='hs-layout'>)</span>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>qtkvs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyTcEvBinds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-18"></a>
<a name="line-19"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-20"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInfer {"</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-21"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"binds ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name_taus</span>
<a name="line-22"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"closed ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-sel'>_top_lvl</span>
<a name="line-23"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"apply_mr ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>apply_mr</span>
<a name="line-24"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"(unzonked) wanted ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-25"></a>             <span class='hs-keyglyph'>]</span>
<a name="line-26"></a>
<a name="line-27"></a>              <span class='hs-comment'>-- Historical note: Before step 2 we used to have a</span>
<a name="line-28"></a>              <span class='hs-comment'>-- HORRIBLE HACK described in Note [Avoid unecessary</span>
<a name="line-29"></a>              <span class='hs-comment'>-- constraint simplification] but, as described in Trac</span>
<a name="line-30"></a>              <span class='hs-comment'>-- #4361, we have taken in out now.  That's why we start</span>
<a name="line-31"></a>              <span class='hs-comment'>-- with step 2!</span>
<a name="line-32"></a>
<a name="line-33"></a>              <span class='hs-comment'>-- Step 2) First try full-blown solving</span>
<a name="line-34"></a>
<a name="line-35"></a>              <span class='hs-comment'>-- NB: we must gather up all the bindings from doing</span>
<a name="line-36"></a>              <span class='hs-comment'>-- this solving; hence (runTcSWithEvBinds ev_binds_var).</span>
<a name="line-37"></a>              <span class='hs-comment'>-- And note that since there are nested implications,</span>
<a name="line-38"></a>              <span class='hs-comment'>-- calling solveWanteds will side-effect their evidence</span>
<a name="line-39"></a>              <span class='hs-comment'>-- bindings, so we can't just revert to the input</span>
<a name="line-40"></a>              <span class='hs-comment'>-- constraint.</span>
<a name="line-41"></a>
<a name="line-42"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcEvBinds</span>
<a name="line-43"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span>
<a name="line-44"></a>               <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcMWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wanteds</span> <span class='hs-varid'>solve_wanteds</span>
<a name="line-45"></a>                  <span class='hs-comment'>-- Post: wanted_transformed_incl_derivs are zonked</span>
<a name="line-46"></a>
<a name="line-47"></a>              <span class='hs-comment'>-- Step 4) Candidates for quantification are an approximation of wanted_transformed</span>
<a name="line-48"></a>              <span class='hs-comment'>-- NB: Already the fixpoint of any unifications that may have happened</span>
<a name="line-49"></a>              <span class='hs-comment'>-- NB: We do not do any defaulting when inferring a type, this can lead</span>
<a name="line-50"></a>              <span class='hs-comment'>-- to less polymorphic types, see Note [Default while Inferring]</span>
<a name="line-51"></a>
<a name="line-52"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tc_lcl_env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcRnMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>getLclEnv</span>
<a name="line-53"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcl_untch</span> <span class='hs-varid'>tc_lcl_env</span>
<a name="line-54"></a>             <span class='hs-varid'>wanted_transformed</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropDerivedWC</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span>
<a name="line-55"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>quant_pred_candidates</span>   <span class='hs-comment'>-- Fully zonked</span>
<a name="line-56"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span>
<a name="line-57"></a>              <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>   <span class='hs-comment'>-- See Note [Quantification with errors]</span>
<a name="line-58"></a>                               <span class='hs-comment'>-- NB: must include derived errors in this test, </span>
<a name="line-59"></a>                               <span class='hs-comment'>--     hence "incl_derivs"</span>
<a name="line-60"></a>
<a name="line-61"></a>              <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>quant_cand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>approximateWC</span> <span class='hs-varid'>wanted_transformed</span>
<a name="line-62"></a>                            <span class='hs-varid'>meta_tvs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>varSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfCts</span> <span class='hs-varid'>quant_cand</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-63"></a>                      <span class='hs-layout'>;</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>
<a name="line-64"></a>                      <span class='hs-layout'>;</span> <span class='hs-varid'>null_ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcEvBinds</span>
<a name="line-65"></a>                            <span class='hs-comment'>-- Miminise quant_cand.  We are not interested in any evidence</span>
<a name="line-66"></a>                            <span class='hs-comment'>-- produced, because we are going to simplify wanted_transformed</span>
<a name="line-67"></a>                            <span class='hs-comment'>-- again later. All we want here is the predicates over which to</span>
<a name="line-68"></a>                            <span class='hs-comment'>-- quantify.  </span>
<a name="line-69"></a>                            <span class='hs-comment'>--</span>
<a name="line-70"></a>                            <span class='hs-comment'>-- If any meta-tyvar unifications take place (unlikely), we'll</span>
<a name="line-71"></a>                            <span class='hs-comment'>-- pick that up later.</span>
<a name="line-72"></a>
<a name="line-73"></a>                      <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>flats</span><span class='hs-layout'>,</span> <span class='hs-sel'>_insols</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSWithEvBinds</span> <span class='hs-varid'>null_ev_binds_var</span> <span class='hs-varop'>$</span>
<a name="line-74"></a>                        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>promoteAndDefaultTyVar</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>gbl_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>meta_tvs</span>
<a name="line-75"></a>                                 <span class='hs-comment'>-- See Note [Promote _and_ default when inferring]</span>
<a name="line-76"></a>                           <span class='hs-layout'>;</span> <span class='hs-sel'>_implics</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveInteract</span> <span class='hs-varid'>quant_cand</span>
<a name="line-77"></a>                           <span class='hs-layout'>;</span> <span class='hs-varid'>getInertUnsolved</span> <span class='hs-layout'>}</span>
<a name="line-78"></a>
<a name="line-79"></a>                      <span class='hs-layout'>;</span> <span class='hs-varid'>flats'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkFlats</span> <span class='hs-varid'>null_ev_binds_var</span> <span class='hs-varid'>untch</span> <span class='hs-varop'>$</span>
<a name="line-80"></a>                                  <span class='hs-varid'>filterBag</span> <span class='hs-varid'>isWantedCt</span> <span class='hs-varid'>flats</span>
<a name="line-81"></a>                           <span class='hs-comment'>-- The quant_cand were already fully zonked, so this zonkFlats</span>
<a name="line-82"></a>                           <span class='hs-comment'>-- really only unflattens the flattening that solveInteract</span>
<a name="line-83"></a>                           <span class='hs-comment'>-- may have done (Trac #8889).  </span>
<a name="line-84"></a>                           <span class='hs-comment'>-- E.g. quant_cand = F a, where F :: * -&gt; Constraint</span>
<a name="line-85"></a>                           <span class='hs-comment'>--      We'll flatten to   (alpha, F a ~ alpha)</span>
<a name="line-86"></a>                           <span class='hs-comment'>-- fail to make any further progress and must unflatten again </span>
<a name="line-87"></a>
<a name="line-88"></a>                      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ctPred</span> <span class='hs-varop'>$</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>flats'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-89"></a>
<a name="line-90"></a>       <span class='hs-comment'>-- NB: quant_pred_candidates is already the fixpoint of any</span>
<a name="line-91"></a>       <span class='hs-comment'>--     unifications that may have happened</span>
<a name="line-92"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>gbl_tvs</span>        <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>
<a name="line-93"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM</span><span class='hs-varop'>.</span><span class='hs-varid'>zonkTyVarsAndFV</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-94"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>poly_qtvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>growThetaTyVars</span> <span class='hs-varid'>quant_pred_candidates</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-95"></a>                         <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-96"></a>             <span class='hs-varid'>pbound</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>quantifyPred</span> <span class='hs-varid'>poly_qtvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>quant_pred_candidates</span>
<a name="line-97"></a>
<a name="line-98"></a>             <span class='hs-comment'>-- Monomorphism restriction</span>
<a name="line-99"></a>             <span class='hs-varid'>constrained_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>pbound</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-100"></a>             <span class='hs-varid'>mr_bites</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>apply_mr</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>pbound</span><span class='hs-layout'>)</span>
<a name="line-101"></a>
<a name="line-102"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>bound</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>mr_bites</span>
<a name="line-103"></a>                          <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>qtvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>quantifyTyVars</span> <span class='hs-varid'>constrained_tvs</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-104"></a>                                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-105"></a>                          <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>qtvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>quantifyTyVars</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>poly_qtvs</span>
<a name="line-106"></a>                                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>pbound</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-107"></a>
<a name="line-108"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyWithApprox"</span> <span class='hs-varop'>$</span>
<a name="line-109"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"quant_pred_candidates ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>quant_pred_candidates</span>
<a name="line-110"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"gbl_tvs="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-111"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"zonked_tau_tvs="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-112"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"pbound ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pbound</span>
<a name="line-113"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"bbound ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bound</span>
<a name="line-114"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"poly_qtvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>poly_qtvs</span>
<a name="line-115"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"constrained_tvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>constrained_tvs</span>
<a name="line-116"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"mr_bites ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mr_bites</span>
<a name="line-117"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"qtvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtvs</span> <span class='hs-keyglyph'>]</span>
<a name="line-118"></a>
<a name="line-119"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>qtvs</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>bound</span>
<a name="line-120"></a>         <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"} simplifyInfer/no implication needed"</span> <span class='hs-varid'>empty</span>
<a name="line-121"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>emitConstraints</span> <span class='hs-varid'>wanted_transformed</span>
<a name="line-122"></a>                    <span class='hs-comment'>-- Includes insolubles (if -fdefer-type-errors)</span>
<a name="line-123"></a>                    <span class='hs-comment'>-- as well as flats and implications</span>
<a name="line-124"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>mr_bites</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcEvBinds</span> <span class='hs-varid'>ev_binds_var</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-125"></a>         <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-126"></a>
<a name="line-127"></a>      <span class='hs-layout'>{</span>     <span class='hs-comment'>-- Step 7) Emit an implication</span>
<a name="line-128"></a>         <span class='hs-keyword'>let</span> <span class='hs-varid'>minimal_flat_preds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMinimalBySCs</span> <span class='hs-varid'>bound</span>
<a name="line-129"></a>                  <span class='hs-comment'>-- See Note [Minimize by Superclasses]</span>
<a name="line-130"></a>             <span class='hs-varid'>skol_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InferSkol</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkSigmaTy</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>minimal_flat_preds</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-131"></a>                                   <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>name_taus</span> <span class='hs-keyglyph'>]</span>
<a name="line-132"></a>                        <span class='hs-comment'>-- Don't add the quantified variables here, because</span>
<a name="line-133"></a>                        <span class='hs-comment'>-- they are also bound in ic_skols and we want them to be</span>
<a name="line-134"></a>                        <span class='hs-comment'>-- tidied uniformly</span>
<a name="line-135"></a>
<a name="line-136"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>minimal_bound_ev_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcM</span><span class='hs-varop'>.</span><span class='hs-varid'>newEvVar</span> <span class='hs-varid'>minimal_flat_preds</span>
<a name="line-137"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>implic</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_untch</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pushUntouchables</span> <span class='hs-varid'>untch</span>
<a name="line-138"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>qtvs</span>
<a name="line-139"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_no_eqs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-140"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_fsks</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>  <span class='hs-comment'>-- wanted_tansformed arose only from solveWanteds</span>
<a name="line-141"></a>                                                 <span class='hs-comment'>-- hence no flatten-skolems (which come from givens)</span>
<a name="line-142"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>minimal_bound_ev_vars</span>
<a name="line-143"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanted_transformed</span>
<a name="line-144"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_insol</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-145"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-146"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_info</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skol_info</span>
<a name="line-147"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_env</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc_lcl_env</span> <span class='hs-layout'>}</span>
<a name="line-148"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitImplication</span> <span class='hs-varid'>implic</span>
<a name="line-149"></a>
<a name="line-150"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"} simplifyInfer/produced residual implication for quantification"</span> <span class='hs-varop'>$</span>
<a name="line-151"></a>             <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"implic ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>implic</span>
<a name="line-152"></a>                       <span class='hs-comment'>-- ic_skols, ic_given give rest of result</span>
<a name="line-153"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"qtvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtvs</span>
<a name="line-154"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"spb ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>quant_pred_candidates</span>
<a name="line-155"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"bound ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bound</span> <span class='hs-keyglyph'>]</span>
<a name="line-156"></a>
<a name="line-157"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>minimal_bound_ev_vars</span>
<a name="line-158"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>mr_bites</span><span class='hs-layout'>,</span>  <span class='hs-conid'>TcEvBinds</span> <span class='hs-varid'>ev_binds_var</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-159"></a>
<a name="line-160"></a><a name="quantifyPred"></a><span class='hs-definition'>quantifyPred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span>           <span class='hs-comment'>-- Quantifying over these</span>
<a name="line-161"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>   <span class='hs-comment'>-- True &lt;=&gt; quantify over this wanted</span>
<a name="line-162"></a><span class='hs-definition'>quantifyPred</span> <span class='hs-varid'>qtvs</span> <span class='hs-varid'>pred</span>
<a name="line-163"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isIPPred</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>  <span class='hs-comment'>-- Note [Inheriting implicit parameters]</span>
<a name="line-164"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>pred</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>qtvs</span>
</pre>\end{code}

Note [Inheriting implicit parameters]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider this:

        f x = (x::Int) + ?y

where f is *not* a top-level binding.
From the RHS of f we'll get the constraint (?y::Int).
There are two types we might infer for f:

        f :: Int -> Int

(so we get ?y from the context of f's definition), or

        f :: (?y::Int) => Int -> Int

At first you might think the first was better, because then
?y behaves like a free variable of the definition, rather than
having to be passed at each call site.  But of course, the WHOLE
IDEA is that ?y should be passed at each call site (that's what
dynamic binding means) so we'd better infer the second.

BOTTOM LINE: when *inferring types* you must quantify over implicit
parameters, *even if* they don't mention the bound type variables.
Reason: because implicit parameters, uniquely, have local instance
declarations. See the predicate quantifyPred.

Note [Quantification with errors]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If we find that the RHS of the definition has some absolutely-insoluble
constraints, we abandon all attempts to find a context to quantify
over, and instead make the function fully-polymorphic in whatever
type we have found.  For two reasons
  a) Minimise downstream errors
  b) Avoid spurious errors from this function

But NB that we must include *derived* errors in the check. Example:
    (a::*) ~ Int#
We get an insoluble derived error *~#, and we don't want to discard
it before doing the isInsolubleWC test!  (Trac #8262)

Note [Default while Inferring]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Our current plan is that defaulting only happens at simplifyTop and
not simplifyInfer.  This may lead to some insoluble deferred constraints
Example:

instance D g => C g Int b

constraint inferred = (forall b. 0 => C gamma alpha b) /\ Num alpha
type inferred       = gamma -> gamma

Now, if we try to default (alpha := Int) we will be able to refine the implication to
  (forall b. 0 => C gamma Int b)
which can then be simplified further to
  (forall b. 0 => D gamma)
Finally we /can/ approximate this implication with (D gamma) and infer the quantified
type:  forall g. D g => g -> g

Instead what will currently happen is that we will get a quantified type
(forall g. g -> g) and an implication:
       forall g. 0 => (forall b. 0 => C g alpha b) /\ Num alpha

which, even if the simplifyTop defaults (alpha := Int) we will still be left with an
unsolvable implication:
       forall g. 0 => (forall b. 0 => D g)

The concrete example would be:
       h :: C g a s => g -> a -> ST s a
       f (x::gamma) = (\_ -> x) (runST (h x (undefined::alpha)) + 1)

But it is quite tedious to do defaulting and resolve the implication constraints and
we have not observed code breaking because of the lack of defaulting in inference so
we don't do it for now.



Note [Minimize by Superclasses]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When we quantify over a constraint, in simplifyInfer we need to
quantify over a constraint that is minimal in some sense: For
instance, if the final wanted constraint is (Eq alpha, Ord alpha),
we'd like to quantify over Ord alpha, because we can just get Eq alpha
from superclass selection from Ord alpha. This minimization is what
mkMinimalBySCs does. Then, simplifyInfer uses the minimal constraint
to check the original wanted.


Note [Avoid unecessary constraint simplification]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    -------- NB NB NB (Jun 12) -------------
    This note not longer applies; see the notes with Trac #4361.
    But I'm leaving it in here so we remember the issue.)
    ----------------------------------------
When inferring the type of a let-binding, with simplifyInfer,
try to avoid unnecessarily simplifying class constraints.
Doing so aids sharing, but it also helps with delicate
situations like

   instance C t => C [t] where ..

   f :: C [t] => ....
   f x = let g y = ...(constraint C [t])...
         in ...
When inferring a type for 'g', we don't want to apply the
instance decl, because then we can't satisfy (C t).  So we
just notice that g isn't quantified over 't' and partition
the constraints before simplifying.

This only half-works, but then let-generalisation only half-works.


*********************************************************************************
*                                                                                 *
*                             RULES                                               *
*                                                                                 *
***********************************************************************************

See note [Simplifying RULE consraints] in TcRule

Note [RULE quanfification over equalities]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Decideing which equalities to quantify over is tricky:
 * We do not want to quantify over insoluble equalities (Int ~ Bool)
    (a) because we prefer to report a LHS type error
    (b) because if such things end up in 'givens' we get a bogus
        "inaccessible code" error

 * But we do want to quantify over things like (a ~ F b), where
   F is a type function.

The difficulty is that it's hard to tell what is insoluble!
So we see whether the simplificaiotn step yielded any type errors,
and if so refrain from quantifying over *any* equalites.

\begin{code}
<pre><a name="line-1"></a><a name="simplifyRule"></a><span class='hs-definition'>simplifyRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleName</span>
<a name="line-2"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>       <span class='hs-comment'>-- Constraints from LHS</span>
<a name="line-3"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>       <span class='hs-comment'>-- Constraints from RHS</span>
<a name="line-4"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- LHS evidence varaibles</span>
<a name="line-5"></a><span class='hs-comment'>-- See Note [Simplifying RULE constraints] in TcRule</span>
<a name="line-6"></a><span class='hs-definition'>simplifyRule</span> <span class='hs-varid'>name</span> <span class='hs-varid'>lhs_wanted</span> <span class='hs-varid'>rhs_wanted</span>
<a name="line-7"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>         <span class='hs-comment'>-- We allow ourselves to unify environment</span>
<a name="line-8"></a>                 <span class='hs-comment'>-- variables: runTcS runs with NoUntouchables</span>
<a name="line-9"></a>         <span class='hs-layout'>(</span><span class='hs-varid'>resid_wanted</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>lhs_wanted</span> <span class='hs-varop'>`andWC`</span> <span class='hs-varid'>rhs_wanted</span><span class='hs-layout'>)</span>
<a name="line-10"></a>                              <span class='hs-comment'>-- Post: these are zonked and unflattened</span>
<a name="line-11"></a>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_lhs_flats</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkCts</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>lhs_wanted</span><span class='hs-layout'>)</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>q_cts</span><span class='hs-layout'>,</span> <span class='hs-varid'>non_q_cts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-varid'>quantify_me</span> <span class='hs-varid'>zonked_lhs_flats</span>
<a name="line-14"></a>             <span class='hs-varid'>quantify_me</span>  <span class='hs-comment'>-- Note [RULE quantification over equalities]</span>
<a name="line-15"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>resid_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quantify_insol</span>
<a name="line-16"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quantify_normal</span>
<a name="line-17"></a>
<a name="line-18"></a>             <span class='hs-varid'>quantify_insol</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEqPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-19"></a>
<a name="line-20"></a>             <span class='hs-varid'>quantify_normal</span> <span class='hs-varid'>ct</span>
<a name="line-21"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EqPred</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-22"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>t1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>
<a name="line-23"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-24"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-25"></a>
<a name="line-26"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyRule"</span> <span class='hs-varop'>$</span>
<a name="line-27"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"LHS of rule"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>doubleQuotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ftext</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-28"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"zonked_lhs_flats"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_lhs_flats</span>
<a name="line-29"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"q_cts"</span>      <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>q_cts</span>
<a name="line-30"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"non_q_cts"</span>  <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>non_q_cts</span> <span class='hs-keyglyph'>]</span>
<a name="line-31"></a>
<a name="line-32"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvId</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ctEvidence</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>q_cts</span><span class='hs-layout'>)</span>
<a name="line-33"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>lhs_wanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>non_q_cts</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}


*********************************************************************************
*                                                                                 *
*                                 Main Simplifier                                 *
*                                                                                 *
***********************************************************************************

Note [Deferring coercion errors to runtime]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
While developing, sometimes it is desirable to allow compilation to succeed even
if there are type errors in the code. Consider the following case:

  module Main where

  a :: Int
  a = 'a'

  main = print "b"

Even though `a` is ill-typed, it is not used in the end, so if all that we're
interested in is `main` it is handy to be able to ignore the problems in `a`.

Since we treat type equalities as evidence, this is relatively simple. Whenever
we run into a type mismatch in TcUnify, we normally just emit an error. But it
is always safe to defer the mismatch to the main constraint solver. If we do
that, `a` will get transformed into

  co :: Int ~ Char
  co = ...

  a :: Int
  a = 'a' `cast` co

The constraint solver would realize that `co` is an insoluble constraint, and
emit an error with `reportUnsolved`. But we can also replace the right-hand side
of `co` with `error "Deferred type error: Int ~ Char"`. This allows the program
to compile, and it will run fine unless we evaluate `a`. This is what
`deferErrorsToRuntime` does.

It does this by keeping track of which errors correspond to which coercion
in TcErrors (with ErrEnv). TcErrors.reportTidyWanteds does not print the errors
and does not fail if -fdefer-type-errors is on, so that we can continue
compilation. The errors are turned into warnings in `reportUnsolved`.

Note [Zonk after solving]
~~~~~~~~~~~~~~~~~~~~~~~~~
We zonk the result immediately after constraint solving, for two reasons:

a) because zonkWC generates evidence, and this is the moment when we
   have a suitable evidence variable to hand.

Note that *after* solving the constraints are typically small, so the
overhead is not great.

\begin{code}
<pre><a name="line-1"></a><a name="solveWantedsTcMWithEvBinds"></a><span class='hs-definition'>solveWantedsTcMWithEvBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>EvBindsVar</span>
<a name="line-2"></a>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-3"></a>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>
<a name="line-4"></a>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-5"></a><span class='hs-comment'>-- Returns a *zonked* result</span>
<a name="line-6"></a><span class='hs-comment'>-- We zonk when we finish primarily to un-flatten out any</span>
<a name="line-7"></a><span class='hs-comment'>-- flatten-skolems etc introduced by canonicalisation of</span>
<a name="line-8"></a><span class='hs-comment'>-- types involving type funuctions.  Happily the result</span>
<a name="line-9"></a><span class='hs-comment'>-- is typically much smaller than the input, indeed it is</span>
<a name="line-10"></a><span class='hs-comment'>-- often empty.</span>
<a name="line-11"></a><span class='hs-definition'>solveWantedsTcMWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wc</span> <span class='hs-varid'>tcs_action</span>
<a name="line-12"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"solveWantedsTcMWithEvBinds"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"wanted="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wc</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wc2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcs_action</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-14"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonkWC</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wc2</span> <span class='hs-layout'>}</span>
<a name="line-15"></a>         <span class='hs-comment'>-- See Note [Zonk after solving]</span>
<a name="line-16"></a>
<a name="line-17"></a><a name="solveWantedsTcM"></a><span class='hs-definition'>solveWantedsTcM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-18"></a><span class='hs-comment'>-- Zonk the input constraints, and simplify them</span>
<a name="line-19"></a><span class='hs-comment'>-- Return the evidence binds in the BagEvBinds result</span>
<a name="line-20"></a><span class='hs-comment'>-- Discards all Derived stuff in result</span>
<a name="line-21"></a><span class='hs-comment'>-- Postcondition: fully zonked and unflattened constraints</span>
<a name="line-22"></a><span class='hs-definition'>solveWantedsTcM</span> <span class='hs-varid'>wanted</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcEvBinds</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanteds'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcMWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wanted</span> <span class='hs-varid'>solve_wanteds_and_drop</span>
<a name="line-25"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcRnMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>getTcEvBinds</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-26"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wanteds'</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-27"></a>
<a name="line-28"></a><a name="solve_wanteds_and_drop"></a><span class='hs-definition'>solve_wanteds_and_drop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>
<a name="line-29"></a><span class='hs-comment'>-- Since solve_wanteds returns the residual WantedConstraints,</span>
<a name="line-30"></a><span class='hs-comment'>-- it should always be called within a runTcS or something similar,</span>
<a name="line-31"></a><span class='hs-definition'>solve_wanteds_and_drop</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solve_wanteds</span> <span class='hs-varid'>wanted</span>
<a name="line-32"></a>                                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>dropDerivedWC</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-33"></a>
<a name="line-34"></a><a name="solve_wanteds"></a><span class='hs-definition'>solve_wanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-35"></a><span class='hs-comment'>-- so that the inert set doesn't mindlessly propagate.</span>
<a name="line-36"></a><span class='hs-comment'>-- NB: wc_flats may be wanted /or/ derived now</span>
<a name="line-37"></a><span class='hs-definition'>solve_wanteds</span> <span class='hs-varid'>wanted</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flats</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-38"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-39"></a>
<a name="line-40"></a>         <span class='hs-comment'>-- Try the flat bit, including insolubles. Solving insolubles a</span>
<a name="line-41"></a>         <span class='hs-comment'>-- second time round is a bit of a waste; but the code is simple</span>
<a name="line-42"></a>         <span class='hs-comment'>-- and the program is wrong anyway, and we don't run the danger</span>
<a name="line-43"></a>         <span class='hs-comment'>-- of adding Derived insolubles twice; see</span>
<a name="line-44"></a>         <span class='hs-comment'>-- TcSMonad Note [Do not add duplicate derived insolubles]</span>
<a name="line-45"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveFlats {"</span> <span class='hs-varid'>empty</span>
<a name="line-46"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_flats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flats</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>insols</span>
<a name="line-47"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>impls_from_flats</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveInteract</span> <span class='hs-varid'>all_flats</span>
<a name="line-48"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveFlats end }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>impls_from_flats</span><span class='hs-layout'>)</span>
<a name="line-49"></a>
<a name="line-50"></a>       <span class='hs-comment'>-- solve_wanteds iterates when it is able to float equalities</span>
<a name="line-51"></a>       <span class='hs-comment'>-- out of one or more of the implications.</span>
<a name="line-52"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simpl_loop</span> <span class='hs-num'>1</span> <span class='hs-layout'>(</span><span class='hs-varid'>implics</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>impls_from_flats</span><span class='hs-layout'>)</span>
<a name="line-53"></a>
<a name="line-54"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsolved_flats</span><span class='hs-layout'>,</span> <span class='hs-varid'>insoluble_flats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getInertUnsolved</span>
<a name="line-55"></a>
<a name="line-56"></a>        <span class='hs-comment'>-- We used to unflatten here but now we only do it once at top-level</span>
<a name="line-57"></a>        <span class='hs-comment'>-- during zonking -- see Note [Unflattening while zonking] in TcMType</span>
<a name="line-58"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-59"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-60"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insoluble_flats</span> <span class='hs-layout'>}</span>
<a name="line-61"></a>
<a name="line-62"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>bb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcEvBindsMap</span>
<a name="line-63"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSTyBindsMap</span>
<a name="line-64"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds }"</span> <span class='hs-varop'>$</span>
<a name="line-65"></a>                 <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_flats   ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-66"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_implics ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-67"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"current evbinds  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>bb</span><span class='hs-layout'>)</span>
<a name="line-68"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"current tybinds  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>vcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>varEnvElts</span> <span class='hs-varid'>tb</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-69"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"final wc ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>]</span>
<a name="line-70"></a>
<a name="line-71"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span> <span class='hs-layout'>}</span>
<a name="line-72"></a>
<a name="line-73"></a><a name="simpl_loop"></a><span class='hs-definition'>simpl_loop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-74"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span>
<a name="line-75"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-76"></a><span class='hs-definition'>simpl_loop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>implics</span>
<a name="line-77"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>10</span>
<a name="line-78"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: loop!"</span> <span class='hs-varid'>empty</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>implics</span>
<a name="line-79"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-80"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"simpl_loop, iteration"</span> <span class='hs-layout'>(</span><span class='hs-varid'>int</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-81"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floated_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveNestedImplications</span> <span class='hs-varid'>implics</span>
<a name="line-82"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>floated_eqs</span>
<a name="line-83"></a>         <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-84"></a>         <span class='hs-keyword'>else</span>
<a name="line-85"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>   <span class='hs-comment'>-- Put floated_eqs into the current inert set before looping</span>
<a name="line-86"></a>         <span class='hs-layout'>(</span><span class='hs-varid'>unifs_happened</span><span class='hs-layout'>,</span> <span class='hs-varid'>impls_from_eqs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>reportUnifications</span> <span class='hs-varop'>$</span>
<a name="line-87"></a>                                             <span class='hs-varid'>solveInteract</span> <span class='hs-varid'>floated_eqs</span>
<a name="line-88"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span>   <span class='hs-comment'>-- See Note [Cutting off simpl_loop]</span>
<a name="line-89"></a>              <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>impls_from_eqs</span> <span class='hs-varop'>&amp;&amp;</span>
<a name="line-90"></a>              <span class='hs-varid'>not</span> <span class='hs-varid'>unifs_happened</span> <span class='hs-varop'>&amp;&amp;</span>                 <span class='hs-comment'>-- (a)</span>
<a name="line-91"></a>              <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>anyBag</span> <span class='hs-varid'>isCFunEqCan</span> <span class='hs-varid'>floated_eqs</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- (b)</span>
<a name="line-92"></a>         <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-93"></a>         <span class='hs-keyword'>else</span> <span class='hs-varid'>simpl_loop</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsolved_implics</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>impls_from_eqs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-94"></a>
<a name="line-95"></a><a name="solveNestedImplications"></a><span class='hs-definition'>solveNestedImplications</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span>
<a name="line-96"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-97"></a><span class='hs-comment'>-- Precondition: the TcS inerts may contain unsolved flats which have</span>
<a name="line-98"></a><span class='hs-comment'>-- to be converted to givens before we go inside a nested implication.</span>
<a name="line-99"></a><span class='hs-definition'>solveNestedImplications</span> <span class='hs-varid'>implics</span>
<a name="line-100"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implics</span>
<a name="line-101"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span>
<a name="line-102"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-103"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inerts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-104"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>thinner_inerts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>prepareInertsForImplications</span> <span class='hs-varid'>inerts</span>
<a name="line-105"></a>                 <span class='hs-comment'>-- See Note [Preparing inert set for implications]</span>
<a name="line-106"></a>
<a name="line-107"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveNestedImplications starting {"</span> <span class='hs-varop'>$</span>
<a name="line-108"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"original inerts = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inerts</span>
<a name="line-109"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"thinner_inerts  = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>thinner_inerts</span> <span class='hs-keyglyph'>]</span>
<a name="line-110"></a>
<a name="line-111"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floated_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span>
<a name="line-112"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatMapBagPairM</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveImplication</span> <span class='hs-varid'>thinner_inerts</span><span class='hs-layout'>)</span> <span class='hs-varid'>implics</span>
<a name="line-113"></a>
<a name="line-114"></a>       <span class='hs-comment'>-- ... and we are back in the original TcS inerts</span>
<a name="line-115"></a>       <span class='hs-comment'>-- Notice that the original includes the _insoluble_flats so it was safe to ignore</span>
<a name="line-116"></a>       <span class='hs-comment'>-- them in the beginning of this function.</span>
<a name="line-117"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveNestedImplications end }"</span> <span class='hs-varop'>$</span>
<a name="line-118"></a>                  <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"all floated_eqs ="</span>  <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>floated_eqs</span>
<a name="line-119"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_implics ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>]</span>
<a name="line-120"></a>
<a name="line-121"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floated_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-122"></a>
<a name="line-123"></a><a name="solveImplication"></a><span class='hs-definition'>solveImplication</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertSet</span>
<a name="line-124"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Implication</span>    <span class='hs-comment'>-- Wanted</span>
<a name="line-125"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- All wanted or derived floated equalities: var = type</span>
<a name="line-126"></a>                         <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Unsolved rest (always empty or singleton)</span>
<a name="line-127"></a><span class='hs-comment'>-- Precondition: The TcS monad contains an empty worklist and given-only inerts</span>
<a name="line-128"></a><span class='hs-comment'>-- which after trying to solve this implication we must restore to their original value</span>
<a name="line-129"></a><span class='hs-definition'>solveImplication</span> <span class='hs-varid'>inerts</span>
<a name="line-130"></a>     <span class='hs-varid'>imp</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_untch</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>untch</span>
<a name="line-131"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds</span>
<a name="line-132"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skols</span>
<a name="line-133"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_fsks</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_fsks</span>
<a name="line-134"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>givens</span>
<a name="line-135"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanteds</span>
<a name="line-136"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_info</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info</span>
<a name="line-137"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_env</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-138"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span>
<a name="line-139"></a>
<a name="line-140"></a>         <span class='hs-comment'>-- Solve the nested constraints</span>
<a name="line-141"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>no_given_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_fsks</span><span class='hs-layout'>,</span> <span class='hs-varid'>residual_wanted</span><span class='hs-layout'>)</span>
<a name="line-142"></a>            <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestImplicTcS</span> <span class='hs-varid'>ev_binds</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>inerts</span> <span class='hs-varop'>$</span>
<a name="line-143"></a>               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>no_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_fsks</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveInteractGiven</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkGivenLoc</span> <span class='hs-varid'>info</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-144"></a>                                                             <span class='hs-varid'>old_fsks</span> <span class='hs-varid'>givens</span>
<a name="line-145"></a>
<a name="line-146"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>residual_wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solve_wanteds</span> <span class='hs-varid'>wanteds</span>
<a name="line-147"></a>                        <span class='hs-comment'>-- solve_wanteds, *not* solve_wanteds_and_drop, because</span>
<a name="line-148"></a>                        <span class='hs-comment'>-- we want to retain derived equalities so we can float</span>
<a name="line-149"></a>                        <span class='hs-comment'>-- them out in floatEqualities</span>
<a name="line-150"></a>
<a name="line-151"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>no_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_fsks</span><span class='hs-layout'>,</span> <span class='hs-varid'>residual_wanted</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-152"></a>
<a name="line-153"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floated_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_wanted</span><span class='hs-layout'>)</span>
<a name="line-154"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>floatEqualities</span> <span class='hs-layout'>(</span><span class='hs-varid'>skols</span> <span class='hs-varop'>++</span> <span class='hs-varid'>new_fsks</span><span class='hs-layout'>)</span> <span class='hs-varid'>no_given_eqs</span> <span class='hs-varid'>residual_wanted</span>
<a name="line-155"></a>
<a name="line-156"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>res_implic</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>final_wanted</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>no_given_eqs</span>
<a name="line-157"></a>                        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span>  <span class='hs-comment'>-- Reason for the no_given_eqs: we don't want to</span>
<a name="line-158"></a>                                    <span class='hs-comment'>-- lose the "inaccessible code" error message</span>
<a name="line-159"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-160"></a>                        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>imp</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_fsks</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_fsks</span>
<a name="line-161"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>ic_no_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>no_given_eqs</span>
<a name="line-162"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropDerivedWC</span> <span class='hs-varid'>final_wanted</span>
<a name="line-163"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>ic_insol</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>final_wanted</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-164"></a>
<a name="line-165"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>evbinds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcEvBindsMap</span>
<a name="line-166"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication end }"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-167"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"no_given_eqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>no_given_eqs</span>
<a name="line-168"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"floated_eqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>floated_eqs</span>
<a name="line-169"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"new_fsks ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>new_fsks</span>
<a name="line-170"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"res_implic ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>res_implic</span>
<a name="line-171"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"implication evbinds = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>evbinds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-172"></a>
<a name="line-173"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floated_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_implic</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Cutting off simpl_loop]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
It is very important not to iterate in simpl_loop unless there is a chance
of progress.  Trac #8474 is a classic example:

  * There's a deeply-nested chain of implication constraints.
       ?x:alpha => ?y1:beta1 => ... ?yn:betan => [W] ?x:Int

  * From the innermost one we get a [D] alpha ~ Int,
    but alpha is untouchable until we get out to the outermost one

  * We float [D] alpha~Int out (it is in floated_eqs), but since alpha
    is untouchable, the solveInteract in simpl_loop makes no progress

  * So there is no point in attempting to re-solve
       ?yn:betan => [W] ?x:Int
    because we'll just get the same [D] again

  * If we *do* re-solve, we'll get an ininite loop. It is cut off by
    the fixed bound of 10, but solving the next takes 10*10*...*10 (ie
    exponentially many) iterations!

Conclusion: we should iterate simpl_loop iff we will get more 'givens'
in the inert set when solving the nested implications.  That is the
result of prepareInertsForImplications is larger.  How can we tell
this?

Consider floated_eqs (all wanted or derived):

(a) [W/D] CTyEqCan (a ~ ty).  This can give rise to a new given only by causing
    a unification. So we count those unifications.

(b) [W] CFunEqCan (F tys ~ xi).  Even though these are wanted, they
    are pushed in as givens by prepareInertsForImplications.  See Note
    [Preparing inert set for implications] in TcSMonad.  But because
    of that very fact, we won't generate another copy if we iterate
    simpl_loop.  So we iterate if there any of these

\begin{code}
<pre><a name="line-1"></a><a name="floatEqualities"></a><span class='hs-definition'>floatEqualities</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-2"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-comment'>-- Post: The returned floated constraints (Cts) are only Wanted or Derived</span>
<a name="line-4"></a><span class='hs-comment'>-- and come from the input wanted ev vars or deriveds</span>
<a name="line-5"></a><span class='hs-comment'>-- Also performs some unifications, adding to monadically-carried ty_binds</span>
<a name="line-6"></a><span class='hs-comment'>-- These will be used when processing floated_eqs later</span>
<a name="line-7"></a><span class='hs-definition'>floatEqualities</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>no_given_eqs</span> <span class='hs-varid'>wanteds</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flats</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>no_given_eqs</span>  <span class='hs-comment'>-- There are some given equalities, so don't float</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- Note [Float Equalities out of Implications]</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-11"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>remaining_flats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>flats</span>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>getUntouchables</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>promoteTyVar</span> <span class='hs-varid'>untch</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>varSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfCts</span> <span class='hs-varid'>float_eqs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-14"></a>             <span class='hs-comment'>-- See Note [Promoting unification variables]</span>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ty_binds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSTyBindsMap</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"floatEqualities"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Flats ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>flats</span>
<a name="line-17"></a>                                          <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Floated eqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>float_eqs</span>
<a name="line-18"></a>                                          <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Ty binds ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty_binds</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanteds</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>remaining_flats</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-20"></a>  <span class='hs-keyword'>where</span>
<a name="line-21"></a>      <span class='hs-comment'>-- See Note [Float equalities from under a skolem binding]</span>
<a name="line-22"></a>    <span class='hs-varid'>skol_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fixVarSet</span> <span class='hs-varid'>mk_next</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>skols</span><span class='hs-layout'>)</span>
<a name="line-23"></a>    <span class='hs-varid'>mk_next</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-varid'>grow_one</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>flats</span>
<a name="line-24"></a>    <span class='hs-varid'>grow_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs</span>
<a name="line-25"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>intersectsVarSet</span> <span class='hs-varid'>tvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>xis</span><span class='hs-layout'>)</span>
<a name="line-26"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>rhs</span>
<a name="line-27"></a>    <span class='hs-varid'>grow_one</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-28"></a>
<a name="line-29"></a>    <span class='hs-varid'>is_floatable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-30"></a>    <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isEqPred</span> <span class='hs-varid'>pred</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>skol_set</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>pred</span>
<a name="line-31"></a>       <span class='hs-keyword'>where</span>
<a name="line-32"></a>         <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span>
<a name="line-33"></a>
<a name="line-34"></a><a name="promoteTyVar"></a><span class='hs-definition'>promoteTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Untouchables</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-35"></a><span class='hs-comment'>-- When we float a constraint out of an implication we must restore</span>
<a name="line-36"></a><span class='hs-comment'>-- invariant (MetaTvInv) in Note [Untouchable type variables] in TcType</span>
<a name="line-37"></a><span class='hs-comment'>-- See Note [Promoting unification variables]</span>
<a name="line-38"></a><span class='hs-definition'>promoteTyVar</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>tv</span>
<a name="line-39"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFloatedTouchableMetaTyVar</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>tv</span>
<a name="line-40"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cloned_tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>cloneMetaTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-41"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs_tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setMetaTyVarUntouchables</span> <span class='hs-varid'>cloned_tv</span> <span class='hs-varid'>untch</span>
<a name="line-42"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>tv</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>rhs_tv</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-43"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-44"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-45"></a>
<a name="line-46"></a><a name="promoteAndDefaultTyVar"></a><span class='hs-definition'>promoteAndDefaultTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Untouchables</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-47"></a><span class='hs-comment'>-- See Note [Promote _and_ default when inferring]</span>
<a name="line-48"></a><span class='hs-definition'>promoteAndDefaultTyVar</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>tv</span>
<a name="line-49"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tv1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-50"></a>                <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>tv</span>
<a name="line-51"></a>                <span class='hs-keyword'>else</span> <span class='hs-varid'>defaultTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-52"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>promoteTyVar</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>tv1</span> <span class='hs-layout'>}</span>
<a name="line-53"></a>
<a name="line-54"></a><a name="defaultTyVar"></a><span class='hs-definition'>defaultTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>TcTyVar</span>
<a name="line-55"></a><span class='hs-comment'>-- Precondition: MetaTyVars only</span>
<a name="line-56"></a><span class='hs-comment'>-- See Note [DefaultTyVar]</span>
<a name="line-57"></a><span class='hs-definition'>defaultTyVar</span> <span class='hs-varid'>the_tv</span>
<a name="line-58"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>default_k</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>defaultKind_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span>
<a name="line-59"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tv'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>cloneMetaTyVar</span> <span class='hs-varid'>the_tv</span>
<a name="line-60"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>new_tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setTyVarKind</span> <span class='hs-varid'>tv'</span> <span class='hs-varid'>default_k</span>
<a name="line-61"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"defaultTyVar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>the_tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>new_tv</span><span class='hs-layout'>)</span>
<a name="line-62"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>the_tv</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>new_tv</span><span class='hs-layout'>)</span>
<a name="line-63"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>new_tv</span> <span class='hs-layout'>}</span>
<a name="line-64"></a>             <span class='hs-comment'>-- Why not directly derived_pred = mkTcEqPred k default_k?</span>
<a name="line-65"></a>             <span class='hs-comment'>-- See Note [DefaultTyVar]</span>
<a name="line-66"></a>             <span class='hs-comment'>-- We keep the same Untouchables on tv'</span>
<a name="line-67"></a>
<a name="line-68"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>the_tv</span>    <span class='hs-comment'>-- The common case</span>
<a name="line-69"></a>
<a name="line-70"></a><a name="approximateWC"></a><span class='hs-definition'>approximateWC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-71"></a><span class='hs-comment'>-- Postcondition: Wanted or Derived Cts</span>
<a name="line-72"></a><span class='hs-comment'>-- See Note [ApproximateWC]</span>
<a name="line-73"></a><span class='hs-definition'>approximateWC</span> <span class='hs-varid'>wc</span>
<a name="line-74"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float_wc</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>wc</span>
<a name="line-75"></a>  <span class='hs-keyword'>where</span>
<a name="line-76"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-77"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flats</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-78"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterBag</span> <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>flats</span> <span class='hs-varop'>`unionBags`</span>
<a name="line-79"></a>        <span class='hs-varid'>do_bag</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_implic</span> <span class='hs-varid'>new_trapping_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>implics</span>
<a name="line-80"></a>      <span class='hs-keyword'>where</span>
<a name="line-81"></a>        <span class='hs-varid'>new_trapping_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fixVarSet</span> <span class='hs-varid'>grow</span> <span class='hs-varid'>trapping_tvs</span>
<a name="line-82"></a>        <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>new_trapping_tvs</span>
<a name="line-83"></a>
<a name="line-84"></a>        <span class='hs-varid'>grow</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-varid'>grow_one</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>flats</span>
<a name="line-85"></a>        <span class='hs-varid'>grow_one</span> <span class='hs-varid'>ct</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ct_tvs</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>ct_tvs</span>
<a name="line-86"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-87"></a>                        <span class='hs-keyword'>where</span>
<a name="line-88"></a>                          <span class='hs-varid'>ct_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span>
<a name="line-89"></a>
<a name="line-90"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-91"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-varid'>imp</span>
<a name="line-92"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ic_no_eqs</span> <span class='hs-varid'>imp</span>                 <span class='hs-comment'>-- No equalities, so float</span>
<a name="line-93"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float_wc</span> <span class='hs-varid'>new_trapping_tvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_wanted</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span>
<a name="line-94"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                     <span class='hs-comment'>-- Don't float out of equalities</span>
<a name="line-95"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyCts</span>                      <span class='hs-comment'>-- See Note [ApproximateWC]</span>
<a name="line-96"></a>      <span class='hs-keyword'>where</span>
<a name="line-97"></a>        <span class='hs-varid'>new_trapping_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-varop'>`extendVarSetList`</span> <span class='hs-varid'>ic_skols</span> <span class='hs-varid'>imp</span>
<a name="line-98"></a>                                        <span class='hs-varop'>`extendVarSetList`</span> <span class='hs-varid'>ic_fsks</span> <span class='hs-varid'>imp</span>
<a name="line-99"></a>    <span class='hs-varid'>do_bag</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span>
<a name="line-100"></a>    <span class='hs-varid'>do_bag</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionBags</span><span class='hs-varop'>.</span><span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyBag</span>
</pre>\end{code}

Note [ApproximateWC]
~~~~~~~~~~~~~~~~~~~~
approximateWC takes a constraint, typically arising from the RHS of a
let-binding whose type we are *inferring*, and extracts from it some
*flat* constraints that we might plausibly abstract over.  Of course
the top-level flat constraints are plausible, but we also float constraints
out from inside, if they are not captured by skolems.

The same function is used when doing type-class defaulting (see the call
to applyDefaultingRules) to extract constraints that that might be defaulted.

There are two caveats:

1.  We do *not* float anything out if the implication binds equality
    constraints, because that defeats the OutsideIn story.  Consider
       data T a where
         TInt :: T Int
         MkT :: T a

       f TInt = 3::Int

    We get the implication (a ~ Int => res ~ Int), where so far we've decided
      f :: T a -> res
    We don't want to float (res~Int) out because then we'll infer
      f :: T a -> Int
    which is only on of the possible types. (GHC 7.6 accidentally *did*
    float out of such implications, which meant it would happily infer
    non-principal types.)

2. We do not float out an inner constraint that shares a type variable
   (transitively) with one that is trapped by a skolem.  Eg
       forall a.  F a ~ beta, Integral beta
   We don't want to float out (Integral beta).  Doing so would be bad
   when defaulting, because then we'll default beta:=Integer, and that
   makes the error message much worse; we'd get
       Can't solve  F a ~ Integer
   rather than
       Can't solve  Integral (F a)

   Moreover, floating out these "contaminated" constraints doesn't help
   when generalising either. If we generalise over (Integral b), we still
   can't solve the retained implication (forall a. F a ~ b).  Indeed,
   arguably that too would be a harder error to understand.

Note [DefaultTyVar]
~~~~~~~~~~~~~~~~~~~
defaultTyVar is used on any un-instantiated meta type variables to
default the kind of OpenKind and ArgKind etc to *.  This is important
to ensure that instance declarations match.  For example consider

     instance Show (a->b)
     foo x = show (\_ -> True)

Then we'll get a constraint (Show (p ->q)) where p has kind ArgKind,
and that won't match the typeKind (*) in the instance decl.  See tests
tc217 and tc175.

We look only at touchable type variables. No further constraints
are going to affect these type variables, so it's time to do it by
hand.  However we aren't ready to default them fully to () or
whatever, because the type-class defaulting rules have yet to run.

An important point is that if the type variable tv has kind k and the
default is default_k we do not simply generate [D] (k ~ default_k) because:

   (1) k may be ArgKind and default_k may be * so we will fail

   (2) We need to rewrite all occurrences of the tv to be a type
       variable with the right kind and we choose to do this by rewriting
       the type variable /itself/ by a new variable which does have the
       right kind.

Note [Promote _and_ default when inferring]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When we are inferring a type, we simplify the constraint, and then use
approximateWC to produce a list of candidate constraints.  Then we MUST

  a) Promote any meta-tyvars that have been floated out by
     approximateWC, to restore invariant (MetaTvInv) described in
     Note [Untouchable type variables] in TcType.

  b) Default the kind of any meta-tyyvars that are not mentioned in
     in the environment.

To see (b), suppose the constraint is (C ((a :: OpenKind) -> Int)), and we
have an instance (C ((x:*) -> Int)).  The instance doesn't match -- but it
should!  If we don't solve the constraint, we'll stupidly quantify over
(C (a->Int)) and, worse, in doing so zonkQuantifiedTyVar will quantify over
(b:*) instead of (a:OpenKind), which can lead to disaster; see Trac #7332.
Trac #7641 is a simpler example.

Note [Float Equalities out of Implications]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For ordinary pattern matches (including existentials) we float
equalities out of implications, for instance:
     data T where
       MkT :: Eq a => a -> T
     f x y = case x of MkT _ -> (y::Int)
We get the implication constraint (x::T) (y::alpha):
     forall a. [untouchable=alpha] Eq a => alpha ~ Int
We want to float out the equality into a scope where alpha is no
longer untouchable, to solve the implication!

But we cannot float equalities out of implications whose givens may
yield or contain equalities:

      data T a where
        T1 :: T Int
        T2 :: T Bool
        T3 :: T a

      h :: T a -> a -> Int

      f x y = case x of
                T1 -> y::Int
                T2 -> y::Bool
                T3 -> h x y

We generate constraint, for (x::T alpha) and (y :: beta):
   [untouchables = beta] (alpha ~ Int => beta ~ Int)   -- From 1st branch
   [untouchables = beta] (alpha ~ Bool => beta ~ Bool) -- From 2nd branch
   (alpha ~ beta)                                      -- From 3rd branch

If we float the equality (beta ~ Int) outside of the first implication and
the equality (beta ~ Bool) out of the second we get an insoluble constraint.
But if we just leave them inside the implications we unify alpha := beta and
solve everything.

Principle:
    We do not want to float equalities out which may
    need the given *evidence* to become soluble.

Consequence: classes with functional dependencies don't matter (since there is
no evidence for a fundep equality), but equality superclasses do matter (since
they carry evidence).

Note [When does an implication have given equalities?]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider an implication
   beta => alpha ~ Int
where beta is a unification variable that has already been unified
to () in an outer scope.  Then we can float the (alpha ~ Int) out
just fine. So when deciding whether the givens contain an equality,
we should canonicalise first, rather than just looking at the original
givens (Trac #8644).

This is the entire reason for the inert_no_eqs field in InertCans.
We initialise it to False before processing the Givens of an implication;
and set it to True when adding an inert equality in addInertCan.

However, when flattening givens, we generate given equalities like
  <F [a]> : F [a] ~ f,
with Refl evidence, and we *don't* want those to count as an equality
in the givens!  After all, the entire flattening business is just an
internal matter, and the evidence does not mention any of the 'givens'
of this implication.

So we set the flag to False when adding an equality
(TcSMonad.addInertCan) whose evidence whose CtOrigin is
FlatSkolOrigin; see TcSMonad.isFlatSkolEv.  Note that we may transform
the original flat-skol equality before adding it to the inerts, so
it's important that the transformation preserves origin (which
xCtEvidence and rewriteEvidence both do).  Example
     instance F [a] = Maybe a
     implication: C (F [a]) => blah
  We flatten (C (F [a])) to C fsk, with <F [a]> : F [a] ~ fsk
  Then we reduce the F [a] LHS, giving
       g22 = ax7 ; <F [a]>
       g22 : Maybe a ~ fsk
  And before adding g22 we'll re-orient it to an ordinary tyvar
  equality.  None of this should count as "adding a given equality".
  This really happens (Trac #8651).

An alternative we considered was to
  * Accumulate the new inert equalities (in TcSMonad.addInertCan)
  * In solveInteractGiven, check whether the evidence for the new
    equalities mentions any of the ic_givens of this implication.
This seems like the Right Thing, but it's more code, and more work
at runtime, so we are using the FlatSkolOrigin idea intead. It's less
obvious that it works, but I htink it does, and it's simple and efficient.


Note [Float equalities from under a skolem binding]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
You might worry about skolem escape with all this floating.
For example, consider
    [2] forall a. (a ~ F beta[2] delta,
                   Maybe beta[2] ~ gamma[1])

The (Maybe beta ~ gamma) doesn't mention 'a', so we float it, and
solve with gamma := beta. But what if later delta:=Int, and
  F b Int = b.
Then we'd get a ~ beta[2], and solve to get beta:=a, and now the
skolem has escaped!

But it's ok: when we float (Maybe beta[2] ~ gamma[1]), we promote beta[2]
to beta[1], and that means the (a ~ beta[1]) will be stuck, as it should be.

Previously we tried to "grow" the skol_set with the constraints, to get
all the tyvars that could *conceivably* unify with the skolems, but that
was far too conservative (Trac #7804). Example: this should be fine:
    f :: (forall a. a -> Proxy x -> Proxy (F x)) -> Int
    f = error "Urk" :: (forall a. a -> Proxy x -> Proxy (F x)) -> Int

BUT (sigh) we have to be careful.  Here are some edge cases:

a)    [2]forall a. (F a delta[1] ~ beta[2],   delta[1] ~ Maybe beta[2])
b)    [2]forall a. (F b ty ~ beta[2],         G beta[2] ~ gamma[2])
c)    [2]forall a. (F a ty ~ beta[2],         delta[1] ~ Maybe beta[2])

In (a) we *must* float out the second equality,
       else we can't solve at all (Trac #7804).

In (b) we *must not* float out the second equality.
       It will ultimately be solved (by flattening) in situ, but if we
       float it we'll promote beta,gamma, and render the first equality insoluble.

In (c) it would be OK to float the second equality but better not to.
       If we flatten we see (delta[1] ~ Maybe (F a ty)), which is a
       skolem-escape problem.  If we float the secodn equality we'll
       end up with (F a ty ~ beta'[1]), which is a less explicable error.

Hence we start with the skolems, grow them by the CFunEqCans, and
float ones that don't mention the grown variables.  Seems very ad hoc.

Note [Promoting unification variables]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When we float an equality out of an implication we must "promote" free
unification variables of the equality, in order to maintain Invariant
(MetaTvInv) from Note [Untouchable type variables] in TcType.  for the
leftover implication.

This is absolutely necessary. Consider the following example. We start
with two implications and a class with a functional dependency.

    class C x y | x -> y
    instance C [a] [a]

    (I1)      [untch=beta]forall b. 0 => F Int ~ [beta]
    (I2)      [untch=beta]forall c. 0 => F Int ~ [[alpha]] /\ C beta [c]

We float (F Int ~ [beta]) out of I1, and we float (F Int ~ [[alpha]]) out of I2.
They may react to yield that (beta := [alpha]) which can then be pushed inwards
the leftover of I2 to get (C [alpha] [a]) which, using the FunDep, will mean that
(alpha := a). In the end we will have the skolem 'b' escaping in the untouchable
beta! Concrete example is in indexed_types/should_fail/ExtraTcsUntch.hs:

    class C x y | x -> y where
     op :: x -> y -> ()

    instance C [a] [a]

    type family F a :: *

    h :: F Int -> ()
    h = undefined

    data TEx where
      TEx :: a -> TEx


    f (x::beta) =
        let g1 :: forall b. b -> ()
            g1 _ = h [x]
            g2 z = case z of TEx y -> (h [[undefined]], op x [y])
        in (g1 '3', g2 undefined)



Note [Solving Family Equations]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
After we are done with simplification we may be left with constraints of the form:
     [Wanted] F xis ~ beta
If 'beta' is a touchable unification variable not already bound in the TyBinds
then we'd like to create a binding for it, effectively "defaulting" it to be 'F xis'.

When is it ok to do so?
    1) 'beta' must not already be defaulted to something. Example:

           [Wanted] F Int  ~ beta   <~ Will default [beta := F Int]
           [Wanted] F Char ~ beta   <~ Already defaulted, can't default again. We
                                       have to report this as unsolved.

    2) However, we must still do an occurs check when defaulting (F xis ~ beta), to
       set [beta := F xis] only if beta is not among the free variables of xis.

    3) Notice that 'beta' can't be bound in ty binds already because we rewrite RHS
       of type family equations. See Inert Set invariants in TcInteract.

This solving is now happening during zonking, see Note [Unflattening while zonking]
in TcMType.


*********************************************************************************
*                                                                               *
*                          Defaulting and disamgiguation                        *
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="applyDefaultingRules"></a><span class='hs-definition'>applyDefaultingRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>
<a name="line-2"></a>  <span class='hs-comment'>-- True &lt;=&gt; I did some defaulting, reflected in ty_binds</span>
<a name="line-3"></a>
<a name="line-4"></a><span class='hs-comment'>-- Return some extra derived equalities, which express the</span>
<a name="line-5"></a><span class='hs-comment'>-- type-class default choice.</span>
<a name="line-6"></a><span class='hs-definition'>applyDefaultingRules</span> <span class='hs-varid'>wanteds</span>
<a name="line-7"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>wanteds</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"applyDefaultingRules { "</span> <span class='hs-varop'>$</span>
<a name="line-11"></a>                  <span class='hs-varid'>text</span> <span class='hs-str'>"wanteds ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-12"></a>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>info</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDefaultInfo</span>
<a name="line-14"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>groups</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findDefaultableGroups</span> <span class='hs-varid'>info</span> <span class='hs-varid'>wanteds</span>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"findDefaultableGroups"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"groups="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>groups</span>
<a name="line-16"></a>                                                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"info="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>info</span> <span class='hs-keyglyph'>]</span>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>something_happeneds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>disambigGroup</span> <span class='hs-varid'>default_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>groups</span>
<a name="line-18"></a>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"applyDefaultingRules }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>something_happeneds</span><span class='hs-layout'>)</span>
<a name="line-20"></a>
<a name="line-21"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>or</span> <span class='hs-varid'>something_happeneds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}



\begin{code}
<pre><a name="line-1"></a><a name="findDefaultableGroups"></a><span class='hs-definition'>findDefaultableGroups</span>
<a name="line-2"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-3"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>  <span class='hs-comment'>-- (Overloaded strings, extended default rules)</span>
<a name="line-4"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>              <span class='hs-comment'>-- Unsolved (wanted or derived)</span>
<a name="line-5"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span><span class='hs-conid'>Class</span><span class='hs-layout'>,</span><span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<a name="line-6"></a><span class='hs-definition'>findDefaultableGroups</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span><span class='hs-layout'>,</span> <span class='hs-varid'>extended_defaults</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>wanteds</span>
<a name="line-7"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>default_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultable_groups</span>
<a name="line-9"></a>  <span class='hs-keyword'>where</span>
<a name="line-10"></a>    <span class='hs-varid'>defaultable_groups</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>is_defaultable_group</span> <span class='hs-varid'>groups</span>
<a name="line-11"></a>    <span class='hs-varid'>groups</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>equivClasses</span> <span class='hs-varid'>cmp_tv</span> <span class='hs-varid'>unaries</span>
<a name="line-12"></a>    <span class='hs-varid'>unaries</span>     <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- (C tv) constraints</span>
<a name="line-13"></a>    <span class='hs-varid'>non_unaries</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>             <span class='hs-comment'>-- and *other* constraints</span>
<a name="line-14"></a>
<a name="line-15"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>unaries</span><span class='hs-layout'>,</span> <span class='hs-varid'>non_unaries</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionWith</span> <span class='hs-varid'>find_unary</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-16"></a>        <span class='hs-comment'>-- Finds unary type-class constraints</span>
<a name="line-17"></a>        <span class='hs-comment'>-- But take account of polykinded classes like Typeable,</span>
<a name="line-18"></a>        <span class='hs-comment'>-- which may look like (Typeable * (a:*))   (Trac #8931)</span>
<a name="line-19"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-varid'>cc</span>
<a name="line-20"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span><span class='hs-layout'>,</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getClassPredTys_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>cc</span><span class='hs-layout'>)</span>
<a name="line-21"></a>        <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>kinds</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>snocView</span> <span class='hs-varid'>tys</span>
<a name="line-22"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>all</span> <span class='hs-varid'>isKind</span> <span class='hs-varid'>kinds</span>
<a name="line-23"></a>        <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-24"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>tv</span>  <span class='hs-comment'>-- We might have runtime-skolems in GHCi, and</span>
<a name="line-25"></a>                          <span class='hs-comment'>-- we definitely don't want to try to assign to those!</span>
<a name="line-26"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc</span><span class='hs-layout'>,</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-27"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-varid'>cc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>cc</span>  <span class='hs-comment'>-- Non unary or non dictionary</span>
<a name="line-28"></a>
<a name="line-29"></a>    <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span>  <span class='hs-comment'>-- TyVars mentioned by non-unaries</span>
<a name="line-30"></a>    <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionVarSet</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tyVarsOfCt</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>non_unaries</span>
<a name="line-31"></a>
<a name="line-32"></a>    <span class='hs-varid'>cmp_tv</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>tv2</span>
<a name="line-33"></a>
<a name="line-34"></a>    <span class='hs-varid'>is_defaultable_group</span> <span class='hs-varid'>ds</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-35"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>b1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTyConableTyVar</span> <span class='hs-varid'>tv</span>  <span class='hs-comment'>-- Note [Avoiding spurious errors]</span>
<a name="line-36"></a>              <span class='hs-varid'>b2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span>
<a name="line-37"></a>              <span class='hs-varid'>b4</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultable_classes</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>cls</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>cls</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ds</span><span class='hs-keyglyph'>]</span>
<a name="line-38"></a>          <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>b1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>b2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>b4</span><span class='hs-layout'>)</span>
<a name="line-39"></a>    <span class='hs-varid'>is_defaultable_group</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"defaultable_group"</span>
<a name="line-40"></a>
<a name="line-41"></a>    <span class='hs-varid'>defaultable_classes</span> <span class='hs-varid'>clss</span>
<a name="line-42"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>extended_defaults</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isInteractiveClass</span> <span class='hs-varid'>clss</span>
<a name="line-43"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>is_std_class</span> <span class='hs-varid'>clss</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>clss</span><span class='hs-layout'>)</span>
<a name="line-44"></a>
<a name="line-45"></a>    <span class='hs-comment'>-- In interactive mode, or with -XExtendedDefaultRules,</span>
<a name="line-46"></a>    <span class='hs-comment'>-- we default Show a to Show () to avoid graututious errors on "show []"</span>
<a name="line-47"></a>    <span class='hs-varid'>isInteractiveClass</span> <span class='hs-varid'>cls</span>
<a name="line-48"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>classKey</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>showClassKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>eqClassKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>ordClassKey</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-49"></a>
<a name="line-50"></a>    <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNumericClass</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>isStringClassKey</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-51"></a>    <span class='hs-comment'>-- is_num_class adds IsString to the standard numeric classes,</span>
<a name="line-52"></a>    <span class='hs-comment'>-- when -foverloaded-strings is enabled</span>
<a name="line-53"></a>
<a name="line-54"></a>    <span class='hs-varid'>is_std_class</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStandardClass</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>isStringClassKey</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-55"></a>    <span class='hs-comment'>-- Similarly is_std_class</span>
<a name="line-56"></a>
<a name="line-57"></a><a name="disambigGroup"></a><span class='hs-comment'>------------------------------</span>
<a name="line-58"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>                  <span class='hs-comment'>-- The default types</span>
<a name="line-59"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- All classes of the form (C a)</span>
<a name="line-60"></a>                                         <span class='hs-comment'>--  sharing same type variable</span>
<a name="line-61"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>   <span class='hs-comment'>-- True &lt;=&gt; something happened, reflected in ty_binds</span>
<a name="line-62"></a>
<a name="line-63"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-conid'>[]</span>  <span class='hs-sel'>_grp</span>
<a name="line-64"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-65"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_ty</span><span class='hs-conop'>:</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>group</span>
<a name="line-66"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>group</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-67"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>success</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryTcS</span> <span class='hs-varop'>$</span> <span class='hs-comment'>-- Why tryTcS? If this attempt fails, we want to</span>
<a name="line-68"></a>                             <span class='hs-comment'>-- discard all side effects from the attempt</span>
<a name="line-69"></a>                    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>the_tv</span> <span class='hs-varid'>default_ty</span>
<a name="line-70"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>implics_from_defaulting</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveInteract</span> <span class='hs-varid'>wanteds</span>
<a name="line-71"></a>                       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span><span class='hs-layout'>(</span><span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implics_from_defaulting</span><span class='hs-layout'>)</span>
<a name="line-72"></a>                           <span class='hs-comment'>-- I am not certain if any implications can be generated</span>
<a name="line-73"></a>                           <span class='hs-comment'>-- but I am letting this fail aggressively if this ever happens.</span>
<a name="line-74"></a>
<a name="line-75"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>checkAllSolved</span> <span class='hs-layout'>}</span>
<a name="line-76"></a>
<a name="line-77"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>success</span> <span class='hs-keyword'>then</span>
<a name="line-78"></a>             <span class='hs-comment'>-- Success: record the type variable binding, and return</span>
<a name="line-79"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>the_tv</span> <span class='hs-varid'>default_ty</span>
<a name="line-80"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>wrapWarnTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>warnDefaulting</span> <span class='hs-varid'>wanteds</span> <span class='hs-varid'>default_ty</span>
<a name="line-81"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup succeeded }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-82"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-83"></a>         <span class='hs-keyword'>else</span>
<a name="line-84"></a>             <span class='hs-comment'>-- Failure: try with the next type</span>
<a name="line-85"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup failed, will try other default types }"</span>
<a name="line-86"></a>                           <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-87"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>disambigGroup</span> <span class='hs-varid'>default_tys</span> <span class='hs-varid'>group</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-88"></a>  <span class='hs-keyword'>where</span>
<a name="line-89"></a>    <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>group</span>
<a name="line-90"></a>    <span class='hs-varid'>wanteds</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>listToBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fstOf3</span> <span class='hs-varid'>group</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Avoiding spurious errors]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When doing the unification for defaulting, we check for skolem
type variables, and simply don't default them.  For example:
   f = (*)      -- Monomorphic
   g :: Num a => a -> a
   g x = f x x
Here, we get a complaint when checking the type signature for g,
that g isn't polymorphic enough; but then we get another one when
dealing with the (Num a) context arising from f's definition;
we try to unify a with Int (to default it), but find that it's
already been unified with the rigid variable from g's type sig

</body>
</html>
