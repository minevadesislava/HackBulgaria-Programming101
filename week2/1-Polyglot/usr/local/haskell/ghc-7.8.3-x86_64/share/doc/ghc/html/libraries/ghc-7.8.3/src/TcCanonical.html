<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcCanonical.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
\begin{code}
<pre><a name="line-1"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcCanonical</span><span class='hs-layout'>(</span>
<a name="line-2"></a>    <span class='hs-varid'>canonicalize</span><span class='hs-layout'>,</span> <span class='hs-varid'>emitWorkNC</span><span class='hs-layout'>,</span>
<a name="line-3"></a>    <span class='hs-conid'>StopOrContinue</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span>
<a name="line-4"></a> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnTypes</span>
<a name="line-9"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-10"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-11"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Kind</span>
<a name="line-12"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-13"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TypeRep</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>OccName</span><span class='hs-layout'>(</span> <span class='hs-conid'>OccName</span> <span class='hs-layout'>)</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>when</span> <span class='hs-layout'>)</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span><span class='hs-layout'>(</span> <span class='hs-conid'>DynFlags</span> <span class='hs-layout'>)</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSMonad</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>
<a name="line-25"></a>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Maybes</span><span class='hs-layout'>(</span> <span class='hs-varid'>catMaybes</span> <span class='hs-layout'>)</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
%*                      The Canonicaliser                               *
%*                                                                      *
%************************************************************************

Note [Canonicalization]
~~~~~~~~~~~~~~~~~~~~~~~

Canonicalization converts a flat constraint to a canonical form. It is
unary (i.e. treats individual constraints one at a time), does not do
any zonking, but lives in TcS monad because it needs to create fresh
variables (for flattening) and consult the inerts (for efficiency).

The execution plan for canonicalization is the following:

  1) Decomposition of equalities happens as necessary until we reach a
     variable or type family in one side. There is no decomposition step
     for other forms of constraints.

  2) If, when we decompose, we discover a variable on the head then we
     look at inert_eqs from the current inert for a substitution for this
     variable and contine decomposing. Hence we lazily apply the inert
     substitution if it is needed.

  3) If no more decomposition is possible, we deeply apply the substitution
     from the inert_eqs and continue with flattening.

  4) During flattening, we examine whether we have already flattened some
     function application by looking at all the CTyFunEqs with the same
     function in the inert set. The reason for deeply applying the inert
     substitution at step (3) is to maximise our chances of matching an
     already flattened family application in the inert.

The net result is that a constraint coming out of the canonicalization
phase cannot be rewritten any further from the inerts (but maybe /it/ can
rewrite an inert or still interact with an inert in a further phase in the
simplifier.

\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a><a name="StopOrContinue"></a><span class='hs-comment'>-- Informative results of canonicalization</span>
<a name="line-3"></a><a name="StopOrContinue"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ContinueWith</span> <span class='hs-conid'>Ct</span>   <span class='hs-comment'>-- Either no canonicalization happened, or if some did</span>
<a name="line-5"></a>                      <span class='hs-comment'>-- happen, it is still safe to just keep going with this</span>
<a name="line-6"></a>                      <span class='hs-comment'>-- work item.</span>
<a name="line-7"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Stop</span>              <span class='hs-comment'>-- Some canonicalization happened, extra work is now in</span>
<a name="line-8"></a>                      <span class='hs-comment'>-- the TcS WorkList.</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>StopOrContinue</span> <span class='hs-keyword'>where</span>
<a name="line-11"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>Stop</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Stop"</span><span class='hs-layout'>)</span>
<a name="line-12"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"ContinueWith"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>w</span>
<a name="line-13"></a>
<a name="line-14"></a>
<a name="line-15"></a><a name="continueWith"></a><span class='hs-definition'>continueWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-16"></a><span class='hs-definition'>continueWith</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>.</span> <span class='hs-conid'>ContinueWith</span>
<a name="line-17"></a>
<a name="line-18"></a><a name="andWhenContinue"></a><span class='hs-definition'>andWhenContinue</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-19"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span><span class='hs-layout'>)</span>
<a name="line-20"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-21"></a><span class='hs-definition'>andWhenContinue</span> <span class='hs-varid'>tcs1</span> <span class='hs-varid'>tcs2</span>
<a name="line-22"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcs1</span>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>of</span>
<a name="line-24"></a>           <span class='hs-conid'>Stop</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-25"></a>           <span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tcs2</span> <span class='hs-varid'>ct</span> <span class='hs-layout'>}</span>
<a name="line-26"></a>
</pre>\end{code}

Note [Caching for canonicals]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Our plan with pre-canonicalization is to be able to solve a constraint
really fast from existing bindings in TcEvBinds. So one may think that
the condition (isCNonCanonical) is not necessary.  However consider
the following setup:

InertSet = { [W] d1 : Num t }
WorkList = { [W] d2 : Num t, [W] c : t ~ Int}

Now, we prioritize equalities, but in our concrete example
(should_run/mc17.hs) the first (d2) constraint is dealt with first,
because (t ~ Int) is an equality that only later appears in the
worklist since it is pulled out from a nested implication
constraint. So, let's examine what happens:

   - We encounter work item (d2 : Num t)

   - Nothing is yet in EvBinds, so we reach the interaction with inerts
     and set:
              d2 := d1
    and we discard d2 from the worklist. The inert set remains unaffected.

   - Now the equation ([W] c : t ~ Int) is encountered and kicks-out
     (d1 : Num t) from the inerts.  Then that equation gets
     spontaneously solved, perhaps. We end up with:
        InertSet : { [G] c : t ~ Int }
        WorkList : { [W] d1 : Num t}

   - Now we examine (d1), we observe that there is a binding for (Num
     t) in the evidence binds and we set:
             d1 := d2
     and end up in a loop!

Now, the constraints that get kicked out from the inert set are always
Canonical, so by restricting the use of the pre-canonicalizer to
NonCanonical constraints we eliminate this danger. Moreover, for
canonical constraints we already have good caching mechanisms
(effectively the interaction solver) and we are interested in reducing
things like superclasses of the same non-canonical constraint being
generated hence I don't expect us to lose a lot by introducing the
(isCNonCanonical) restriction.

A similar situation can arise in TcSimplify, at the end of the
solve_wanteds function, where constraints from the inert set are
returned as new work -- our substCt ensures however that if they are
not rewritten by subst, they remain canonical and hence we will not
attempt to solve them from the EvBinds. If on the other hand they did
get rewritten and are now non-canonical they will still not match the
EvBinds, so we are again good.



\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a><span class='hs-comment'>-- Top-level canonicalization</span>
<a name="line-3"></a><span class='hs-comment'>-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="line-4"></a>
<a name="line-5"></a><a name="canonicalize"></a><span class='hs-definition'>canonicalize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-6"></a><span class='hs-definition'>canonicalize</span> <span class='hs-varid'>ct</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-7"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canonicalize (non-canonical)"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-8"></a>       <span class='hs-layout'>;</span> <span class='hs-comment'>{-# SCC "canEvVar" #-}</span>
<a name="line-9"></a>         <span class='hs-varid'>canEvNC</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-definition'>canonicalize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span>
<a name="line-12"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span>
<a name="line-13"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-14"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "canClass" #-}</span>
<a name="line-15"></a>    <span class='hs-varid'>canClass</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span> <span class='hs-comment'>-- Do not add any superclasses</span>
<a name="line-16"></a><span class='hs-definition'>canonicalize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span>
<a name="line-17"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span>
<a name="line-18"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-19"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "canEqLeafTyVarEq" #-}</span>
<a name="line-20"></a>    <span class='hs-varid'>canEqTyVar</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>xi</span>
<a name="line-21"></a>
<a name="line-22"></a><span class='hs-definition'>canonicalize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span>
<a name="line-23"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn</span>
<a name="line-24"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis1</span>
<a name="line-25"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-26"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "canEqLeafFunEq" #-}</span>
<a name="line-27"></a>    <span class='hs-varid'>canEqLeafFun</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>xis1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>xi2</span>
<a name="line-28"></a>
<a name="line-29"></a><span class='hs-definition'>canonicalize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CIrredEvCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-30"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canIrred</span> <span class='hs-varid'>ev</span>
<a name="line-31"></a><span class='hs-definition'>canonicalize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CHoleCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_occ</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-32"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canHole</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>occ</span>
<a name="line-33"></a>
<a name="line-34"></a><a name="canEvNC"></a><span class='hs-definition'>canEvNC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-35"></a><span class='hs-comment'>-- Called only for non-canonical EvVars</span>
<a name="line-36"></a><span class='hs-definition'>canEvNC</span> <span class='hs-varid'>ev</span>
<a name="line-37"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-38"></a>      <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEvNC:cls"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>canClassNC</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-39"></a>      <span class='hs-conid'>EqPred</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEvNC:eq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>   <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>canEqNC</span>    <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-40"></a>      <span class='hs-conid'>TuplePred</span> <span class='hs-varid'>tys</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEvNC:tup"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>             <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>canTuple</span>   <span class='hs-varid'>ev</span> <span class='hs-varid'>tys</span>
<a name="line-41"></a>      <span class='hs-conid'>IrredPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEvNC:irred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>canIrred</span>   <span class='hs-varid'>ev</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
%*                      Tuple Canonicalization
%*                                                                      *
%************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="canTuple"></a><span class='hs-definition'>canTuple</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-2"></a><span class='hs-definition'>canTuple</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tys</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_pred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"TuplePred!"</span><span class='hs-layout'>)</span>
<a name="line-4"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>xcomp</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvTupleMk</span>
<a name="line-5"></a>             <span class='hs-varid'>xdecomp</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EvTupleSel</span> <span class='hs-varid'>x</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
<a name="line-6"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ctevs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xCtEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-conid'>XEvTerm</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>xcomp</span> <span class='hs-varid'>xdecomp</span><span class='hs-layout'>)</span>
<a name="line-7"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>canEvVarsCreated</span> <span class='hs-varid'>ctevs</span> <span class='hs-layout'>}</span>
</pre>\end{code}

%************************************************************************
%*                                                                      *
%*                      Class Canonicalization
%*                                                                      *
%************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="canClass"></a><span class='hs-definition'>canClass</span><span class='hs-layout'>,</span> <span class='hs-varid'>canClassNC</span>
<a name="line-2"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-3"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-4"></a><span class='hs-comment'>-- Precondition: EvVar is class evidence</span>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-comment'>-- The canClassNC version is used on non-canonical constraints</span>
<a name="line-7"></a><span class='hs-comment'>-- and adds superclasses.  The plain canClass version is used</span>
<a name="line-8"></a><span class='hs-comment'>-- for already-canonical class constraints (but which might have</span>
<a name="line-9"></a><span class='hs-comment'>-- been subsituted or somthing), and hence do not need superclasses</span>
<a name="line-10"></a>
<a name="line-11"></a><a name="canClassNC"></a><span class='hs-definition'>canClassNC</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-12"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canClass</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-13"></a>    <span class='hs-varop'>`andWhenContinue`</span> <span class='hs-varid'>emitSuperclasses</span>
<a name="line-14"></a>
<a name="line-15"></a><span class='hs-definition'>canClass</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-16"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flattenMany</span> <span class='hs-conid'>FMFullFlatten</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tys</span>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varid'>cos</span>
<a name="line-18"></a>             <span class='hs-varid'>xi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>co</span>
<a name="line-20"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canClass"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span>
<a name="line-21"></a>                                   <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-22"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-23"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-24"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>continueWith</span> <span class='hs-varop'>$</span>
<a name="line-25"></a>                          <span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ev</span>
<a name="line-26"></a>                                   <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-27"></a>
<a name="line-28"></a><a name="emitSuperclasses"></a><span class='hs-definition'>emitSuperclasses</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-29"></a><span class='hs-definition'>emitSuperclasses</span> <span class='hs-varid'>ct</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis_new</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-30"></a>            <span class='hs-comment'>-- Add superclasses of this one here, See Note [Adding superclasses].</span>
<a name="line-31"></a>            <span class='hs-comment'>-- But only if we are not simplifying the LHS of a rule.</span>
<a name="line-32"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>newSCWorkFromFlavored</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis_new</span>
<a name="line-33"></a>      <span class='hs-comment'>-- Arguably we should "seq" the coercions if they are derived,</span>
<a name="line-34"></a>      <span class='hs-comment'>-- as we do below for emit_kind_constraint, to allow errors in</span>
<a name="line-35"></a>      <span class='hs-comment'>-- superclasses to be executed if deferred to runtime!</span>
<a name="line-36"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>continueWith</span> <span class='hs-varid'>ct</span> <span class='hs-layout'>}</span>
<a name="line-37"></a><span class='hs-definition'>emitSuperclasses</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"emit_superclasses of non-class!"</span>
</pre>\end{code}

Note [Adding superclasses]
~~~~~~~~~~~~~~~~~~~~~~~~~~
Since dictionaries are canonicalized only once in their lifetime, the
place to add their superclasses is canonicalisation (The alternative
would be to do it during constraint solving, but we'd have to be
extremely careful to not repeatedly introduced the same superclass in
our worklist). Here is what we do:

For Givens:
       We add all their superclasses as Givens.

For Wanteds:
       Generally speaking we want to be able to add superclasses of
       wanteds for two reasons:

       (1) Oportunities for improvement. Example:
                  class (a ~ b) => C a b
           Wanted constraint is: C alpha beta
           We'd like to simply have C alpha alpha. Similar
           situations arise in relation to functional dependencies.

       (2) To have minimal constraints to quantify over:
           For instance, if our wanted constraint is (Eq a, Ord a)
           we'd only like to quantify over Ord a.

       To deal with (1) above we only add the superclasses of wanteds
       which may lead to improvement, that is: equality superclasses or
       superclasses with functional dependencies.

       We deal with (2) completely independently in TcSimplify. See
       Note [Minimize by SuperClasses] in TcSimplify.


       Moreover, in all cases the extra improvement constraints are
       Derived. Derived constraints have an identity (for now), but
       we don't do anything with their evidence. For instance they
       are never used to rewrite other constraints.

       See also [New Wanted Superclass Work] in TcInteract.


For Deriveds:
       We do nothing.

Here's an example that demonstrates why we chose to NOT add
superclasses during simplification: [Comes from ticket #4497]

   class Num (RealOf t) => Normed t
   type family RealOf x

Assume the generated wanted constraint is:
   RealOf e ~ e, Normed e
If we were to be adding the superclasses during simplification we'd get:
   Num uf, Normed e, RealOf e ~ e, RealOf e ~ uf
==>
   e ~ uf, Num uf, Normed e, RealOf e ~ e
==> [Spontaneous solve]
   Num uf, Normed uf, RealOf uf ~ uf

While looks exactly like our original constraint. If we add the superclass again we'd loop.
By adding superclasses definitely only once, during canonicalisation, this situation can't
happen.

\begin{code}
<pre><a name="line-1"></a><a name="newSCWorkFromFlavored"></a><span class='hs-definition'>newSCWorkFromFlavored</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-2"></a><span class='hs-comment'>-- Returns superclasses, see Note [Adding superclasses]</span>
<a name="line-3"></a><span class='hs-definition'>newSCWorkFromFlavored</span> <span class='hs-varid'>flavor</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDerived</span> <span class='hs-varid'>flavor</span>
<a name="line-5"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>  <span class='hs-comment'>-- Deriveds don't yield more superclasses because we will</span>
<a name="line-6"></a>               <span class='hs-comment'>-- add them transitively in the case of wanteds.</span>
<a name="line-7"></a>
<a name="line-8"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGiven</span> <span class='hs-varid'>flavor</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>sc_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>immSuperClasses</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span>
<a name="line-10"></a>             <span class='hs-varid'>xev_decomp</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EvSuperClass</span> <span class='hs-varid'>x</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-varid'>sc_theta</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
<a name="line-11"></a>             <span class='hs-varid'>xev</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XEvTerm</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ev_preds</span>  <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>sc_theta</span>
<a name="line-12"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>ev_comp</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"Can't compose for given!"</span>
<a name="line-13"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>ev_decomp</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xev_decomp</span> <span class='hs-layout'>}</span>
<a name="line-14"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ctevs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xCtEvidence</span> <span class='hs-varid'>flavor</span> <span class='hs-varid'>xev</span>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitWorkNC</span> <span class='hs-varid'>ctevs</span> <span class='hs-layout'>}</span>
<a name="line-16"></a>
<a name="line-17"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>xis</span><span class='hs-layout'>)</span>
<a name="line-18"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-comment'>-- Wanteds with no variables yield no deriveds.</span>
<a name="line-19"></a>              <span class='hs-comment'>-- See Note [Improvement from Ground Wanteds]</span>
<a name="line-20"></a>
<a name="line-21"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-comment'>-- Wanted case, just add those SC that can lead to improvement.</span>
<a name="line-22"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>sc_rec_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>transSuperClasses</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span>
<a name="line-23"></a>             <span class='hs-varid'>impr_theta</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>is_improvement_pty</span> <span class='hs-varid'>sc_rec_theta</span>
<a name="line-24"></a>             <span class='hs-varid'>loc</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-varid'>flavor</span>
<a name="line-25"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"newSCWork/Derived"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"impr_theta ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>impr_theta</span>
<a name="line-26"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb_der_evs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>newDerived</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span> <span class='hs-varid'>impr_theta</span>
<a name="line-27"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitWorkNC</span> <span class='hs-layout'>(</span><span class='hs-varid'>catMaybes</span> <span class='hs-varid'>mb_der_evs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-28"></a>
<a name="line-29"></a><a name="is_improvement_pty"></a><span class='hs-definition'>is_improvement_pty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-30"></a><span class='hs-comment'>-- Either it's an equality, or has some functional dependency</span>
<a name="line-31"></a><span class='hs-definition'>is_improvement_pty</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-32"></a>  <span class='hs-keyword'>where</span>
<a name="line-33"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>EqPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-34"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-sel'>_tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-varop'>$</span> <span class='hs-varid'>null</span> <span class='hs-varid'>fundeps</span>
<a name="line-35"></a>      <span class='hs-keyword'>where</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>fundeps</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classTvsFds</span> <span class='hs-varid'>cls</span>
<a name="line-36"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TuplePred</span> <span class='hs-varid'>ts</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-varid'>is_improvement_pty</span> <span class='hs-varid'>ts</span>
<a name="line-37"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>IrredPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- Might have equalities after reduction?</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
%*                      Irreducibles canonicalization
%*                                                                      *
%************************************************************************


\begin{code}
<pre><a name="line-1"></a><a name="canIrred"></a><span class='hs-definition'>canIrred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-2"></a><span class='hs-comment'>-- Precondition: ty not a tuple and no other evidence form</span>
<a name="line-3"></a><span class='hs-definition'>canIrred</span> <span class='hs-varid'>old_ev</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>old_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>old_ev</span>
<a name="line-5"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_pred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"IrredPred = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>old_ty</span><span class='hs-layout'>)</span>
<a name="line-6"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span><span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-conid'>FMFullFlatten</span> <span class='hs-varid'>old_ev</span> <span class='hs-varid'>old_ty</span> <span class='hs-comment'>-- co :: xi ~ old_ty</span>
<a name="line-7"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEvidence</span> <span class='hs-varid'>old_ev</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>co</span>
<a name="line-8"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span>
<a name="line-9"></a>             <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>;</span>
<a name="line-10"></a>             <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-11"></a>
<a name="line-12"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- Re-classify, in case flattening has improved its shape</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-14"></a>           <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>canClassNC</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-15"></a>           <span class='hs-conid'>TuplePred</span> <span class='hs-varid'>tys</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>canTuple</span>   <span class='hs-varid'>new_ev</span> <span class='hs-varid'>tys</span>
<a name="line-16"></a>           <span class='hs-conid'>EqPred</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>canEqNC</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-17"></a>           <span class='hs-keyword'>_</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>continueWith</span> <span class='hs-varop'>$</span>
<a name="line-18"></a>                                <span class='hs-conid'>CIrredEvCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ev</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-19"></a>
<a name="line-20"></a><a name="canHole"></a><span class='hs-definition'>canHole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccName</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-21"></a><span class='hs-definition'>canHole</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>occ</span>
<a name="line-22"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span><span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-conid'>FMFullFlatten</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty</span> <span class='hs-comment'>-- co :: xi ~ ty</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>co</span>
<a name="line-25"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-26"></a>             <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>emitInsoluble</span> <span class='hs-layout'>(</span><span class='hs-conid'>CHoleCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_occ</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-27"></a>             <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>   <span class='hs-comment'>-- Found a cached copy; won't happen</span>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span>
</pre>\end{code}

%************************************************************************
%*                                                                      *
%*        Flattening (eliminating all function symbols)                 *
%*                                                                      *
%************************************************************************

Note [Flattening]
~~~~~~~~~~~~~~~~~~~~
  flatten ty  ==>   (xi, cc)
    where
      xi has no type functions, unless they appear under ForAlls

      cc = Auxiliary given (equality) constraints constraining
           the fresh type variables in xi.  Evidence for these
           is always the identity coercion, because internally the
           fresh flattening skolem variables are actually identified
           with the types they have been generated to stand in for.

Note that it is flatten's job to flatten *every type function it sees*.
flatten is only called on *arguments* to type functions, by canEqGiven.

Recall that in comments we use alpha[flat = ty] to represent a
flattening skolem variable alpha which has been generated to stand in
for ty.

----- Example of flattening a constraint: ------
  flatten (List (F (G Int)))  ==>  (xi, cc)
    where
      xi  = List alpha
      cc  = { G Int ~ beta[flat = G Int],
              F beta ~ alpha[flat = F beta] }
Here
  * alpha and beta are 'flattening skolem variables'.
  * All the constraints in cc are 'given', and all their coercion terms
    are the identity.

NB: Flattening Skolems only occur in canonical constraints, which
are never zonked, so we don't need to worry about zonking doing
accidental unflattening.

Note that we prefer to leave type synonyms unexpanded when possible,
so when the flattener encounters one, it first asks whether its
transitive expansion contains any type function applications.  If so,
it expands the synonym and proceeds; if not, it simply returns the
unexpanded synonym.

\begin{code}
<pre><a name="line-1"></a><a name="FlattenMode"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FMSubstOnly</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FMFullFlatten</span>
<a name="line-2"></a>                   <span class='hs-comment'>-- See Note [Flattening under a forall]</span>
<a name="line-3"></a>
<a name="line-4"></a><a name="flattenMany"></a><span class='hs-comment'>-- Flatten a bunch of types all at once.</span>
<a name="line-5"></a><span class='hs-definition'>flattenMany</span> <span class='hs-keyglyph'>::</span>  <span class='hs-conid'>FlattenMode</span>
<a name="line-6"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-7"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcCoercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-8"></a><span class='hs-comment'>-- Coercions :: Xi ~ Type</span>
<a name="line-9"></a><span class='hs-comment'>-- Returns True iff (no flattening happened)</span>
<a name="line-10"></a><span class='hs-comment'>-- NB: The EvVar inside the 'ctxt :: CtEvidence' is unused,</span>
<a name="line-11"></a><span class='hs-comment'>--     we merely want (a) Given/Solved/Derived/Wanted info</span>
<a name="line-12"></a><span class='hs-comment'>--                    (b) the GivenLoc/WantedLoc for when we create new evidence</span>
<a name="line-13"></a><span class='hs-definition'>flattenMany</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tys</span>
<a name="line-14"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "flattenMany" empty $</span>
<a name="line-15"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>tys</span>
<a name="line-16"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-17"></a>        <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-conop'>:</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span><span class='hs-varid'>co</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span>
<a name="line-18"></a>                         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span><span class='hs-varid'>cos</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>tys</span>
<a name="line-19"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-conop'>:</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span><span class='hs-varid'>co</span><span class='hs-conop'>:</span><span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-20"></a>
<a name="line-21"></a><a name="flatten"></a><span class='hs-definition'>flatten</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span>
<a name="line-22"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-23"></a><span class='hs-comment'>-- Flatten a type to get rid of type function applications, returning</span>
<a name="line-24"></a><span class='hs-comment'>-- the new type-function-free type, and a collection of new equality</span>
<a name="line-25"></a><span class='hs-comment'>-- constraints.  See Note [Flattening] for more detail.</span>
<a name="line-26"></a><span class='hs-comment'>--</span>
<a name="line-27"></a><span class='hs-comment'>-- Postcondition: Coercion :: Xi ~ TcType</span>
<a name="line-28"></a>
<a name="line-29"></a><span class='hs-definition'>flatten</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>xi</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>xi</span><span class='hs-layout'>)</span>
<a name="line-30"></a>
<a name="line-31"></a><span class='hs-definition'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-32"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flattenTyVar</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tv</span>
<a name="line-33"></a>
<a name="line-34"></a><span class='hs-definition'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-35"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span><span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty1</span>
<a name="line-36"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span><span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty2</span>
<a name="line-37"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flatten/appty"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi2</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span>
<a name="line-38"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkAppTy</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcAppCo</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-39"></a>
<a name="line-40"></a><span class='hs-definition'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-41"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span><span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty1</span>
<a name="line-42"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span><span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty2</span>
<a name="line-43"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFunTy</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcFunCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-44"></a>
<a name="line-45"></a><span class='hs-definition'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-46"></a>
<a name="line-47"></a>  <span class='hs-comment'>-- Expand type synonyms that mention type families </span>
<a name="line-48"></a>  <span class='hs-comment'>-- on the RHS; see Note [Flattening synonyms]</span>
<a name="line-49"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tenv</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcExpandTyCon_maybe</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-50"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isSynFamilyTyCon</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConsOfType</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-51"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkAppTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTopTvSubst</span> <span class='hs-varid'>tenv</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys'</span><span class='hs-layout'>)</span>
<a name="line-52"></a>
<a name="line-53"></a>  <span class='hs-comment'>-- For * a normal data type application</span>
<a name="line-54"></a>  <span class='hs-comment'>--     * data family application</span>
<a name="line-55"></a>  <span class='hs-comment'>--     * type synonym application whose RHS does not mention type families</span>
<a name="line-56"></a>  <span class='hs-comment'>--             See Note [Flattening synonyms]</span>
<a name="line-57"></a>  <span class='hs-comment'>-- we just recursively flatten the arguments.</span>
<a name="line-58"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSynFamilyTyCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-59"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span><span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flattenMany</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tys</span>
<a name="line-60"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-61"></a>
<a name="line-62"></a>  <span class='hs-comment'>-- Otherwise, it's a type function application, and we have to</span>
<a name="line-63"></a>  <span class='hs-comment'>-- flatten it away as well, and generate a new given equality constraint</span>
<a name="line-64"></a>  <span class='hs-comment'>-- between the application and a newly generated flattening skolem variable.</span>
<a name="line-65"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-66"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>)</span>       <span class='hs-comment'>-- Type functions are saturated</span>
<a name="line-67"></a>      <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flattenMany</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tys</span>
<a name="line-68"></a>         <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi_args</span><span class='hs-layout'>,</span>  <span class='hs-varid'>xi_rest</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAt</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>xis</span>
<a name="line-69"></a>               <span class='hs-layout'>(</span><span class='hs-varid'>cos_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos_rest</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAt</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>cos</span>
<a name="line-70"></a>                 <span class='hs-comment'>-- The type function might be *over* saturated</span>
<a name="line-71"></a>                 <span class='hs-comment'>-- in which case the remaining arguments should</span>
<a name="line-72"></a>                 <span class='hs-comment'>-- be dealt with by AppTys</span>
<a name="line-73"></a>
<a name="line-74"></a>         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>ret_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flattenNestedFamApp</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xi_args</span>
<a name="line-75"></a>
<a name="line-76"></a>                  <span class='hs-comment'>-- Emit the flat constraints</span>
<a name="line-77"></a>         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkAppTys</span> <span class='hs-varid'>rhs_xi</span> <span class='hs-varid'>xi_rest</span> <span class='hs-comment'>-- NB mkAppTys: rhs_xi might not be a type variable</span>
<a name="line-78"></a>                                            <span class='hs-comment'>--    cf Trac #5655</span>
<a name="line-79"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>mkTcAppCos</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>ret_co</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos_args</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-80"></a>                    <span class='hs-varid'>cos_rest</span>
<a name="line-81"></a>                  <span class='hs-layout'>)</span>
<a name="line-82"></a>         <span class='hs-layout'>}</span>
<a name="line-83"></a>
<a name="line-84"></a><span class='hs-definition'>flatten</span> <span class='hs-sel'>_f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-85"></a><span class='hs-comment'>-- We allow for-alls when, but only when, no type function</span>
<a name="line-86"></a><span class='hs-comment'>-- applications inside the forall involve the bound type variables.</span>
<a name="line-87"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rho</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitForAllTys</span> <span class='hs-varid'>ty</span>
<a name="line-88"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rho'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-conid'>FMSubstOnly</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rho</span>
<a name="line-89"></a>                         <span class='hs-comment'>-- Substitute only under a forall</span>
<a name="line-90"></a>                         <span class='hs-comment'>-- See Note [Flattening under a forall]</span>
<a name="line-91"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkForAllTys</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>rho'</span><span class='hs-layout'>,</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mkTcForAllCo</span> <span class='hs-varid'>co</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Flattening synonyms]
~~~~~~~~~~~~~~~~~~~~~~~~~~
Not expanding synonyms aggressively improves error messages, and
keeps types smaller. But we need to take care.

Suppose
   type T a = a -> a
and we want to flatten the type (T (F a)).  Then we can safely flatten
the (F a) to a skolem, and return (T fsk).  We don't need to expand the
synonym.  This works because TcTyConAppCo can deal with synonyms
(unlike TyConAppCo), see Note [TcCoercions] in TcEvidence.

But (Trac #8979) for
   type T a = (F a, a)    where F is a type function
we must expand the synonym in (say) T Int, to expose the type functoin
to the flattener.


Note [Flattening under a forall]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Under a forall, we
  (a) MUST apply the inert substitution
  (b) MUST NOT flatten type family applications
Hence FMSubstOnly.

For (a) consider   c ~ a, a ~ T (forall b. (b, [c])
If we don't apply the c~a substitution to the second constraint
we won't see the occurs-check error.

For (b) consider  (a ~ forall b. F a b), we don't want to flatten
to     (a ~ forall b.fsk, F a b ~ fsk)
because now the 'b' has escaped its scope.  We'd have to flatten to
       (a ~ forall b. fsk b, forall b. F a b ~ fsk b)
and we have not begun to think about how to make that work!

\begin{code}
<pre><a name="line-1"></a><a name="flattenNestedFamApp"></a><span class='hs-definition'>flattenNestedFamApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-2"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Exactly-saturated type function application</span>
<a name="line-3"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-4"></a><span class='hs-definition'>flattenNestedFamApp</span> <span class='hs-conid'>FMSubstOnly</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xi_args</span>
<a name="line-5"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fam_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xi_args</span>
<a name="line-6"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>fam_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>fam_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-definition'>flattenNestedFamApp</span> <span class='hs-conid'>FMFullFlatten</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xi_args</span>  <span class='hs-comment'>-- Eactly saturated</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fam_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xi_args</span>
<a name="line-10"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupFlatEqn</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xi_args</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyword'>of</span>
<a name="line-12"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>)</span>
<a name="line-13"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ctev</span> <span class='hs-varop'>`</span><span class='hs-varid'>canRewriteOrSame</span> <span class='hs-varop'>`</span><span class='hs-varid'>ctxt</span>    <span class='hs-comment'>-- Must allow [W]/[W]</span>
<a name="line-14"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- You may think that we can just return (cc_rhs ct) but not so.</span>
<a name="line-15"></a>                <span class='hs-comment'>--            return (mkTcCoVarCo (ctId ct), cc_rhs ct, [])</span>
<a name="line-16"></a>                <span class='hs-comment'>-- The cached constraint resides in the cache so we have to flatten</span>
<a name="line-17"></a>                <span class='hs-comment'>-- the rhs to make sure we have applied any inert substitution to it.</span>
<a name="line-18"></a>                <span class='hs-comment'>-- Alternatively we could be applying the inert substitution to the</span>
<a name="line-19"></a>                <span class='hs-comment'>-- cache as well when we interact an equality with the inert.</span>
<a name="line-20"></a>                <span class='hs-comment'>-- The design choice is: do we keep the flat cache rewritten or not?</span>
<a name="line-21"></a>                <span class='hs-comment'>-- For now I say we don't keep it fully rewritten.</span>
<a name="line-22"></a>               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_xi</span><span class='hs-layout'>,</span><span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-conid'>FMFullFlatten</span> <span class='hs-varid'>ctev</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-23"></a>                  <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>final_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evTermCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span>
<a name="line-24"></a>                                   <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>co</span>
<a name="line-25"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flatten/flat-cache hit"</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ctev</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_xi</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>final_co</span><span class='hs-layout'>)</span>
<a name="line-26"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-27"></a>
<a name="line-28"></a>           <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_xi</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFlattenSkolem</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>fam_ty</span>
<a name="line-29"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>extendFlatCache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xi_args</span> <span class='hs-varid'>ctev</span> <span class='hs-varid'>rhs_xi</span>
<a name="line-30"></a>
<a name="line-31"></a>                   <span class='hs-comment'>-- The new constraint (F xi_args ~ rhs_xi) is not necessarily inert</span>
<a name="line-32"></a>                   <span class='hs-comment'>-- (e.g. the LHS may be a redex) so we must put it in the work list</span>
<a name="line-33"></a>                   <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctev</span>
<a name="line-34"></a>                                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span>
<a name="line-35"></a>                                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi_args</span>
<a name="line-36"></a>                                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_xi</span> <span class='hs-layout'>}</span>
<a name="line-37"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>extendWorkListFunEq</span> <span class='hs-varid'>ct</span>
<a name="line-38"></a>
<a name="line-39"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flatten/flat-cache miss"</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>fam_ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_xi</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span>
<a name="line-40"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>evTermCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-41"></a>       <span class='hs-layout'>}</span>
</pre>\end{code}

\begin{code}
<pre><a name="line-1"></a><a name="flattenTyVar"></a><span class='hs-definition'>flattenTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-comment'>-- "Flattening" a type variable means to apply the substitution to it</span>
<a name="line-3"></a><span class='hs-comment'>-- The substitution is actually the union of the substitution in the TyBinds</span>
<a name="line-4"></a><span class='hs-comment'>-- for the unification variables that have been unified already with the inert</span>
<a name="line-5"></a><span class='hs-comment'>-- equalities, see Note [Spontaneously solved in TyBinds] in TcInteract.</span>
<a name="line-6"></a><span class='hs-comment'>--</span>
<a name="line-7"></a><span class='hs-comment'>-- Postcondition: co : xi ~ tv</span>
<a name="line-8"></a><span class='hs-definition'>flattenTyVar</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tv</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_yes</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flattenTyVarOuter</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tv</span>
<a name="line-10"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_yes</span> <span class='hs-keyword'>of</span>
<a name="line-11"></a>           <span class='hs-conid'>Left</span> <span class='hs-varid'>tv'</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Done </span>
<a name="line-12"></a>                               <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-13"></a>                            <span class='hs-keyword'>where</span>
<a name="line-14"></a>                               <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv'</span>
<a name="line-15"></a>
<a name="line-16"></a>           <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Recurse</span>
<a name="line-17"></a>                               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty1</span>
<a name="line-18"></a>                                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-19"></a>       <span class='hs-layout'>}</span>
<a name="line-20"></a>
<a name="line-21"></a><a name="flattenTyVarOuter"></a><span class='hs-definition'>flattenTyVarOuter</span><span class='hs-layout'>,</span> <span class='hs-varid'>flattenTyVarFinal</span> 
<a name="line-22"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-23"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> 
<a name="line-24"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-conid'>TyVar</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcType</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-25"></a><span class='hs-comment'>-- Look up the tyvar in </span>
<a name="line-26"></a><span class='hs-comment'>--   a) the internal MetaTyVar box</span>
<a name="line-27"></a><span class='hs-comment'>--   b) the tyvar binds </span>
<a name="line-28"></a><span class='hs-comment'>--   c) the inerts</span>
<a name="line-29"></a><span class='hs-comment'>-- Return (Left tv')       if it is not found, tv' has a properly zonked kind</span>
<a name="line-30"></a><span class='hs-comment'>--        (Right (ty, co)) if found, with co :: ty ~ tv</span>
<a name="line-31"></a><span class='hs-comment'>--                         NB: in the latter case ty is not necessarily flattened</span>
<a name="line-32"></a>
<a name="line-33"></a><span class='hs-definition'>flattenTyVarOuter</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tv</span>
<a name="line-34"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTcTyVar</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>            <span class='hs-comment'>-- Happens when flatten under a (forall a. ty)</span>
<a name="line-35"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flattenTyVarFinal</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tv</span>   <span class='hs-comment'>-- So ty contains refernces to the non-TcTyVar a</span>
<a name="line-36"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-37"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFilledMetaTyVar_maybe</span> <span class='hs-varid'>tv</span>
<a name="line-38"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span>
<a name="line-39"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Following filled tyvar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-40"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>;</span>
<a name="line-41"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-42"></a>
<a name="line-43"></a>    <span class='hs-comment'>-- Try in ty_binds</span>
<a name="line-44"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty_binds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSTyBindsMap</span>
<a name="line-45"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>ty_binds</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span>
<a name="line-46"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-sel'>_tv</span><span class='hs-layout'>,</span><span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Following bound tyvar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-47"></a>                               <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>;</span>
<a name="line-48"></a>                                 <span class='hs-comment'>-- NB: ty_binds coercions are all ReflCo,</span>
<a name="line-49"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-50"></a>
<a name="line-51"></a>    <span class='hs-comment'>-- Try in the inert equalities</span>
<a name="line-52"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ieqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getInertEqs</span>
<a name="line-53"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>ieqs</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>of</span>
<a name="line-54"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                      <span class='hs-comment'>-- If the first doesn't work,</span>
<a name="line-55"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ctev</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>ct</span>   <span class='hs-comment'>-- the subsequent ones won't either</span>
<a name="line-56"></a>                   <span class='hs-varid'>rhs_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-varid'>ct</span>
<a name="line-57"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ctev</span> <span class='hs-varop'>`canRewrite`</span> <span class='hs-varid'>ctxt</span> 
<a name="line-58"></a>             <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Following inert tyvar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span>
<a name="line-59"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>evTermCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvTerm</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-60"></a>                    <span class='hs-comment'>-- NB: even if ct is Derived we are not going to</span>
<a name="line-61"></a>                    <span class='hs-comment'>-- touch the actual coercion so we are fine.</span>
<a name="line-62"></a>
<a name="line-63"></a>           <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flattenTyVarFinal</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tv</span>
<a name="line-64"></a>    <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-65"></a>
<a name="line-66"></a><a name="flattenTyVarFinal"></a><span class='hs-definition'>flattenTyVarFinal</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tv</span>
<a name="line-67"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- Done, but make sure the kind is zonked</span>
<a name="line-68"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>knd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span>
<a name="line-69"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_knd</span><span class='hs-layout'>,</span> <span class='hs-sel'>_kind_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>knd</span>
<a name="line-70"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-varid'>setVarType</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>new_knd</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Non-idempotent inert substitution]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The inert substitution is not idempotent in the broad sense. It is only idempotent in
that it cannot rewrite the RHS of other inert equalities any further. An example of such
an inert substitution is:

 [G] g1 : ta8 ~ ta4
 [W] g2 : ta4 ~ a5Fj

Observe that the wanted cannot rewrite the solved goal, despite the fact that ta4 appears on
an RHS of an equality. Now, imagine a constraint:

 [W] g3: ta8 ~ Int

coming in. If we simply apply once the inert substitution we will get:

 [W] g3_1: ta4 ~ Int

and because potentially ta4 is untouchable we will try to insert g3_1 in the inert set,
getting a panic since the inert only allows ONE equation per LHS type variable (as it
should).

For this reason, when we reach to flatten a type variable, we flatten it recursively,
so that we can make sure that the inert substitution /is/ fully applied.

Insufficient (non-recursive) rewriting was the reason for #5668.


%************************************************************************
%*                                                                      *
%*        Equalities
%*                                                                      *
%************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="canEvVarsCreated"></a><span class='hs-definition'>canEvVarsCreated</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CtEvidence</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-2"></a><span class='hs-definition'>canEvVarsCreated</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-3"></a>    <span class='hs-comment'>-- Add all but one to the work list</span>
<a name="line-4"></a>    <span class='hs-comment'>-- and return the first (if any) for futher processing</span>
<a name="line-5"></a><span class='hs-definition'>canEvVarsCreated</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev</span> <span class='hs-conop'>:</span> <span class='hs-varid'>evs</span><span class='hs-layout'>)</span>
<a name="line-6"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>emitWorkNC</span> <span class='hs-varid'>evs</span><span class='hs-layout'>;</span> <span class='hs-varid'>canEvNC</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span>
<a name="line-7"></a>          <span class='hs-comment'>-- Note the "NC": these are fresh goals, not necessarily canonical</span>
<a name="line-8"></a>
<a name="line-9"></a><a name="emitWorkNC"></a><span class='hs-definition'>emitWorkNC</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CtEvidence</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-10"></a><span class='hs-definition'>emitWorkNC</span> <span class='hs-varid'>evs</span>
<a name="line-11"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>evs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-12"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListCts</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mk_nc</span> <span class='hs-varid'>evs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-13"></a>  <span class='hs-keyword'>where</span>
<a name="line-14"></a>    <span class='hs-varid'>mk_nc</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span>
<a name="line-15"></a>
<a name="line-16"></a><a name="canEqNC"></a><span class='hs-comment'>-------------------------</span>
<a name="line-17"></a><span class='hs-definition'>canEqNC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-18"></a><span class='hs-definition'>canEqNC</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_nc</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ty2</span>
<a name="line-19"></a>
<a name="line-20"></a>
<a name="line-21"></a><a name="can_eq_nc"></a><span class='hs-definition'>can_eq_nc</span><span class='hs-layout'>,</span> <span class='hs-varid'>can_eq_nc'</span> 
<a name="line-22"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> 
<a name="line-23"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- LHS, after and before type-synonym expansion, resp </span>
<a name="line-24"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- RHS, after and before type-synonym expansion, resp </span>
<a name="line-25"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-26"></a>
<a name="line-27"></a><span class='hs-definition'>can_eq_nc</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-28"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_eq_nc"</span> <span class='hs-varop'>$</span> 
<a name="line-29"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ps_ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-keyglyph'>]</span>
<a name="line-30"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-layout'>}</span>
<a name="line-31"></a>
<a name="line-32"></a><a name="can_eq_nc'"></a><span class='hs-comment'>-- Expand synonyms first; see Note [Type synonyms and canonicalization]</span>
<a name="line-33"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-34"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty1'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_nc</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span>  <span class='hs-varid'>ps_ty2</span>
<a name="line-35"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty2'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_nc</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span>  <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2'</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-36"></a>
<a name="line-37"></a><span class='hs-comment'>-- Type family on LHS or RHS take priority</span>
<a name="line-38"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-39"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSynFamilyTyCon</span> <span class='hs-varid'>fn</span>
<a name="line-40"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqLeafFun</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-41"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>
<a name="line-42"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSynFamilyTyCon</span> <span class='hs-varid'>fn</span>
<a name="line-43"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqLeafFun</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>IsSwapped</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span>
<a name="line-44"></a>
<a name="line-45"></a><span class='hs-comment'>-- Type variable on LHS or RHS are next</span>
<a name="line-46"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-47"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqTyVar</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-48"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>
<a name="line-49"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqTyVar</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>IsSwapped</span> <span class='hs-varid'>tv2</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span>
<a name="line-50"></a>
<a name="line-51"></a><span class='hs-comment'>----------------------</span>
<a name="line-52"></a><span class='hs-comment'>-- Otherwise try to decompose</span>
<a name="line-53"></a><span class='hs-comment'>----------------------</span>
<a name="line-54"></a>
<a name="line-55"></a><span class='hs-comment'>-- Literals</span>
<a name="line-56"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>
<a name="line-57"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>l1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>l2</span>
<a name="line-58"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-59"></a>         <span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev_evar</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-60"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span>
<a name="line-61"></a>
<a name="line-62"></a><span class='hs-comment'>-- Decomposable type constructor applications </span>
<a name="line-63"></a><span class='hs-comment'>-- Synonyms and type functions (which are not decomposable)</span>
<a name="line-64"></a><span class='hs-comment'>-- have already been dealt with </span>
<a name="line-65"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc2</span> <span class='hs-varid'>tys2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>
<a name="line-66"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDecomposableTyCon</span> <span class='hs-varid'>tc1</span>
<a name="line-67"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isDecomposableTyCon</span> <span class='hs-varid'>tc2</span>
<a name="line-68"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canDecomposableTyConApp</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tc2</span> <span class='hs-varid'>tys2</span>
<a name="line-69"></a>
<a name="line-70"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc1</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-71"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDecomposableTyCon</span> <span class='hs-varid'>tc1</span> 
<a name="line-72"></a>      <span class='hs-comment'>-- The guard is important</span>
<a name="line-73"></a>      <span class='hs-comment'>-- e.g.  (x -&gt; y) ~ (F x y) where F has arity 1</span>
<a name="line-74"></a>      <span class='hs-comment'>--       should not fail, but get the app/app case</span>
<a name="line-75"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-76"></a>
<a name="line-77"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>s2</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>
<a name="line-78"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canDecomposableTyConAppOK</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>funTyCon</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>s1</span><span class='hs-layout'>,</span><span class='hs-varid'>t1</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>s2</span><span class='hs-layout'>,</span><span class='hs-varid'>t2</span><span class='hs-keyglyph'>]</span>
<a name="line-79"></a>
<a name="line-80"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc2</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-81"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDecomposableTyCon</span> <span class='hs-varid'>tc2</span> 
<a name="line-82"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-83"></a>
<a name="line-84"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>s1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>s2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>
<a name="line-85"></a> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtWanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span><span class='hs-layout'>,</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>orig_ev</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ev</span>
<a name="line-86"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs1</span><span class='hs-layout'>,</span><span class='hs-varid'>body1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitForAllTys</span> <span class='hs-varid'>s1</span>
<a name="line-87"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>tvs2</span><span class='hs-layout'>,</span><span class='hs-varid'>body2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitForAllTys</span> <span class='hs-varid'>s2</span>
<a name="line-88"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>equalLength</span> <span class='hs-varid'>tvs1</span> <span class='hs-varid'>tvs2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>then</span>
<a name="line-89"></a>          <span class='hs-varid'>canEqFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span>
<a name="line-90"></a>        <span class='hs-keyword'>else</span>
<a name="line-91"></a>          <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Creating implication for polytype equality"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span>
<a name="line-92"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>ev_term</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>deferTcSForAllEq</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs1</span><span class='hs-layout'>,</span><span class='hs-varid'>body1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs2</span><span class='hs-layout'>,</span><span class='hs-varid'>body2</span><span class='hs-layout'>)</span>
<a name="line-93"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>setEvBind</span> <span class='hs-varid'>orig_ev</span> <span class='hs-varid'>ev_term</span>
<a name="line-94"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-95"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-96"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Ommitting decomposition of given polytype equality"</span> <span class='hs-varop'>$</span>
<a name="line-97"></a>        <span class='hs-varid'>pprEq</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span>    <span class='hs-comment'>-- See Note [Do not decompose given polytype equalities]</span>
<a name="line-98"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span>
<a name="line-99"></a>
<a name="line-100"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-101"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_app</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-102"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>s2</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-103"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_app</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>IsSwapped</span> <span class='hs-varid'>s2</span> <span class='hs-varid'>t2</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span>
<a name="line-104"></a>
<a name="line-105"></a><span class='hs-comment'>-- Everything else is a definite type error, eg LitTy ~ TyConApp</span>
<a name="line-106"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>ev</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-107"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-108"></a>
<a name="line-109"></a><a name="can_eq_app"></a><span class='hs-comment'>------------</span>
<a name="line-110"></a><span class='hs-definition'>can_eq_app</span><span class='hs-layout'>,</span> <span class='hs-varid'>can_eq_flat_app</span>
<a name="line-111"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-112"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>  <span class='hs-comment'>-- LHS (s1 t2), after and before type-synonym expansion, resp </span>
<a name="line-113"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>          <span class='hs-comment'>-- RHS (ty2),   after and before type-synonym expansion, resp </span>
<a name="line-114"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-115"></a><span class='hs-comment'>-- See Note [Canonicalising type applications]</span>
<a name="line-116"></a><span class='hs-definition'>can_eq_app</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-117"></a>  <span class='hs-keyglyph'>=</span>  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_eq_app 1"</span> <span class='hs-varop'>$</span>
<a name="line-118"></a>          <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>swapped</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>t1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>]</span>
<a name="line-119"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi_s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co_s1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-conid'>FMSubstOnly</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>s1</span>
<a name="line-120"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_eq_app 2"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi_s1</span> <span class='hs-keyglyph'>]</span>
<a name="line-121"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>s1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>xi_s1</span>
<a name="line-122"></a>          <span class='hs-keyword'>then</span> <span class='hs-varid'>can_eq_flat_app</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-123"></a>          <span class='hs-keyword'>else</span>
<a name="line-124"></a>     <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi_t1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co_t1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-conid'>FMSubstOnly</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>t1</span>
<a name="line-125"></a>             <span class='hs-comment'>-- We flatten t1 as well so that (xi_s1 xi_t1) is well-kinded</span>
<a name="line-126"></a>             <span class='hs-comment'>-- If we form (xi_s1 t1) that might (appear) ill-kinded, </span>
<a name="line-127"></a>             <span class='hs-comment'>-- and then crash in a call to typeKind</span>
<a name="line-128"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>xi1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkAppTy</span> <span class='hs-varid'>xi_s1</span> <span class='hs-varid'>xi_t1</span>
<a name="line-129"></a>              <span class='hs-varid'>co1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcAppCo</span> <span class='hs-varid'>co_s1</span> <span class='hs-varid'>co_t1</span>
<a name="line-130"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_eq_app 3"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co1</span> <span class='hs-keyglyph'>]</span>
<a name="line-131"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>ps_ty2</span> 
<a name="line-132"></a>                                     <span class='hs-varid'>co1</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>ps_ty2</span><span class='hs-layout'>)</span>
<a name="line-133"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_eq_app 4"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co1</span> <span class='hs-keyglyph'>]</span>
<a name="line-134"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyword'>of</span>
<a name="line-135"></a>           <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-136"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>can_eq_nc</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-137"></a>
<a name="line-138"></a><a name="can_eq_flat_app"></a><span class='hs-comment'>-- Preconditions: s1  is already flattened</span>
<a name="line-139"></a><span class='hs-comment'>--                ty2 is not a type variable, so flattening</span>
<a name="line-140"></a><span class='hs-comment'>--                    can't turn it into an application if it</span>
<a name="line-141"></a><span class='hs-comment'>--                    doesn't look like one already</span>
<a name="line-142"></a><span class='hs-comment'>-- See Note [Canonicalising type applications]</span>
<a name="line-143"></a><span class='hs-definition'>can_eq_flat_app</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-144"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>s2</span><span class='hs-layout'>,</span><span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSplitAppTy_maybe</span> <span class='hs-varid'>ty2</span>
<a name="line-145"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unSwap</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>decompose_it</span> <span class='hs-layout'>(</span><span class='hs-varid'>s1</span><span class='hs-layout'>,</span><span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>s2</span><span class='hs-layout'>,</span><span class='hs-varid'>t2</span><span class='hs-layout'>)</span>
<a name="line-146"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-147"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unSwap</span> <span class='hs-varid'>swapped</span> <span class='hs-layout'>(</span><span class='hs-varid'>canEqFailure</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-148"></a>  <span class='hs-keyword'>where</span>
<a name="line-149"></a>    <span class='hs-varid'>decompose_it</span> <span class='hs-layout'>(</span><span class='hs-varid'>s1</span><span class='hs-layout'>,</span><span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>s2</span><span class='hs-layout'>,</span><span class='hs-varid'>t2</span><span class='hs-layout'>)</span> 
<a name="line-150"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>xevcomp</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcAppCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>evTermCoercion</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>evTermCoercion</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-151"></a>                 <span class='hs-varid'>xevcomp</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"canEqAppTy: can't happen"</span> <span class='hs-comment'>-- Can't happen</span>
<a name="line-152"></a>                 <span class='hs-varid'>xevdecomp</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>xco</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evTermCoercion</span> <span class='hs-varid'>x</span>
<a name="line-153"></a>                               <span class='hs-keyword'>in</span> <span class='hs-keyglyph'>[</span> <span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcLRCo</span> <span class='hs-conid'>CLeft</span> <span class='hs-varid'>xco</span><span class='hs-layout'>)</span>
<a name="line-154"></a>                                  <span class='hs-layout'>,</span> <span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcLRCo</span> <span class='hs-conid'>CRight</span> <span class='hs-varid'>xco</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-155"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>ctevs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xCtEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-conid'>XEvTerm</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>mkTcEqPred</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcEqPred</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xevcomp</span> <span class='hs-varid'>xevdecomp</span><span class='hs-layout'>)</span>
<a name="line-156"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>canEvVarsCreated</span> <span class='hs-varid'>ctevs</span> <span class='hs-layout'>}</span>
<a name="line-157"></a>
<a name="line-158"></a>
<a name="line-159"></a><a name="canDecomposableTyConApp"></a><span class='hs-comment'>------------------------</span>
<a name="line-160"></a><span class='hs-definition'>canDecomposableTyConApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-161"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-162"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-163"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-164"></a><span class='hs-definition'>canDecomposableTyConApp</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tc2</span> <span class='hs-varid'>tys2</span>
<a name="line-165"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>tc2</span> <span class='hs-varop'>||</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tys1</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tys2</span>
<a name="line-166"></a>    <span class='hs-comment'>-- Fail straight away for better error messages</span>
<a name="line-167"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqFailure</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc2</span> <span class='hs-varid'>tys2</span><span class='hs-layout'>)</span>
<a name="line-168"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-169"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canDecomposableTyConAppOK</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-170"></a>
<a name="line-171"></a><a name="canDecomposableTyConAppOK"></a><span class='hs-definition'>canDecomposableTyConAppOK</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-172"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-173"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-174"></a>
<a name="line-175"></a><span class='hs-definition'>canDecomposableTyConAppOK</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-176"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>xcomp</span> <span class='hs-varid'>xs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>tc1</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>evTermCoercion</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-177"></a>             <span class='hs-varid'>xdecomp</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EvCoercion</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkTcNthCo</span> <span class='hs-varid'>i</span> <span class='hs-layout'>(</span><span class='hs-varid'>evTermCoercion</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys1</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
<a name="line-178"></a>             <span class='hs-varid'>xev</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XEvTerm</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith</span> <span class='hs-varid'>mkTcEqPred</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span><span class='hs-layout'>)</span> <span class='hs-varid'>xcomp</span> <span class='hs-varid'>xdecomp</span>
<a name="line-179"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ctevs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xCtEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>xev</span>
<a name="line-180"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>canEvVarsCreated</span> <span class='hs-varid'>ctevs</span> <span class='hs-layout'>}</span>
<a name="line-181"></a>
<a name="line-182"></a><a name="canEqFailure"></a><span class='hs-definition'>canEqFailure</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-183"></a><span class='hs-comment'>-- See Note [Make sure that insolubles are fully rewritten]</span>
<a name="line-184"></a><span class='hs-definition'>canEqFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-185"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-conid'>FMSubstOnly</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span>
<a name="line-186"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>s2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-conid'>FMSubstOnly</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty2</span>
<a name="line-187"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span>
<a name="line-188"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyword'>of</span>
<a name="line-189"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>emitInsoluble</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span>
<a name="line-190"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"canEqFailure"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-191"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Canonicalising type applications]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Given (s1 t1) ~ ty2, how should we proceed?
The simple things is to see if ty2 is of form (s2 t2), and 
decompose.  By this time s1 and s2 can't be saturated type
function applications, because those have been dealt with 
by an earlier equation in can_eq_nc, so it is always sound to 
decompose.

However, over-eager decomposition gives bad error messages 
for things like
   a b ~ Maybe c
   e f ~ p -> q
Suppose (in the first example) we already know a~Array.  Then if we
decompose the application eagerly, yielding
   a ~ Maybe
   b ~ c
we get an error        "Can't match Array ~ Maybe", 
but we'd prefer to get "Can't match Array b ~ Maybe c".

So instead can_eq_app flattens s1.  If flattening does something, it
rewrites, and goes round can_eq_nc again.  If flattening 
does nothing, then (at least with our present state of knowledge)
we can only decompose, and that is what can_eq_flat_app attempts
to do. 

Note [Make sure that insolubles are fully rewritten]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When an equality fails, we still want to rewrite the equality
all the way down, so that it accurately reflects
 (a) the mutable reference substitution in force at start of solving
 (b) any ty-binds in force at this point in solving
See Note [Kick out insolubles] in TcInteract.
And if we don't do this there is a bad danger that
TcSimplify.applyTyVarDefaulting will find a variable
that has in fact been substituted.

Note [Do not decompose Given polytype equalities]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider [G] (forall a. t1 ~ forall a. t2).  Can we decompose this?
No -- what would the evidence look like?  So instead we simply discard
this given evidence.


Note [Combining insoluble constraints]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
As this point we have an insoluble constraint, like Int~Bool.

 * If it is Wanted, delete it from the cache, so that subsequent
   Int~Bool constraints give rise to separate error messages

 * But if it is Derived, DO NOT delete from cache.  A class constraint
   may get kicked out of the inert set, and then have its functional
   dependency Derived constraints generated a second time. In that
   case we don't want to get two (or more) error messages by
   generating two (or more) insoluble fundep constraints from the same
   class constraint.


Note [Canonical ordering for equality constraints]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Implemented as (<+=) below:

  - Type function applications always come before anything else.
  - Variables always come before non-variables (other than type
      function applications).

Note that we don't need to unfold type synonyms on the RHS to check
the ordering; that is, in the rules above it's OK to consider only
whether something is *syntactically* a type function application or
not.  To illustrate why this is OK, suppose we have an equality of the
form 'tv ~ S a b c', where S is a type synonym which expands to a
top-level application of the type function F, something like

  type S a b c = F d e

Then to canonicalize 'tv ~ S a b c' we flatten the RHS, and since S's
expansion contains type function applications the flattener will do
the expansion and then generate a skolem variable for the type
function application, so we end up with something like this:

  tv ~ x
  F d e ~ x

where x is the skolem variable.  This is one extra equation than
absolutely necessary (we could have gotten away with just 'F d e ~ tv'
if we had noticed that S expanded to a top-level type function
application and flipped it around in the first place) but this way
keeps the code simpler.

Unlike the OutsideIn(X) draft of May 7, 2010, we do not care about the
ordering of tv ~ tv constraints.  There are several reasons why we
might:

  (1) In order to be able to extract a substitution that doesn't
      mention untouchable variables after we are done solving, we might
      prefer to put touchable variables on the left. However, in and
      of itself this isn't necessary; we can always re-orient equality
      constraints at the end if necessary when extracting a substitution.

  (2) To ensure termination we might think it necessary to put
      variables in lexicographic order. However, this isn't actually
      necessary as outlined below.

While building up an inert set of canonical constraints, we maintain
the invariant that the equality constraints in the inert set form an
acyclic rewrite system when viewed as L-R rewrite rules.  Moreover,
the given constraints form an idempotent substitution (i.e. none of
the variables on the LHS occur in any of the RHS's, and type functions
never show up in the RHS at all), the wanted constraints also form an
idempotent substitution, and finally the LHS of a given constraint
never shows up on the RHS of a wanted constraint.  There may, however,
be a wanted LHS that shows up in a given RHS, since we do not rewrite
given constraints with wanted constraints.

Suppose we have an inert constraint set


  tg_1 ~ xig_1         -- givens
  tg_2 ~ xig_2
  ...
  tw_1 ~ xiw_1         -- wanteds
  tw_2 ~ xiw_2
  ...

where each t_i can be either a type variable or a type function
application. Now suppose we take a new canonical equality constraint,
t' ~ xi' (note among other things this means t' does not occur in xi')
and try to react it with the existing inert set.  We show by induction
on the number of t_i which occur in t' ~ xi' that this process will
terminate.

There are several ways t' ~ xi' could react with an existing constraint:

TODO: finish this proof.  The below was for the case where the entire
inert set is an idempotent subustitution...

(b) We could have t' = t_j for some j.  Then we obtain the new
    equality xi_j ~ xi'; note that neither xi_j or xi' contain t_j.  We
    now canonicalize the new equality, which may involve decomposing it
    into several canonical equalities, and recurse on these.  However,
    none of the new equalities will contain t_j, so they have fewer
    occurrences of the t_i than the original equation.

(a) We could have t_j occurring in xi' for some j, with t' /=
    t_j. Then we substitute xi_j for t_j in xi' and continue.  However,
    since none of the t_i occur in xi_j, we have decreased the
    number of t_i that occur in xi', since we eliminated t_j and did not
    introduce any new ones.

\begin{code}
<pre><a name="line-1"></a><a name="canEqLeafFun"></a><span class='hs-definition'>canEqLeafFun</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> 
<a name="line-2"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-3"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- LHS</span>
<a name="line-4"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>    <span class='hs-comment'>-- RHS</span>
<a name="line-5"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-6"></a><span class='hs-definition'>canEqLeafFun</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-7"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tys1</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>fn</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- Over-saturated type function on LHS: </span>
<a name="line-9"></a>    <span class='hs-comment'>-- flatten LHS, leaving an AppTy, and go around again</span>
<a name="line-10"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-conid'>FMFullFlatten</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>tys1</span><span class='hs-layout'>)</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>ps_ty2</span> 
<a name="line-12"></a>                                 <span class='hs-varid'>co1</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>ps_ty2</span><span class='hs-layout'>)</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-14"></a>            <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-15"></a>            <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>can_eq_nc</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-layout'>}</span>
<a name="line-16"></a>
<a name="line-17"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-18"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- ev :: F tys1 ~ ty2,   if not swapped</span>
<a name="line-19"></a>    <span class='hs-comment'>-- ev :: ty2 ~ F tys1,   if swapped                                    </span>
<a name="line-20"></a>    <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tys1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>fn</span> <span class='hs-layout'>)</span>  
<a name="line-21"></a>        <span class='hs-comment'>-- Type functions are never under-saturated</span>
<a name="line-22"></a>        <span class='hs-comment'>-- Previous equation checks for over-saturation</span>
<a name="line-23"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEqLeafFun"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>pprEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>tys1</span><span class='hs-layout'>)</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-24"></a>
<a name="line-25"></a>            <span class='hs-comment'>-- Flatten type function arguments</span>
<a name="line-26"></a>            <span class='hs-comment'>-- cos1 :: xis1 ~ tys1</span>
<a name="line-27"></a>            <span class='hs-comment'>-- co2  :: xi2 ~ ty2</span>
<a name="line-28"></a>      <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis1</span><span class='hs-layout'>,</span><span class='hs-varid'>cos1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flattenMany</span> <span class='hs-conid'>FMFullFlatten</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tys1</span>
<a name="line-29"></a>      <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span>     <span class='hs-conid'>FMFullFlatten</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-30"></a>
<a name="line-31"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fam_head</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>xis1</span>
<a name="line-32"></a>             <span class='hs-varid'>co1</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>cos1</span>
<a name="line-33"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>fam_head</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span>
<a name="line-34"></a>
<a name="line-35"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>k1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>fam_head</span>
<a name="line-36"></a>             <span class='hs-varid'>k2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>xi2</span>
<a name="line-37"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-38"></a>            <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-39"></a>            <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k1</span> <span class='hs-varop'>`isSubKind`</span> <span class='hs-varid'>k2</span>
<a name="line-40"></a>                        <span class='hs-comment'>-- Establish CFunEqCan kind invariant</span>
<a name="line-41"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn</span>
<a name="line-42"></a>                                                   <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-43"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-44"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>checkKind</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>fam_head</span> <span class='hs-varid'>k1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>k2</span> <span class='hs-layout'>}</span>
<a name="line-45"></a>
<a name="line-46"></a><a name="canEqTyVar"></a><span class='hs-comment'>---------------------</span>
<a name="line-47"></a><span class='hs-definition'>canEqTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-48"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> 
<a name="line-49"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>
<a name="line-50"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-51"></a><span class='hs-comment'>-- A TyVar on LHS, but so far un-zonked</span>
<a name="line-52"></a><span class='hs-definition'>canEqTyVar</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>              <span class='hs-comment'>-- ev :: tv ~ s2</span>
<a name="line-53"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEqTyVar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>swapped</span><span class='hs-layout'>)</span>
<a name="line-54"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb_yes</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flattenTyVarOuter</span> <span class='hs-conid'>FMFullFlatten</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tv1</span> 
<a name="line-55"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_yes</span> <span class='hs-keyword'>of</span>
<a name="line-56"></a>           <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- co1 :: ty1 ~ tv1</span>
<a name="line-57"></a>                               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span>  <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-58"></a>                                                            <span class='hs-varid'>co1</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>ps_ty2</span><span class='hs-layout'>)</span>
<a name="line-59"></a>                                  <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEqTyVar2"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>swapped</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span>
<a name="line-60"></a>                                                                  <span class='hs-varid'>ppUnless</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDerived</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-61"></a>                                  <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-62"></a>                                      <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-63"></a>                                      <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>can_eq_nc</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-layout'>}</span>
<a name="line-64"></a>
<a name="line-65"></a>           <span class='hs-conid'>Left</span> <span class='hs-varid'>tv1'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten</span> <span class='hs-conid'>FMFullFlatten</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-comment'>-- co2 :: xi2 ~ ps_ty2</span>
<a name="line-66"></a>                                           <span class='hs-comment'>-- Use ps_ty2 to preserve type synonyms if poss</span>
<a name="line-67"></a>                           <span class='hs-layout'>;</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-68"></a>                           <span class='hs-layout'>;</span> <span class='hs-varid'>canEqTyVar2</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>tv1'</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>co2</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-69"></a>
<a name="line-70"></a><a name="canEqTyVar2"></a><span class='hs-definition'>canEqTyVar2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-71"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>   <span class='hs-comment'>-- olhs ~ orhs (or, if swapped, orhs ~ olhs)</span>
<a name="line-72"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-73"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span>      <span class='hs-comment'>-- olhs</span>
<a name="line-74"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>       <span class='hs-comment'>-- nrhs</span>
<a name="line-75"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcCoercion</span>   <span class='hs-comment'>-- nrhs ~ orhs</span>
<a name="line-76"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-77"></a><span class='hs-comment'>-- LHS is an inert type variable, </span>
<a name="line-78"></a><span class='hs-comment'>-- and RHS is fully rewritten, but with type synonyms</span>
<a name="line-79"></a><span class='hs-comment'>-- preserved as must as possible</span>
<a name="line-80"></a>
<a name="line-81"></a><span class='hs-definition'>canEqTyVar2</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>co2</span>
<a name="line-82"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTyVar_maybe</span> <span class='hs-varid'>xi2</span>
<a name="line-83"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqTyVarTyVar</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>tv2</span> <span class='hs-varid'>co2</span>
<a name="line-84"></a>
<a name="line-85"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OC_OK</span> <span class='hs-varid'>xi2'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>occurCheckExpand</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>xi2</span>  <span class='hs-comment'>-- No occurs check</span>
<a name="line-86"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2'</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span>
<a name="line-87"></a>                <span class='hs-comment'>-- Ensure that the new goal has enough type synonyms</span>
<a name="line-88"></a>                <span class='hs-comment'>-- expanded by the occurCheckExpand; hence using xi2' here</span>
<a name="line-89"></a>                <span class='hs-comment'>-- See Note [occurCheckExpand]</span>
<a name="line-90"></a>
<a name="line-91"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>k1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv1</span>
<a name="line-92"></a>             <span class='hs-varid'>k2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>xi2'</span>
<a name="line-93"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-94"></a>            <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-95"></a>            <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k2</span> <span class='hs-varop'>`isSubKind`</span> <span class='hs-varid'>k1</span>
<a name="line-96"></a>                        <span class='hs-comment'>-- Establish CTyEqCan kind invariant</span>
<a name="line-97"></a>                        <span class='hs-comment'>-- Reorientation has done its best, but the kinds might</span>
<a name="line-98"></a>                        <span class='hs-comment'>-- simply be incompatible</span>
<a name="line-99"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ev</span>
<a name="line-100"></a>                                                  <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi2'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-101"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-102"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>checkKind</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>k1</span> <span class='hs-varid'>xi2'</span> <span class='hs-varid'>k2</span> <span class='hs-layout'>}</span>
<a name="line-103"></a>
<a name="line-104"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- Occurs check error</span>
<a name="line-105"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span>
<a name="line-106"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-107"></a>           <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-108"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>emitInsoluble</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span>
<a name="line-109"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span>
<a name="line-110"></a>  <span class='hs-keyword'>where</span>
<a name="line-111"></a>    <span class='hs-varid'>xi1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv1</span>
<a name="line-112"></a>    <span class='hs-varid'>co1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>xi1</span>
<a name="line-113"></a>
<a name="line-114"></a>
<a name="line-115"></a><a name="canEqTyVarTyVar"></a><span class='hs-definition'>canEqTyVarTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>       <span class='hs-comment'>-- tv1 ~ orhs (or orhs ~ tv1, if swapped)</span>
<a name="line-116"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-117"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVar</span>   <span class='hs-comment'>-- tv2, tv2</span>
<a name="line-118"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcCoercion</span>       <span class='hs-comment'>-- tv2 ~ orhs</span>
<a name="line-119"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-120"></a><span class='hs-comment'>-- Both LHS and RHS rewrote to a type variable,</span>
<a name="line-121"></a><span class='hs-definition'>canEqTyVarTyVar</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>tv2</span> <span class='hs-varid'>co2</span>
<a name="line-122"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tv2</span>
<a name="line-123"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-124"></a>         <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>tcCoercionRole</span> <span class='hs-varid'>co2</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Nominal</span> <span class='hs-layout'>)</span>
<a name="line-125"></a>         <span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev_evar</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>maybeSym</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-126"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span>  
<a name="line-127"></a>
<a name="line-128"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>reorient_me</span>  <span class='hs-comment'>-- See note [Canonical ordering for equality constraints].</span>
<a name="line-129"></a>                 <span class='hs-comment'>-- True =&gt; the kinds are compatible, </span>
<a name="line-130"></a>                 <span class='hs-comment'>--         so no need for further sub-kind check</span>
<a name="line-131"></a>                 <span class='hs-comment'>-- If swapped = NotSwapped, then</span>
<a name="line-132"></a>                 <span class='hs-comment'>--     rw_orhs = tv1, rw_olhs = orhs</span>
<a name="line-133"></a>                 <span class='hs-comment'>--     rw_nlhs = tv2, rw_nrhs = xi1</span>
<a name="line-134"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>flipSwap</span> <span class='hs-varid'>swapped</span><span class='hs-layout'>)</span>  <span class='hs-varid'>xi2</span> <span class='hs-varid'>xi1</span>
<a name="line-135"></a>                                 <span class='hs-varid'>co2</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>xi1</span><span class='hs-layout'>)</span>
<a name="line-136"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-137"></a>           <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-138"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ev</span>
<a name="line-139"></a>                                                 <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi1</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-140"></a>
<a name="line-141"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-142"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span> 
<a name="line-143"></a>                                 <span class='hs-layout'>(</span><span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>xi1</span><span class='hs-layout'>)</span> <span class='hs-varid'>co2</span>
<a name="line-144"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb</span> <span class='hs-keyword'>of</span>
<a name="line-145"></a>           <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-146"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k2</span> <span class='hs-varop'>`isSubKind`</span> <span class='hs-varid'>k1</span>
<a name="line-147"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ev</span>
<a name="line-148"></a>                                                 <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-149"></a>                       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-150"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>checkKind</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>k1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>k2</span> <span class='hs-layout'>}</span> 
<a name="line-151"></a>  <span class='hs-keyword'>where</span>
<a name="line-152"></a>    <span class='hs-varid'>reorient_me</span> 
<a name="line-153"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k1</span> <span class='hs-varop'>`tcEqKind`</span> <span class='hs-varid'>k2</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv2</span> <span class='hs-varop'>`better_than`</span> <span class='hs-varid'>tv1</span>
<a name="line-154"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k1</span> <span class='hs-varop'>`isSubKind`</span> <span class='hs-varid'>k2</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>  <span class='hs-comment'>-- Note [Kind orientation for CTyEqCan]</span>
<a name="line-155"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- in TcRnTypes</span>
<a name="line-156"></a>
<a name="line-157"></a>    <span class='hs-varid'>xi1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv1</span>
<a name="line-158"></a>    <span class='hs-varid'>xi2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv2</span>
<a name="line-159"></a>    <span class='hs-varid'>k1</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv1</span>
<a name="line-160"></a>    <span class='hs-varid'>k2</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv2</span>
<a name="line-161"></a>
<a name="line-162"></a>    <span class='hs-varid'>tv2</span> <span class='hs-varop'>`better_than`</span> <span class='hs-varid'>tv1</span>
<a name="line-163"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>tv1</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>   <span class='hs-comment'>-- Never swap a meta-tyvar</span>
<a name="line-164"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFlatSkolTyVar</span> <span class='hs-varid'>tv1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>tv2</span>
<a name="line-165"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>tv2</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isFlatSkolTyVar</span> <span class='hs-varid'>tv2</span>
<a name="line-166"></a>                            <span class='hs-comment'>-- Note [Eliminate flat-skols]</span>
<a name="line-167"></a>
<a name="line-168"></a><a name="checkKind"></a><span class='hs-definition'>checkKind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>         <span class='hs-comment'>-- t1~t2</span>
<a name="line-169"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcKind</span>
<a name="line-170"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcKind</span>   <span class='hs-comment'>-- s1~s2, flattened and zonked</span>
<a name="line-171"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-172"></a><span class='hs-comment'>-- LHS and RHS have incompatible kinds, so emit an "irreducible" constraint</span>
<a name="line-173"></a><span class='hs-comment'>--       CIrredEvCan (NOT CTyEqCan or CFunEqCan)</span>
<a name="line-174"></a><span class='hs-comment'>-- for the type equality; and continue with the kind equality constraint.</span>
<a name="line-175"></a><span class='hs-comment'>-- When the latter is solved, it'll kick out the irreducible equality for</span>
<a name="line-176"></a><span class='hs-comment'>-- a second attempt at solving</span>
<a name="line-177"></a>
<a name="line-178"></a><span class='hs-definition'>checkKind</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>k1</span> <span class='hs-varid'>s2</span> <span class='hs-varid'>k2</span>   <span class='hs-comment'>-- See Note [Equalities with incompatible kinds]</span>
<a name="line-179"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isKind</span> <span class='hs-varid'>k1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isKind</span> <span class='hs-varid'>k2</span> <span class='hs-layout'>)</span>
<a name="line-180"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEqLeaf: incompatible kinds"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>k1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>k2</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-181"></a>
<a name="line-182"></a>         <span class='hs-comment'>-- Create a derived kind-equality, and solve it</span>
<a name="line-183"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mw</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newDerived</span> <span class='hs-varid'>kind_co_loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkEqPred</span> <span class='hs-varid'>k1</span> <span class='hs-varid'>k2</span><span class='hs-layout'>)</span>
<a name="line-184"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mw</span> <span class='hs-keyword'>of</span>
<a name="line-185"></a>           <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-186"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>kev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>emitWorkNC</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>kev</span><span class='hs-keyglyph'>]</span>
<a name="line-187"></a>
<a name="line-188"></a>         <span class='hs-comment'>-- Put the not-currently-soluble thing into the inert set</span>
<a name="line-189"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-conid'>CIrredEvCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-190"></a>  <span class='hs-keyword'>where</span>
<a name="line-191"></a>    <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-varid'>new_ev</span>
<a name="line-192"></a>    <span class='hs-varid'>kind_co_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setCtLocOrigin</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-conid'>KindEqOrigin</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctLocOrigin</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Eliminate flat-skols]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose we have  [G] Num (F [a])
then we flatten to
     [G] Num fsk
     [G] F [a] ~ fsk
where fsk is a flatten-skolem (FlatSkol). Suppose we have
      type instance F [a] = a
then we'll reduce the second constraint to
     [G] a ~ fsk
and then replace all uses of 'a' with fsk.  That's bad because
in error messages intead of saying 'a' we'll say (F [a]).  In all
places, including those where the programmer wrote 'a' in the first
place.  Very confusing!  See Trac #7862.

Solution: re-orient a~fsk to fsk~a, so that we preferentially eliminate
the fsk.

Note [Equalities with incompatible kinds]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
canEqLeaf is about to make a CTyEqCan or CFunEqCan; but both have the
invariant that LHS and RHS satisfy the kind invariants for CTyEqCan,
CFunEqCan.  What if we try to unify two things with incompatible
kinds?

eg    a ~ b  where a::*, b::*->*
or    a ~ b  where a::*, b::k, k is a kind variable

The CTyEqCan compatKind invariant is important.  If we make a CTyEqCan
for a~b, then we might well *substitute* 'b' for 'a', and that might make
a well-kinded type ill-kinded; and that is bad (eg typeKind can crash, see
Trac #7696).

So instead for these ill-kinded equalities we generate a CIrredCan,
and put it in the inert set, which keeps it out of the way until a
subsequent substitution (on kind variables, say) re-activates it.

NB: it is important that the types s1,s2 are flattened and zonked
    so that their kinds k1, k2 are inert wrt the substitution.  That
    means that they can only become the same if we change the inert
    set, which in turn will kick out the irreducible equality
    E.g. it is WRONG to make an irred (a:k1)~(b:k2)
         if we already have a substitution k1:=k2

NB: it's important that the new CIrredCan goes in the inert set rather
than back into the work list. We used to do the latter, but that led
to an infinite loop when we encountered it again, and put it back it
the work list again.

See also Note [Kind orientation for CTyEqCan] and
         Note [Kind orientation for CFunEqCan] in TcRnTypes

Note [Type synonyms and canonicalization]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We treat type synonym applications as xi types, that is, they do not
count as type function applications.  However, we do need to be a bit
careful with type synonyms: like type functions they may not be
generative or injective.  However, unlike type functions, they are
parametric, so there is no problem in expanding them whenever we see
them, since we do not need to know anything about their arguments in
order to expand them; this is what justifies not having to treat them
as specially as type function applications.  The thing that causes
some subtleties is that we prefer to leave type synonym applications
*unexpanded* whenever possible, in order to generate better error
messages.

If we encounter an equality constraint with type synonym applications
on both sides, or a type synonym application on one side and some sort
of type application on the other, we simply must expand out the type
synonyms in order to continue decomposing the equality constraint into
primitive equality constraints.  For example, suppose we have

  type F a = [Int]

and we encounter the equality

  F a ~ [b]

In order to continue we must expand F a into [Int], giving us the
equality

  [Int] ~ [b]

which we can then decompose into the more primitive equality
constraint

  Int ~ b.

However, if we encounter an equality constraint with a type synonym
application on one side and a variable on the other side, we should
NOT (necessarily) expand the type synonym, since for the purpose of
good error messages we want to leave type synonyms unexpanded as much
as possible.  Hence the ps_ty1, ps_ty2 argument passed to canEqTyVar.


Note [occurCheckExpand]
~~~~~~~~~~~~~~~~~~~~~~~
There is a subtle point with type synonyms and the occurs check that
takes place for equality constraints of the form tv ~ xi.  As an
example, suppose we have

  type F a = Int

and we come across the equality constraint

  a ~ F a

This should not actually fail the occurs check, since expanding out
the type synonym results in the legitimate equality constraint a ~
Int.  We must actually do this expansion, because unifying a with F a
will lead the type checker into infinite loops later.  Put another
way, canonical equality constraints should never *syntactically*
contain the LHS variable in the RHS type.  However, we don't always
need to expand type synonyms when doing an occurs check; for example,
the constraint

  a ~ F b

is obviously fine no matter what F expands to. And in this case we
would rather unify a with F b (rather than F b's expansion) in order
to get better error messages later.

So, when doing an occurs check with a type synonym application on the
RHS, we use some heuristics to find an expansion of the RHS which does
not contain the variable from the LHS.  In particular, given

  a ~ F t1 ... tn

we first try expanding each of the ti to types which no longer contain
a.  If this turns out to be impossible, we next try expanding F
itself, and so on.  See Note [Occurs check expansion] in TcType

</body>
</html>
