<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcValidity.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
%
% (c) The University of Glasgow 2006
% (c) The GRASP/AQUA Project, Glasgow University, 1992-1998
%

\begin{code}
<pre><a name="line-1"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcValidity</span> <span class='hs-layout'>(</span>
<a name="line-2"></a>  <span class='hs-conid'>Rank</span><span class='hs-layout'>,</span> <span class='hs-conid'>UserTypeCtxt</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkValidType</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkValidMonoType</span><span class='hs-layout'>,</span>
<a name="line-3"></a>  <span class='hs-varid'>expectedKindInCtxt</span><span class='hs-layout'>,</span> 
<a name="line-4"></a>  <span class='hs-varid'>checkValidTheta</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkValidFamPats</span><span class='hs-layout'>,</span>
<a name="line-5"></a>  <span class='hs-varid'>checkValidInstance</span><span class='hs-layout'>,</span> <span class='hs-varid'>validDerivPred</span><span class='hs-layout'>,</span>
<a name="line-6"></a>  <span class='hs-varid'>checkInstTermination</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkValidTyFamInst</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkTyFamFreeness</span><span class='hs-layout'>,</span> 
<a name="line-7"></a>  <span class='hs-varid'>checkConsistentFamInst</span><span class='hs-layout'>,</span>
<a name="line-8"></a>  <span class='hs-varid'>arityErr</span><span class='hs-layout'>,</span> <span class='hs-varid'>badATErr</span>
<a name="line-9"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-12"></a>
<a name="line-13"></a><span class='hs-comment'>-- friends:</span>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcUnify</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>tcSubType</span> <span class='hs-layout'>)</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSimplify</span> <span class='hs-layout'>(</span> <span class='hs-varid'>simplifyAmbiguityCheck</span> <span class='hs-layout'>)</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TypeRep</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcMType</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TysWiredIn</span> <span class='hs-layout'>(</span> <span class='hs-varid'>coercibleClass</span> <span class='hs-layout'>)</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unify</span><span class='hs-layout'>(</span> <span class='hs-varid'>tcMatchTyX</span> <span class='hs-layout'>)</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Kind</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoAxiom</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-26"></a>
<a name="line-27"></a><span class='hs-comment'>-- others:</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>HsSyn</span>            <span class='hs-comment'>-- HsType</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnMonad</span>        <span class='hs-comment'>-- TcType, amongst others</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FunDeps</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ErrUtils</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Maybes</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ListSetOps</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>SrcLoc</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Arity</span> <span class='hs-layout'>)</span>
<a name="line-43"></a>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span>        <span class='hs-layout'>(</span> <span class='hs-layout'>(</span><span class='hs-varop'>\\</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
</pre>\end{code}
 

%************************************************************************
%*                                                                      *
          Checking for ambiguity
%*                                                                      *
%************************************************************************


\begin{code}
<pre><a name="line-1"></a><a name="checkAmbiguity"></a><span class='hs-definition'>checkAmbiguity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2"></a><span class='hs-definition'>checkAmbiguity</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GhciCtxt</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ctxt</span>    <span class='hs-comment'>-- Allow ambiguous types in GHCi's :kind command</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>           <span class='hs-comment'>-- E.g.   type family T a :: *  -- T :: forall k. k -&gt; *</span>
<a name="line-5"></a>                        <span class='hs-comment'>-- Then :k T should work in GHCi, not complain that</span>
<a name="line-6"></a>                        <span class='hs-comment'>-- (T k) is ambiguous!</span>
<a name="line-7"></a>
<a name="line-8"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"Ambiguity check for"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-10"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>free_tkvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>varSetElemsKvsFirst</span> <span class='hs-layout'>(</span><span class='hs-varid'>closeOverKinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-sel'>_tvs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInstSkolTyVars</span> <span class='hs-varid'>free_tkvs</span>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>ty</span>
<a name="line-13"></a>              <span class='hs-comment'>-- The type might have free TyVars, esp when the ambiguity check</span>
<a name="line-14"></a>              <span class='hs-comment'>-- happens during a call to checkValidType,</span>
<a name="line-15"></a>              <span class='hs-comment'>-- so we skolemise them as TcTyVars.</span>
<a name="line-16"></a>              <span class='hs-comment'>-- Tiresome; but the type inference engine expects TcTyVars</span>
<a name="line-17"></a>              <span class='hs-comment'>-- NB: The free tyvar might be (a::k), so k is also free</span>
<a name="line-18"></a>              <span class='hs-comment'>--     and we must skolemise it as well. Hence closeOverKinds.</span>
<a name="line-19"></a>              <span class='hs-comment'>--     (Trac #9222)</span>
<a name="line-20"></a>
<a name="line-21"></a>         <span class='hs-comment'>-- Solve the constraints eagerly because an ambiguous type</span>
<a name="line-22"></a>         <span class='hs-comment'>-- can cause a cascade of further errors.  Since the free</span>
<a name="line-23"></a>         <span class='hs-comment'>-- tyvars are skolemised, we can safely use tcSimplifyTop</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-sel'>_wrap</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addErrCtxtM</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_msg</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-25"></a>                            <span class='hs-varid'>captureConstraints</span> <span class='hs-varop'>$</span>
<a name="line-26"></a>                            <span class='hs-varid'>tcSubType</span> <span class='hs-layout'>(</span><span class='hs-conid'>AmbigOrigin</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty'</span> <span class='hs-varid'>ty'</span>
<a name="line-27"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>simplifyAmbiguityCheck</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>wanted</span>
<a name="line-28"></a>
<a name="line-29"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"Done ambiguity check for"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-30"></a> <span class='hs-keyword'>where</span>
<a name="line-31"></a>   <span class='hs-varid'>mk_msg</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tidy_env</span>
<a name="line-32"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>allow_ambiguous</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_AllowAmbiguousTypes</span>
<a name="line-33"></a>          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>tidy_env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>msg</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppWhen</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>allow_ambiguous</span><span class='hs-layout'>)</span> <span class='hs-varid'>ambig_msg</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-34"></a>     <span class='hs-keyword'>where</span>
<a name="line-35"></a>       <span class='hs-layout'>(</span><span class='hs-varid'>tidy_env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tidy_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tidyOpenType</span> <span class='hs-varid'>tidy_env</span> <span class='hs-varid'>ty</span>
<a name="line-36"></a>       <span class='hs-varid'>msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"In the ambiguity check for:"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-37"></a>                <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tidy_ty</span><span class='hs-layout'>)</span>
<a name="line-38"></a>       <span class='hs-varid'>ambig_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"To defer the ambiguity check to use sites, enable AllowAmbiguousTypes"</span><span class='hs-layout'>)</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
          Checking validity of a user-defined type
%*                                                                      *
%************************************************************************

When dealing with a user-written type, we first translate it from an HsType
to a Type, performing kind checking, and then check various things that should 
be true about it.  We don't want to perform these checks at the same time
as the initial translation because (a) they are unnecessary for interface-file
types and (b) when checking a mutually recursive group of type and class decls,
we can't "look" at the tycons/classes yet.  Also, the checks are are rather
diverse, and used to really mess up the other code.

One thing we check for is 'rank'.  

        Rank 0:         monotypes (no foralls)
        Rank 1:         foralls at the front only, Rank 0 inside
        Rank 2:         foralls at the front, Rank 1 on left of fn arrow,

        basic ::= tyvar | T basic ... basic

        r2  ::= forall tvs. cxt => r2a
        r2a ::= r1 -> r2a | basic
        r1  ::= forall tvs. cxt => r0
        r0  ::= r0 -> r0 | basic
        
Another thing is to check that type synonyms are saturated. 
This might not necessarily show up in kind checking.
        type A i = i
        data T k = MkT (k Int)
        f :: T A        -- BAD!

        
\begin{code}
<pre><a name="line-1"></a><a name="checkValidType"></a><span class='hs-definition'>checkValidType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2"></a><span class='hs-comment'>-- Checks that the type is valid for the given context</span>
<a name="line-3"></a><span class='hs-comment'>-- Not used for instance decls; checkValidInstance instead</span>
<a name="line-4"></a><span class='hs-definition'>checkValidType</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span> 
<a name="line-5"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"checkValidType"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"::"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-6"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rankn_flag</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_RankNTypes</span>
<a name="line-7"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>gen_rank</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Rank</span>
<a name="line-8"></a>             <span class='hs-varid'>gen_rank</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>rankn_flag</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArbitraryRank</span>
<a name="line-9"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-10"></a>
<a name="line-11"></a>             <span class='hs-varid'>rank1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gen_rank</span> <span class='hs-varid'>r1</span>
<a name="line-12"></a>             <span class='hs-varid'>rank0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gen_rank</span> <span class='hs-varid'>r0</span>
<a name="line-13"></a>
<a name="line-14"></a>             <span class='hs-varid'>r0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rankZeroMonoType</span>
<a name="line-15"></a>             <span class='hs-varid'>r1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LimitedRank</span> <span class='hs-conid'>True</span> <span class='hs-varid'>r0</span>
<a name="line-16"></a>
<a name="line-17"></a>             <span class='hs-varid'>rank</span>
<a name="line-18"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-19"></a>                 <span class='hs-conid'>DefaultDeclCtxt</span><span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MustBeMonoType</span>
<a name="line-20"></a>                 <span class='hs-conid'>ResSigCtxt</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MustBeMonoType</span>
<a name="line-21"></a>                 <span class='hs-conid'>LamPatSigCtxt</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank0</span>
<a name="line-22"></a>                 <span class='hs-conid'>BindPatSigCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank0</span>
<a name="line-23"></a>                 <span class='hs-conid'>RuleSigCtxt</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-24"></a>                 <span class='hs-conid'>TySynCtxt</span> <span class='hs-keyword'>_</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank0</span>
<a name="line-25"></a>
<a name="line-26"></a>                 <span class='hs-conid'>ExprSigCtxt</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-27"></a>                 <span class='hs-conid'>FunSigCtxt</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-28"></a>                 <span class='hs-conid'>InfSigCtxt</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArbitraryRank</span>        <span class='hs-comment'>-- Inferred type</span>
<a name="line-29"></a>                 <span class='hs-conid'>ConArgCtxt</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span> <span class='hs-comment'>-- We are given the type of the entire</span>
<a name="line-30"></a>                                         <span class='hs-comment'>-- constructor, hence rank 1</span>
<a name="line-31"></a>
<a name="line-32"></a>                 <span class='hs-conid'>ForSigCtxt</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-33"></a>                 <span class='hs-conid'>SpecInstCtxt</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-34"></a>                 <span class='hs-conid'>ThBrackCtxt</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-35"></a>                 <span class='hs-conid'>GhciCtxt</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArbitraryRank</span>
<a name="line-36"></a>                 <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"checkValidType"</span>
<a name="line-37"></a>                                          <span class='hs-comment'>-- Can't happen; not used for *user* sigs</span>
<a name="line-38"></a>
<a name="line-39"></a>        <span class='hs-comment'>-- Check the internal validity of the type itself</span>
<a name="line-40"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span>
<a name="line-41"></a>
<a name="line-42"></a>        <span class='hs-comment'>-- Check that the thing has kind Type, and is lifted if necessary</span>
<a name="line-43"></a>        <span class='hs-comment'>-- Do this second, because we can't usefully take the kind of an </span>
<a name="line-44"></a>        <span class='hs-comment'>-- ill-formed type such as (a~Int)</span>
<a name="line-45"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>check_kind</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span>
<a name="line-46"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"checkValidType done"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"::"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-47"></a>
<a name="line-48"></a><a name="checkValidMonoType"></a><span class='hs-definition'>checkValidMonoType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-49"></a><span class='hs-definition'>checkValidMonoType</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_mono_type</span> <span class='hs-conid'>SigmaCtxt</span> <span class='hs-conid'>MustBeMonoType</span> <span class='hs-varid'>ty</span>
<a name="line-50"></a>
<a name="line-51"></a>
<a name="line-52"></a><a name="check_kind"></a><span class='hs-definition'>check_kind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-53"></a><span class='hs-comment'>-- Check that the type's kind is acceptable for the context</span>
<a name="line-54"></a><span class='hs-definition'>check_kind</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span>
<a name="line-55"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TySynCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ctxt</span>
<a name="line-56"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ck</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_ConstraintKinds</span>
<a name="line-57"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-varid'>ck</span> <span class='hs-varop'>$</span>
<a name="line-58"></a>         <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>returnsConstraintKind</span> <span class='hs-varid'>actual_kind</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> 
<a name="line-59"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>constraintSynErr</span> <span class='hs-varid'>actual_kind</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-60"></a>
<a name="line-61"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>expectedKindInCtxt</span> <span class='hs-varid'>ctxt</span>
<a name="line-62"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcIsSubKind</span> <span class='hs-varid'>actual_kind</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>kindErr</span> <span class='hs-varid'>actual_kind</span><span class='hs-layout'>)</span>
<a name="line-63"></a>
<a name="line-64"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-65"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>   <span class='hs-comment'>-- Any kind will do</span>
<a name="line-66"></a>  <span class='hs-keyword'>where</span>
<a name="line-67"></a>    <span class='hs-varid'>actual_kind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>ty</span>
<a name="line-68"></a>
<a name="line-69"></a><a name="expectedKindInCtxt"></a><span class='hs-comment'>-- Depending on the context, we might accept any kind (for instance, in a TH</span>
<a name="line-70"></a><span class='hs-comment'>-- splice), or only certain kinds (like in type signatures).</span>
<a name="line-71"></a><span class='hs-definition'>expectedKindInCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Kind</span>
<a name="line-72"></a><span class='hs-definition'>expectedKindInCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TySynCtxt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> <span class='hs-comment'>-- Any kind will do</span>
<a name="line-73"></a><span class='hs-definition'>expectedKindInCtxt</span> <span class='hs-conid'>ThBrackCtxt</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-74"></a><span class='hs-definition'>expectedKindInCtxt</span> <span class='hs-conid'>GhciCtxt</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-75"></a><span class='hs-definition'>expectedKindInCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForSigCtxt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>liftedTypeKind</span>
<a name="line-76"></a><span class='hs-definition'>expectedKindInCtxt</span> <span class='hs-conid'>InstDeclCtxt</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>constraintKind</span>
<a name="line-77"></a><span class='hs-definition'>expectedKindInCtxt</span> <span class='hs-conid'>SpecInstCtxt</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>constraintKind</span>
<a name="line-78"></a><span class='hs-definition'>expectedKindInCtxt</span> <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>openTypeKind</span>
</pre>\end{code}

Note [Higher rank types]
~~~~~~~~~~~~~~~~~~~~~~~~
Technically 
            Int -> forall a. a->a
is still a rank-1 type, but it's not Haskell 98 (Trac #5957).  So the
validity checker allow a forall after an arrow only if we allow it
before -- that is, with Rank2Types or RankNTypes

\begin{code}
<pre><a name="line-1"></a><a name="Rank"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArbitraryRank</span>         <span class='hs-comment'>-- Any rank ok</span>
<a name="line-2"></a>
<a name="line-3"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LimitedRank</span>   <span class='hs-comment'>-- Note [Higher rank types]</span>
<a name="line-4"></a>                 <span class='hs-conid'>Bool</span>     <span class='hs-comment'>-- Forall ok at top</span>
<a name="line-5"></a>                 <span class='hs-conid'>Rank</span>     <span class='hs-comment'>-- Use for function arguments</span>
<a name="line-6"></a>
<a name="line-7"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>MonoType</span> <span class='hs-conid'>SDoc</span>   <span class='hs-comment'>-- Monotype, with a suggestion of how it could be a polytype</span>
<a name="line-8"></a>  
<a name="line-9"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>MustBeMonoType</span>  <span class='hs-comment'>-- Monotype regardless of flags</span>
<a name="line-10"></a>
<a name="line-11"></a><a name="rankZeroMonoType"></a><span class='hs-definition'>rankZeroMonoType</span><span class='hs-layout'>,</span> <span class='hs-varid'>tyConArgMonoType</span><span class='hs-layout'>,</span> <span class='hs-varid'>synArgMonoType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rank</span>
<a name="line-12"></a><span class='hs-definition'>rankZeroMonoType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MonoType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Perhaps you intended to use RankNTypes or Rank2Types"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-13"></a><a name="tyConArgMonoType"></a><span class='hs-definition'>tyConArgMonoType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MonoType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Perhaps you intended to use ImpredicativeTypes"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-14"></a><a name="synArgMonoType"></a><span class='hs-definition'>synArgMonoType</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MonoType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Perhaps you intended to use LiberalTypeSynonyms"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-15"></a>
<a name="line-16"></a><a name="funArgResRank"></a><span class='hs-definition'>funArgResRank</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rank</span><span class='hs-layout'>,</span> <span class='hs-conid'>Rank</span><span class='hs-layout'>)</span>             <span class='hs-comment'>-- Function argument and result</span>
<a name="line-17"></a><span class='hs-definition'>funArgResRank</span> <span class='hs-layout'>(</span><span class='hs-conid'>LimitedRank</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>arg_rank</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_rank</span><span class='hs-layout'>,</span> <span class='hs-conid'>LimitedRank</span> <span class='hs-layout'>(</span><span class='hs-varid'>forAllAllowed</span> <span class='hs-varid'>arg_rank</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_rank</span><span class='hs-layout'>)</span>
<a name="line-18"></a><span class='hs-definition'>funArgResRank</span> <span class='hs-varid'>other_rank</span>               <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>other_rank</span><span class='hs-layout'>,</span> <span class='hs-varid'>other_rank</span><span class='hs-layout'>)</span>
<a name="line-19"></a>
<a name="line-20"></a><a name="forAllAllowed"></a><span class='hs-definition'>forAllAllowed</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-21"></a><span class='hs-definition'>forAllAllowed</span> <span class='hs-conid'>ArbitraryRank</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-22"></a><span class='hs-definition'>forAllAllowed</span> <span class='hs-layout'>(</span><span class='hs-conid'>LimitedRank</span> <span class='hs-varid'>forall_ok</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forall_ok</span>
<a name="line-23"></a><span class='hs-definition'>forAllAllowed</span> <span class='hs-keyword'>_</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-24"></a>
<a name="line-25"></a><a name="check_mono_type"></a><span class='hs-comment'>----------------------------------------</span>
<a name="line-26"></a><span class='hs-definition'>check_mono_type</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Rank</span>
<a name="line-27"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>KindOrType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span> <span class='hs-comment'>-- No foralls anywhere</span>
<a name="line-28"></a>                                        <span class='hs-comment'>-- No unlifted types of any kind</span>
<a name="line-29"></a><span class='hs-definition'>check_mono_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span>
<a name="line-30"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isKind</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>  <span class='hs-comment'>-- IA0_NOTE: Do we need to check kinds?</span>
<a name="line-31"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-32"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span>
<a name="line-33"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isUnLiftedType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>unliftedArgErr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-34"></a>
<a name="line-35"></a><a name="check_type"></a><span class='hs-definition'>check_type</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-36"></a><span class='hs-comment'>-- The args say what the *type context* requires, independent</span>
<a name="line-37"></a><span class='hs-comment'>-- of *flag* settings.  You test the flag settings at usage sites.</span>
<a name="line-38"></a><span class='hs-comment'>-- </span>
<a name="line-39"></a><span class='hs-comment'>-- Rank is allowed rank for function args</span>
<a name="line-40"></a><span class='hs-comment'>-- Rank 0 means no for-alls anywhere</span>
<a name="line-41"></a>
<a name="line-42"></a><span class='hs-definition'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span>
<a name="line-43"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-44"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>forAllAllowed</span> <span class='hs-varid'>rank</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>forAllTyErr</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-45"></a>                <span class='hs-comment'>-- Reject e.g. (Maybe (?x::Int =&gt; Int)), </span>
<a name="line-46"></a>                <span class='hs-comment'>-- with a decent error message</span>
<a name="line-47"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_valid_theta</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>theta</span>
<a name="line-48"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>tau</span>      <span class='hs-comment'>-- Allow foralls to right of arrow</span>
<a name="line-49"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkAmbiguity</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span>
<a name="line-50"></a>  <span class='hs-keyword'>where</span>
<a name="line-51"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>tau</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitSigmaTy</span> <span class='hs-varid'>ty</span>
<a name="line-52"></a>   
<a name="line-53"></a><span class='hs-definition'>check_type</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-54"></a>
<a name="line-55"></a><span class='hs-definition'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-56"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>arg_rank</span> <span class='hs-varid'>arg_ty</span>
<a name="line-57"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>res_rank</span> <span class='hs-varid'>res_ty</span> <span class='hs-layout'>}</span>
<a name="line-58"></a>  <span class='hs-keyword'>where</span>
<a name="line-59"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>arg_rank</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_rank</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>funArgResRank</span> <span class='hs-varid'>rank</span>
<a name="line-60"></a>
<a name="line-61"></a><span class='hs-definition'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-62"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>check_arg_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty1</span>
<a name="line-63"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_arg_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty2</span> <span class='hs-layout'>}</span>
<a name="line-64"></a>
<a name="line-65"></a><span class='hs-definition'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-66"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTypeSynonymTyCon</span> <span class='hs-varid'>tc</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_syn_tc_app</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-67"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isUnboxedTupleTyCon</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_ubx_tuple</span>  <span class='hs-varid'>ctxt</span>      <span class='hs-varid'>ty</span>    <span class='hs-varid'>tys</span>
<a name="line-68"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_arg_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-69"></a>
<a name="line-70"></a><span class='hs-definition'>check_type</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-71"></a>
<a name="line-72"></a><span class='hs-definition'>check_type</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"check_type"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-73"></a>
<a name="line-74"></a><a name="check_syn_tc_app"></a><span class='hs-comment'>----------------------------------------</span>
<a name="line-75"></a><span class='hs-definition'>check_syn_tc_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>KindOrType</span> 
<a name="line-76"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>KindOrType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-77"></a><span class='hs-definition'>check_syn_tc_app</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-78"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc_arity</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>n_args</span>   <span class='hs-comment'>-- Saturated</span>
<a name="line-79"></a>       <span class='hs-comment'>-- Check that the synonym has enough args</span>
<a name="line-80"></a>       <span class='hs-comment'>-- This applies equally to open and closed synonyms</span>
<a name="line-81"></a>       <span class='hs-comment'>-- It's OK to have an *over-applied* type synonym</span>
<a name="line-82"></a>       <span class='hs-comment'>--      data Tree a b = ...</span>
<a name="line-83"></a>       <span class='hs-comment'>--      type Foo a = Tree [a]</span>
<a name="line-84"></a>       <span class='hs-comment'>--      f :: Foo a b -&gt; ...</span>
<a name="line-85"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-comment'>-- See Note [Liberal type synonyms]</span>
<a name="line-86"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>liberal</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_LiberalTypeSynonyms</span>
<a name="line-87"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>not</span> <span class='hs-varid'>liberal</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isSynFamilyTyCon</span> <span class='hs-varid'>tc</span> <span class='hs-keyword'>then</span>
<a name="line-88"></a>                <span class='hs-comment'>-- For H98 and synonym families, do check the type args</span>
<a name="line-89"></a>                <span class='hs-varid'>mapM_</span> <span class='hs-varid'>check_arg</span> <span class='hs-varid'>tys</span>
<a name="line-90"></a>
<a name="line-91"></a>          <span class='hs-keyword'>else</span>  <span class='hs-comment'>-- In the liberal case (only for closed syns), expand then check</span>
<a name="line-92"></a>          <span class='hs-keyword'>case</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>of</span>   
<a name="line-93"></a>             <span class='hs-conid'>Just</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty'</span> 
<a name="line-94"></a>             <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"check_tau_type"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>  <span class='hs-layout'>}</span>
<a name="line-95"></a>
<a name="line-96"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GhciCtxt</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ctxt</span>  <span class='hs-comment'>-- Accept under-saturated type synonyms in </span>
<a name="line-97"></a>                      <span class='hs-comment'>-- GHCi :kind commands; see Trac #7586</span>
<a name="line-98"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>check_arg</span> <span class='hs-varid'>tys</span>
<a name="line-99"></a>
<a name="line-100"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-101"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>arityErr</span> <span class='hs-str'>"Type synonym"</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tc_arity</span> <span class='hs-varid'>n_args</span><span class='hs-layout'>)</span>
<a name="line-102"></a>  <span class='hs-keyword'>where</span>
<a name="line-103"></a>    <span class='hs-varid'>n_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tys</span>
<a name="line-104"></a>    <span class='hs-varid'>tc_arity</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span>
<a name="line-105"></a>    <span class='hs-varid'>check_arg</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSynFamilyTyCon</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_arg_type</span>  <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span>
<a name="line-106"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_mono_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>synArgMonoType</span>
<a name="line-107"></a>         
<a name="line-108"></a><a name="check_ubx_tuple"></a><span class='hs-comment'>----------------------------------------</span>
<a name="line-109"></a><span class='hs-definition'>check_ubx_tuple</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>KindOrType</span> 
<a name="line-110"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>KindOrType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-111"></a><span class='hs-definition'>check_ubx_tuple</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tys</span>
<a name="line-112"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>ub_tuples_allowed</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_UnboxedTuples</span>
<a name="line-113"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-varid'>ub_tuples_allowed</span> <span class='hs-layout'>(</span><span class='hs-varid'>ubxArgTyErr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-114"></a>
<a name="line-115"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>impred</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_ImpredicativeTypes</span>        
<a name="line-116"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rank'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>impred</span> <span class='hs-keyword'>then</span> <span class='hs-conid'>ArbitraryRank</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>tyConArgMonoType</span>
<a name="line-117"></a>                <span class='hs-comment'>-- c.f. check_arg_type</span>
<a name="line-118"></a>                <span class='hs-comment'>-- However, args are allowed to be unlifted, or</span>
<a name="line-119"></a>                <span class='hs-comment'>-- more unboxed tuples, so can't use check_arg_ty</span>
<a name="line-120"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank'</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>}</span>
<a name="line-121"></a>    
<a name="line-122"></a><a name="check_arg_type"></a><span class='hs-comment'>----------------------------------------</span>
<a name="line-123"></a><span class='hs-definition'>check_arg_type</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>KindOrType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-124"></a><span class='hs-comment'>-- The sort of type that can instantiate a type variable,</span>
<a name="line-125"></a><span class='hs-comment'>-- or be the argument of a type constructor.</span>
<a name="line-126"></a><span class='hs-comment'>-- Not an unboxed tuple, but now *can* be a forall (since impredicativity)</span>
<a name="line-127"></a><span class='hs-comment'>-- Other unboxed types are very occasionally allowed as type</span>
<a name="line-128"></a><span class='hs-comment'>-- arguments depending on the kind of the type constructor</span>
<a name="line-129"></a><span class='hs-comment'>-- </span>
<a name="line-130"></a><span class='hs-comment'>-- For example, we want to reject things like:</span>
<a name="line-131"></a><span class='hs-comment'>--</span>
<a name="line-132"></a><span class='hs-comment'>--      instance Ord a =&gt; Ord (forall s. T s a)</span>
<a name="line-133"></a><span class='hs-comment'>-- and</span>
<a name="line-134"></a><span class='hs-comment'>--      g :: T s (forall b.b)</span>
<a name="line-135"></a><span class='hs-comment'>--</span>
<a name="line-136"></a><span class='hs-comment'>-- NB: unboxed tuples can have polymorphic or unboxed args.</span>
<a name="line-137"></a><span class='hs-comment'>--     This happens in the workers for functions returning</span>
<a name="line-138"></a><span class='hs-comment'>--     product types with polymorphic components.</span>
<a name="line-139"></a><span class='hs-comment'>--     But not in user code.</span>
<a name="line-140"></a><span class='hs-comment'>-- Anyway, they are dealt with by a special case in check_tau_type</span>
<a name="line-141"></a>
<a name="line-142"></a><span class='hs-definition'>check_arg_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span>
<a name="line-143"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isKind</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>  <span class='hs-comment'>-- IA0_NOTE: Do we need to check a kind?</span>
<a name="line-144"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-145"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>impred</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_ImpredicativeTypes</span>
<a name="line-146"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rank'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>rank</span> <span class='hs-keyword'>of</span>          <span class='hs-comment'>-- Predictive =&gt; must be monotype</span>
<a name="line-147"></a>                        <span class='hs-conid'>MustBeMonoType</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MustBeMonoType</span>  <span class='hs-comment'>-- Monotype, regardless</span>
<a name="line-148"></a>                        <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>impred</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArbitraryRank</span>
<a name="line-149"></a>                               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tyConArgMonoType</span>
<a name="line-150"></a>                        <span class='hs-comment'>-- Make sure that MustBeMonoType is propagated, </span>
<a name="line-151"></a>                        <span class='hs-comment'>-- so that we don't suggest -XImpredicativeTypes in</span>
<a name="line-152"></a>                        <span class='hs-comment'>--    (Ord (forall a.a)) =&gt; a -&gt; a</span>
<a name="line-153"></a>                        <span class='hs-comment'>-- and so that if it Must be a monotype, we check that it is!</span>
<a name="line-154"></a>
<a name="line-155"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>rank'</span> <span class='hs-varid'>ty</span>
<a name="line-156"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isUnLiftedType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>unliftedArgErr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-157"></a>             <span class='hs-comment'>-- NB the isUnLiftedType test also checks for </span>
<a name="line-158"></a>             <span class='hs-comment'>--    T State#</span>
<a name="line-159"></a>             <span class='hs-comment'>-- where there is an illegal partial application of State# (which has</span>
<a name="line-160"></a>             <span class='hs-comment'>-- kind * -&gt; #); see Note [The kind invariant] in TypeRep</span>
<a name="line-161"></a>
<a name="line-162"></a><a name="forAllTyErr"></a><span class='hs-comment'>----------------------------------------</span>
<a name="line-163"></a><span class='hs-definition'>forAllTyErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-164"></a><span class='hs-definition'>forAllTyErr</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span> 
<a name="line-165"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal polymorphic or qualified type:"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-166"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>suggestion</span> <span class='hs-keyglyph'>]</span>
<a name="line-167"></a>  <span class='hs-keyword'>where</span>
<a name="line-168"></a>    <span class='hs-varid'>suggestion</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>rank</span> <span class='hs-keyword'>of</span>
<a name="line-169"></a>                   <span class='hs-conid'>LimitedRank</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Perhaps you intended to use RankNTypes or Rank2Types"</span><span class='hs-layout'>)</span>
<a name="line-170"></a>                   <span class='hs-conid'>MonoType</span> <span class='hs-varid'>d</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d</span>
<a name="line-171"></a>                   <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>empty</span>      <span class='hs-comment'>-- Polytype is always illegal</span>
<a name="line-172"></a>
<a name="line-173"></a><a name="unliftedArgErr"></a><span class='hs-definition'>unliftedArgErr</span><span class='hs-layout'>,</span> <span class='hs-varid'>ubxArgTyErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-174"></a><span class='hs-definition'>unliftedArgErr</span>  <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal unlifted type:"</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span>
<a name="line-175"></a><a name="ubxArgTyErr"></a><span class='hs-definition'>ubxArgTyErr</span>     <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal unboxed tuple type as function argument:"</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span>
<a name="line-176"></a>
<a name="line-177"></a><a name="kindErr"></a><span class='hs-definition'>kindErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Kind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-178"></a><span class='hs-definition'>kindErr</span> <span class='hs-varid'>kind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Expecting an ordinary type, but found a type of kind"</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>kind</span><span class='hs-keyglyph'>]</span>
</pre>\end{code}

Note [Liberal type synonyms]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If -XLiberalTypeSynonyms is on, expand closed type synonyms *before*
doing validity checking.  This allows us to instantiate a synonym defn
with a for-all type, or with a partially-applied type synonym.
        e.g.   type T a b = a
               type S m   = m ()
               f :: S (T Int)
Here, T is partially applied, so it's illegal in H98.  But if you
expand S first, then T we get just
               f :: Int
which is fine.

IMPORTANT: suppose T is a type synonym.  Then we must do validity
checking on an appliation (T ty1 ty2)

        *either* before expansion (i.e. check ty1, ty2)
        *or* after expansion (i.e. expand T ty1 ty2, and then check)
        BUT NOT BOTH

If we do both, we get exponential behaviour!!

  data TIACons1 i r c = c i ::: r c
  type TIACons2 t x = TIACons1 t (TIACons1 t x)
  type TIACons3 t x = TIACons2 t (TIACons1 t x)
  type TIACons4 t x = TIACons2 t (TIACons2 t x)
  type TIACons7 t x = TIACons4 t (TIACons3 t x)


%************************************************************************
%*                                                                      *
\subsection{Checking a theta or source type}
%*                                                                      *
%************************************************************************

Note [Implicit parameters in instance decls]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Implicit parameters _only_ allowed in type signatures; not in instance
decls, superclasses etc. The reason for not allowing implicit params in
instances is a bit subtle.  If we allowed
  instance (?x::Int, Eq a) => Foo [a] where ...
then when we saw
     (e :: (?x::Int) => t)
it would be unclear how to discharge all the potential usas of the ?x
in e.  For example, a constraint Foo [Int] might come out of e,and
applying the instance decl would show up two uses of ?x.  Trac #8912.

\begin{code}
<pre><a name="line-1"></a><a name="checkValidTheta"></a><span class='hs-definition'>checkValidTheta</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2"></a><span class='hs-definition'>checkValidTheta</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>theta</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addErrCtxt</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkThetaCtxt</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_valid_theta</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-4"></a>
<a name="line-5"></a><a name="check_valid_theta"></a><span class='hs-comment'>-------------------------</span>
<a name="line-6"></a><span class='hs-definition'>check_valid_theta</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-7"></a><span class='hs-definition'>check_valid_theta</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-9"></a><span class='hs-definition'>check_valid_theta</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>theta</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>warnTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>wopt</span> <span class='hs-conid'>Opt_WarnDuplicateConstraints</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>&amp;&amp;</span>
<a name="line-12"></a>                 <span class='hs-varid'>notNull</span> <span class='hs-varid'>dups</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>dupPredWarn</span> <span class='hs-varid'>dups</span><span class='hs-layout'>)</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_pred_ty</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span> <span class='hs-varid'>theta</span> <span class='hs-layout'>}</span>
<a name="line-14"></a>  <span class='hs-keyword'>where</span>
<a name="line-15"></a>    <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>dups</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>removeDups</span> <span class='hs-varid'>cmpPred</span> <span class='hs-varid'>theta</span>
<a name="line-16"></a>
<a name="line-17"></a><a name="check_pred_ty"></a><span class='hs-comment'>-------------------------</span>
<a name="line-18"></a><span class='hs-definition'>check_pred_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-19"></a><span class='hs-comment'>-- Check the validity of a predicate in a signature</span>
<a name="line-20"></a><span class='hs-comment'>-- We look through any type synonyms; any constraint kinded</span>
<a name="line-21"></a><span class='hs-comment'>-- type synonyms have been checked at their definition site</span>
<a name="line-22"></a>
<a name="line-23"></a><span class='hs-definition'>check_pred_ty</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span>
<a name="line-24"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span> <span class='hs-keyword'>of</span>
<a name="line-25"></a>      <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_class_pred</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-26"></a>      <span class='hs-conid'>EqPred</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_eq_pred</span>    <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-27"></a>      <span class='hs-conid'>TuplePred</span> <span class='hs-varid'>tys</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_tuple_pred</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>tys</span>
<a name="line-28"></a>      <span class='hs-conid'>IrredPred</span> <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_irred_pred</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span>
<a name="line-29"></a>
<a name="line-30"></a>
<a name="line-31"></a><a name="check_class_pred"></a><span class='hs-definition'>check_class_pred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-32"></a><span class='hs-definition'>check_class_pred</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-33"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>        <span class='hs-comment'>-- Class predicates are valid in all contexts</span>
<a name="line-34"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>arity</span> <span class='hs-varop'>==</span> <span class='hs-varid'>n_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>arity_err</span>
<a name="line-35"></a>
<a name="line-36"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isIPClass</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>okIPCtxt</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span>
<a name="line-37"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>badIPPred</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-38"></a>
<a name="line-39"></a>                <span class='hs-comment'>-- Check the form of the argument types</span>
<a name="line-40"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>checkValidMonoType</span> <span class='hs-varid'>tys</span>
<a name="line-41"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_class_pred_tys</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-42"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>predTyVarErr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>how_to_allow</span><span class='hs-layout'>)</span>
<a name="line-43"></a>       <span class='hs-layout'>}</span>
<a name="line-44"></a>  <span class='hs-keyword'>where</span>
<a name="line-45"></a>    <span class='hs-varid'>class_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>className</span> <span class='hs-varid'>cls</span>
<a name="line-46"></a>    <span class='hs-varid'>arity</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classArity</span> <span class='hs-varid'>cls</span>
<a name="line-47"></a>    <span class='hs-varid'>n_tys</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tys</span>
<a name="line-48"></a>    <span class='hs-varid'>arity_err</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityErr</span> <span class='hs-str'>"Class"</span> <span class='hs-varid'>class_name</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>n_tys</span>
<a name="line-49"></a>    <span class='hs-varid'>how_to_allow</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Use FlexibleContexts to permit this"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-50"></a>
<a name="line-51"></a><a name="okIPCtxt"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-52"></a>  <span class='hs-comment'>-- See Note [Implicit parameters in instance decls]</span>
<a name="line-53"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClassSCCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-54"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>InstDeclCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-55"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>SpecInstCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-56"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-keyword'>_</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-57"></a>
<a name="line-58"></a><a name="badIPPred"></a><span class='hs-definition'>badIPPred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-59"></a><span class='hs-definition'>badIPPred</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal implict parameter"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-60"></a>
<a name="line-61"></a>
<a name="line-62"></a><a name="check_eq_pred"></a><span class='hs-definition'>check_eq_pred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-63"></a><span class='hs-definition'>check_eq_pred</span> <span class='hs-varid'>dflags</span> <span class='hs-sel'>_ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-64"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>        <span class='hs-comment'>-- Equational constraints are valid in all contexts if type</span>
<a name="line-65"></a>                <span class='hs-comment'>-- families are permitted</span>
<a name="line-66"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_TypeFamilies</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>||</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_GADTs</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> 
<a name="line-67"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>eqPredTyErr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-68"></a>
<a name="line-69"></a>                <span class='hs-comment'>-- Check the form of the argument types</span>
<a name="line-70"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkValidMonoType</span> <span class='hs-varid'>ty1</span>
<a name="line-71"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkValidMonoType</span> <span class='hs-varid'>ty2</span>
<a name="line-72"></a>       <span class='hs-layout'>}</span>
<a name="line-73"></a>
<a name="line-74"></a><a name="check_tuple_pred"></a><span class='hs-definition'>check_tuple_pred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-75"></a><span class='hs-definition'>check_tuple_pred</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>ts</span>
<a name="line-76"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_ConstraintKinds</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-77"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>predTupleErr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-78"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_pred_ty</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span> <span class='hs-varid'>ts</span> <span class='hs-layout'>}</span>
<a name="line-79"></a>    <span class='hs-comment'>-- This case will not normally be executed because </span>
<a name="line-80"></a>    <span class='hs-comment'>-- without -XConstraintKinds tuple types are only kind-checked as *</span>
<a name="line-81"></a>
<a name="line-82"></a><a name="check_irred_pred"></a><span class='hs-definition'>check_irred_pred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-83"></a><span class='hs-definition'>check_irred_pred</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span>
<a name="line-84"></a>    <span class='hs-comment'>-- The predicate looks like (X t1 t2) or (x t1 t2) :: Constraint</span>
<a name="line-85"></a>    <span class='hs-comment'>-- But X is not a synonym; that's been expanded already</span>
<a name="line-86"></a>    <span class='hs-comment'>--</span>
<a name="line-87"></a>    <span class='hs-comment'>-- Allowing irreducible predicates in class superclasses is somewhat dangerous</span>
<a name="line-88"></a>    <span class='hs-comment'>-- because we can write:</span>
<a name="line-89"></a>    <span class='hs-comment'>--</span>
<a name="line-90"></a>    <span class='hs-comment'>--  type family Fooish x :: * -&gt; Constraint</span>
<a name="line-91"></a>    <span class='hs-comment'>--  type instance Fooish () = Foo</span>
<a name="line-92"></a>    <span class='hs-comment'>--  class Fooish () a =&gt; Foo a where</span>
<a name="line-93"></a>    <span class='hs-comment'>--</span>
<a name="line-94"></a>    <span class='hs-comment'>-- This will cause the constraint simplifier to loop because every time we canonicalise a</span>
<a name="line-95"></a>    <span class='hs-comment'>-- (Foo a) class constraint we add a (Fooish () a) constraint which will be immediately</span>
<a name="line-96"></a>    <span class='hs-comment'>-- solved to add+canonicalise another (Foo a) constraint.</span>
<a name="line-97"></a>    <span class='hs-comment'>--</span>
<a name="line-98"></a>    <span class='hs-comment'>-- It is equally dangerous to allow them in instance heads because in that case the</span>
<a name="line-99"></a>    <span class='hs-comment'>-- Paterson conditions may not detect duplication of a type variable or size change.</span>
<a name="line-100"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkValidMonoType</span> <span class='hs-varid'>pred</span>
<a name="line-101"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_ConstraintKinds</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-102"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>predIrredErr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-103"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_UndecidableInstances</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-104"></a>                 <span class='hs-comment'>-- Make sure it is OK to have an irred pred in this context</span>
<a name="line-105"></a>         <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span> <span class='hs-conid'>ClassSCCtxt</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span><span class='hs-layout'>;</span> <span class='hs-conid'>InstDeclCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span><span class='hs-layout'>;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>
<a name="line-106"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>predIrredBadCtxtErr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-107"></a>
<a name="line-108"></a><a name="check_class_pred_tys"></a><span class='hs-comment'>-------------------------</span>
<a name="line-109"></a><span class='hs-definition'>check_class_pred_tys</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>KindOrType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-110"></a><span class='hs-definition'>check_class_pred_tys</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>kts</span>
<a name="line-111"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-112"></a>        <span class='hs-conid'>SpecInstCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>    <span class='hs-comment'>-- {-# SPECIALISE instance Eq (T Int) #-} is fine</span>
<a name="line-113"></a>        <span class='hs-conid'>InstDeclCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flexible_contexts</span> <span class='hs-varop'>||</span> <span class='hs-varid'>undecidable_ok</span> <span class='hs-varop'>||</span> <span class='hs-varid'>all</span> <span class='hs-varid'>tcIsTyVarTy</span> <span class='hs-varid'>tys</span>
<a name="line-114"></a>                                <span class='hs-comment'>-- Further checks on head and theta in</span>
<a name="line-115"></a>                                <span class='hs-comment'>-- checkInstTermination</span>
<a name="line-116"></a>        <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flexible_contexts</span> <span class='hs-varop'>||</span> <span class='hs-varid'>all</span> <span class='hs-varid'>tyvar_head</span> <span class='hs-varid'>tys</span>
<a name="line-117"></a>  <span class='hs-keyword'>where</span>
<a name="line-118"></a>    <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>span</span> <span class='hs-varid'>isKind</span> <span class='hs-varid'>kts</span>  <span class='hs-comment'>-- see Note [Kind polymorphic type classes]</span>
<a name="line-119"></a>    <span class='hs-varid'>flexible_contexts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_FlexibleContexts</span> <span class='hs-varid'>dflags</span>
<a name="line-120"></a>    <span class='hs-varid'>undecidable_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_UndecidableInstances</span> <span class='hs-varid'>dflags</span>
<a name="line-121"></a>
<a name="line-122"></a><a name="tyvar_head"></a><span class='hs-comment'>-------------------------</span>
<a name="line-123"></a><span class='hs-definition'>tyvar_head</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-124"></a><span class='hs-definition'>tyvar_head</span> <span class='hs-varid'>ty</span>                   <span class='hs-comment'>-- Haskell 98 allows predicates of form </span>
<a name="line-125"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tcIsTyVarTy</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>       <span class='hs-comment'>--      C (a ty1 .. tyn)</span>
<a name="line-126"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                   <span class='hs-comment'>-- where a is a type variable</span>
<a name="line-127"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tcSplitAppTy_maybe</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>of</span>
<a name="line-128"></a>        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tyvar_head</span> <span class='hs-varid'>ty</span>
<a name="line-129"></a>        <span class='hs-conid'>Nothing</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
</pre>\end{code}

Note [Kind polymorphic type classes]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MultiParam check:

    class C f where...   -- C :: forall k. k -> Constraint
    instance C Maybe where...

  The dictionary gets type [C * Maybe] even if it's not a MultiParam
  type class.

Flexibility check:

    class C f where...   -- C :: forall k. k -> Constraint
    data D a = D a
    instance C D where

  The dictionary gets type [C * (D *)]. IA0_TODO it should be
  generalized actually.

Note [The ambiguity check for type signatures]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
checkAmbiguity is a check on user-supplied type signatures.  It is
*purely* there to report functions that cannot possibly be called.  So for
example we want to reject:
   f :: C a => Int
The idea is there can be no legal calls to 'f' because every call will
give rise to an ambiguous constraint.  We could soundly omit the
ambiguity check on type signatures entirely, at the expense of
delaying ambiguity errors to call sites.  Indeed, the flag 
-XAllowAmbiguousTypes switches off the ambiguity check.

What about things like this:
   class D a b | a -> b where ..
   h :: D Int b => Int 
The Int may well fix 'b' at the call site, so that signature should
not be rejected.  Moreover, using *visible* fundeps is too
conservative.  Consider
   class X a b where ...
   class D a b | a -> b where ...
   instance D a b => X [a] b where...
   h :: X a b => a -> a
Here h's type looks ambiguous in 'b', but here's a legal call:
   ...(h [True])...
That gives rise to a (X [Bool] beta) constraint, and using the
instance means we need (D Bool beta) and that fixes 'beta' via D's
fundep!

Behind all these special cases there is a simple guiding principle. 
Consider

  f :: <type>
  f = ...blah...

  g :: <type>
  g = f

You would think that the definition of g would surely typecheck!
After all f has exactly the same type, and g=f. But in fact f's type
is instantiated and the instantiated constraints are solved against
the originals, so in the case an ambiguous type it won't work.
Consider our earlier example f :: C a => Int.  Then in g's definition,
we'll instantiate to (C alpha) and try to deduce (C alpha) from (C a),
and fail.  

So in fact we use this as our *definition* of ambiguity.  We use a
very similar test for *inferred* types, to ensure that they are
unambiguous. See Note [Impedence matching] in TcBinds.

This test is very conveniently implemented by calling
    tcSubType <type> <type>
This neatly takes account of the functional dependecy stuff above, 
and implict parameter (see Note [Implicit parameters and ambiguity]).

What about this, though?
   g :: C [a] => Int
Is every call to 'g' ambiguous?  After all, we might have
   intance C [a] where ...
at the call site.  So maybe that type is ok!  Indeed even f's
quintessentially ambiguous type might, just possibly be callable: 
with -XFlexibleInstances we could have
  instance C a where ...
and now a call could be legal after all!  Well, we'll reject this
unless the instance is available *here*.

Side note: the ambiguity check is only used for *user* types, not for
types coming from inteface files.  The latter can legitimately have
ambiguous types. Example

   class S a where s :: a -> (Int,Int)
   instance S Char where s _ = (1,1)
   f:: S a => [a] -> Int -> (Int,Int)
   f (_::[a]) x = (a*x,b)
        where (a,b) = s (undefined::a)

Here the worker for f gets the type
        fw :: forall a. S a => Int -> (# Int, Int #)

Note [Implicit parameters and ambiguity] 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Only a *class* predicate can give rise to ambiguity
An *implicit parameter* cannot.  For example:
        foo :: (?x :: [a]) => Int
        foo = length ?x
is fine.  The call site will suppply a particular 'x'

Furthermore, the type variables fixed by an implicit parameter
propagate to the others.  E.g.
        foo :: (Show a, ?x::[a]) => Int
        foo = show (?x++?x)
The type of foo looks ambiguous.  But it isn't, because at a call site
we might have
        let ?x = 5::Int in foo
and all is well.  In effect, implicit parameters are, well, parameters,
so we can take their type variables into account as part of the
"tau-tvs" stuff.  This is done in the function 'FunDeps.grow'.
\begin{code}
<pre><a name="line-1"></a><a name="checkThetaCtxt"></a><span class='hs-definition'>checkThetaCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-2"></a><span class='hs-definition'>checkThetaCtxt</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>theta</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"In the context:"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprTheta</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span>
<a name="line-4"></a>          <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"While checking"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprUserTypeCtxt</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>]</span>
<a name="line-5"></a>
<a name="line-6"></a><a name="eqPredTyErr"></a><span class='hs-definition'>eqPredTyErr</span><span class='hs-layout'>,</span> <span class='hs-varid'>predTyVarErr</span><span class='hs-layout'>,</span> <span class='hs-varid'>predTupleErr</span><span class='hs-layout'>,</span> <span class='hs-varid'>predIrredErr</span><span class='hs-layout'>,</span> <span class='hs-varid'>predIrredBadCtxtErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-7"></a><span class='hs-definition'>eqPredTyErr</span>  <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal equational constraint"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprType</span> <span class='hs-varid'>pred</span>
<a name="line-8"></a>                    <span class='hs-varop'>$$</span>
<a name="line-9"></a>                    <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Use GADTs or TypeFamilies to permit this"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-10"></a><a name="predTyVarErr"></a><span class='hs-definition'>predTyVarErr</span> <span class='hs-varid'>pred</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Non type-variable argument"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-11"></a>                        <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"in the constraint:"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprType</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-12"></a><a name="predTupleErr"></a><span class='hs-definition'>predTupleErr</span> <span class='hs-varid'>pred</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal tuple constraint:"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprType</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-13"></a>                        <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Use ConstraintKinds to permit this"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-14"></a><a name="predIrredErr"></a><span class='hs-definition'>predIrredErr</span> <span class='hs-varid'>pred</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal constraint:"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprType</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-15"></a>                        <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Use ConstraintKinds to permit this"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-16"></a><a name="predIrredBadCtxtErr"></a><span class='hs-definition'>predIrredBadCtxtErr</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal constraint"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprType</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-17"></a>                                 <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"in a superclass/instance context"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> 
<a name="line-18"></a>                               <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Use UndecidableInstances to permit this"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-19"></a>
<a name="line-20"></a><a name="constraintSynErr"></a><span class='hs-definition'>constraintSynErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-21"></a><span class='hs-definition'>constraintSynErr</span> <span class='hs-varid'>kind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal constraint synonym of kind:"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>kind</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-22"></a>                           <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Use ConstraintKinds to permit this"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-23"></a>
<a name="line-24"></a><a name="dupPredWarn"></a><span class='hs-definition'>dupPredWarn</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-25"></a><span class='hs-definition'>dupPredWarn</span> <span class='hs-varid'>dups</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Duplicate constraint(s):"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprWithCommas</span> <span class='hs-varid'>pprType</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>head</span> <span class='hs-varid'>dups</span><span class='hs-layout'>)</span>
<a name="line-26"></a>
<a name="line-27"></a><a name="arityErr"></a><span class='hs-definition'>arityErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Outputable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-28"></a><span class='hs-definition'>arityErr</span> <span class='hs-varid'>kind</span> <span class='hs-varid'>name</span> <span class='hs-varid'>n</span> <span class='hs-varid'>m</span>
<a name="line-29"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hsep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-varid'>kind</span><span class='hs-layout'>,</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"should have"</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-30"></a>           <span class='hs-varid'>n_arguments</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>comma</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"but has been given"</span><span class='hs-layout'>,</span> 
<a name="line-31"></a>           <span class='hs-keyword'>if</span> <span class='hs-varid'>m</span><span class='hs-varop'>==</span><span class='hs-num'>0</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>text</span> <span class='hs-str'>"none"</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>int</span> <span class='hs-varid'>m</span><span class='hs-keyglyph'>]</span>
<a name="line-32"></a>    <span class='hs-keyword'>where</span>
<a name="line-33"></a>        <span class='hs-varid'>n_arguments</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"no arguments"</span><span class='hs-layout'>)</span>
<a name="line-34"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"1 argument"</span><span class='hs-layout'>)</span>
<a name="line-35"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hsep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>int</span> <span class='hs-varid'>n</span><span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"arguments"</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
</pre>\end{code}

%************************************************************************
%*                                                                      *
\subsection{Checking for a decent instance head type}
%*                                                                      *
%************************************************************************

@checkValidInstHead@ checks the type {\em and} its syntactic constraints:
it must normally look like: @instance Foo (Tycon a b c ...) ...@

The exceptions to this syntactic checking: (1)~if the @GlasgowExts@
flag is on, or (2)~the instance is imported (they must have been
compiled elsewhere). In these cases, we let them go through anyway.

We can also have instances for functions: @instance Foo (a -> b) ...@.

\begin{code}
<pre><a name="line-1"></a><a name="checkValidInstHead"></a><span class='hs-definition'>checkValidInstHead</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2"></a><span class='hs-definition'>checkValidInstHead</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-4"></a>
<a name="line-5"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>clas</span> <span class='hs-varop'>`notElem`</span> <span class='hs-varid'>abstractClasses</span><span class='hs-layout'>)</span>
<a name="line-6"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>instTypeErr</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span> <span class='hs-varid'>abstract_class_msg</span><span class='hs-layout'>)</span>
<a name="line-7"></a>
<a name="line-8"></a>           <span class='hs-comment'>-- Check language restrictions; </span>
<a name="line-9"></a>           <span class='hs-comment'>-- but not for SPECIALISE isntance pragmas</span>
<a name="line-10"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ty_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropWhile</span> <span class='hs-varid'>isKind</span> <span class='hs-varid'>cls_args</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-varid'>spec_inst_prag</span> <span class='hs-varop'>$</span>
<a name="line-12"></a>         <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_TypeSynonymInstances</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>||</span>
<a name="line-13"></a>                       <span class='hs-varid'>all</span> <span class='hs-varid'>tcInstHeadTyNotSynonym</span> <span class='hs-varid'>ty_args</span><span class='hs-layout'>)</span>
<a name="line-14"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>instTypeErr</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span> <span class='hs-varid'>head_type_synonym_msg</span><span class='hs-layout'>)</span>
<a name="line-15"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_FlexibleInstances</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>||</span>
<a name="line-16"></a>                       <span class='hs-varid'>all</span> <span class='hs-varid'>tcInstHeadTyAppAllTyVars</span> <span class='hs-varid'>ty_args</span><span class='hs-layout'>)</span>
<a name="line-17"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>instTypeErr</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span> <span class='hs-varid'>head_type_args_tyvars_msg</span><span class='hs-layout'>)</span>
<a name="line-18"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_NullaryTypeClasses</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>||</span>
<a name="line-19"></a>                       <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>ty_args</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-20"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>instTypeErr</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span> <span class='hs-varid'>head_no_type_msg</span><span class='hs-layout'>)</span>
<a name="line-21"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>Opt_MultiParamTypeClasses</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>||</span>
<a name="line-22"></a>                       <span class='hs-varid'>length</span> <span class='hs-varid'>ty_args</span> <span class='hs-varop'>&lt;=</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Only count type arguments</span>
<a name="line-23"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>instTypeErr</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span> <span class='hs-varid'>head_one_type_msg</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-24"></a>
<a name="line-25"></a>         <span class='hs-comment'>-- May not contain type family applications</span>
<a name="line-26"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>checkTyFamFreeness</span> <span class='hs-varid'>ty_args</span>
<a name="line-27"></a>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>checkValidMonoType</span> <span class='hs-varid'>ty_args</span>
<a name="line-29"></a>        <span class='hs-comment'>-- For now, I only allow tau-types (not polytypes) in </span>
<a name="line-30"></a>        <span class='hs-comment'>-- the head of an instance decl.  </span>
<a name="line-31"></a>        <span class='hs-comment'>--      E.g.  instance C (forall a. a-&gt;a) is rejected</span>
<a name="line-32"></a>        <span class='hs-comment'>-- One could imagine generalising that, but I'm not sure</span>
<a name="line-33"></a>        <span class='hs-comment'>-- what all the consequences might be</span>
<a name="line-34"></a>       <span class='hs-layout'>}</span>
<a name="line-35"></a>
<a name="line-36"></a>  <span class='hs-keyword'>where</span>
<a name="line-37"></a>    <span class='hs-varid'>spec_inst_prag</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-conid'>SpecInstCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span><span class='hs-layout'>;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-38"></a>
<a name="line-39"></a>    <span class='hs-varid'>head_type_synonym_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span>
<a name="line-40"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"All instance types must be of the form (T t1 ... tn)"</span> <span class='hs-varop'>$$</span>
<a name="line-41"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"where T is not a synonym."</span> <span class='hs-varop'>$$</span>
<a name="line-42"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"Use TypeSynonymInstances if you want to disable this."</span><span class='hs-layout'>)</span>
<a name="line-43"></a>
<a name="line-44"></a>    <span class='hs-varid'>head_type_args_tyvars_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span>
<a name="line-45"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"All instance types must be of the form (T a1 ... an)"</span><span class='hs-layout'>,</span>
<a name="line-46"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"where a1 ... an are *distinct type variables*,"</span><span class='hs-layout'>,</span>
<a name="line-47"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"and each type variable appears at most once in the instance head."</span><span class='hs-layout'>,</span>
<a name="line-48"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"Use FlexibleInstances if you want to disable this."</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-49"></a>
<a name="line-50"></a>    <span class='hs-varid'>head_one_type_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span>
<a name="line-51"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"Only one type can be given in an instance head."</span> <span class='hs-varop'>$$</span>
<a name="line-52"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"Use MultiParamTypeClasses if you want to allow more."</span><span class='hs-layout'>)</span>
<a name="line-53"></a>
<a name="line-54"></a>    <span class='hs-varid'>head_no_type_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span>
<a name="line-55"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"No parameters in the instance head."</span> <span class='hs-varop'>$$</span>
<a name="line-56"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"Use NullaryTypeClasses if you want to allow this."</span><span class='hs-layout'>)</span>
<a name="line-57"></a>
<a name="line-58"></a>    <span class='hs-varid'>abstract_class_msg</span> <span class='hs-keyglyph'>=</span>
<a name="line-59"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"The class is abstract, manual instances are not permitted."</span>
<a name="line-60"></a>
<a name="line-61"></a><a name="abstractClasses"></a><span class='hs-definition'>abstractClasses</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>]</span>
<a name="line-62"></a><span class='hs-definition'>abstractClasses</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>coercibleClass</span> <span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- See Note [Coercible Instances]</span>
<a name="line-63"></a>
<a name="line-64"></a><a name="instTypeErr"></a><span class='hs-definition'>instTypeErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-65"></a><span class='hs-definition'>instTypeErr</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>msg</span>
<a name="line-66"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal instance declaration for"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-67"></a>             <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-68"></a>       <span class='hs-num'>2</span> <span class='hs-varid'>msg</span>
</pre>\end{code}

validDeivPred checks for OK 'deriving' context.  See Note [Exotic
derived instance contexts] in TcSimplify.  However the predicate is
here because it uses sizeTypes, fvTypes.

Also check for a bizarre corner case, when the derived instance decl 
would look like
    instance C a b => D (T a) where ...
Note that 'b' isn't a parameter of T.  This gives rise to all sorts of
problems; in particular, it's hard to compare solutions for equality
when finding the fixpoint, and that means the inferContext loop does
not converge.  See Trac #5287.

\begin{code}
<pre><a name="line-1"></a><a name="validDerivPred"></a><span class='hs-definition'>validDerivPred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2"></a><span class='hs-definition'>validDerivPred</span> <span class='hs-varid'>tv_set</span> <span class='hs-varid'>pred</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span> <span class='hs-keyword'>of</span>
<a name="line-4"></a>       <span class='hs-conid'>ClassPred</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>hasNoDups</span> <span class='hs-varid'>fvs</span> 
<a name="line-5"></a>                       <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>==</span> <span class='hs-varid'>length</span> <span class='hs-varid'>fvs</span>
<a name="line-6"></a>                       <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tv_set</span><span class='hs-layout'>)</span> <span class='hs-varid'>fvs</span>
<a name="line-7"></a>       <span class='hs-conid'>TuplePred</span> <span class='hs-varid'>ps</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varid'>validDerivPred</span> <span class='hs-varid'>tv_set</span><span class='hs-layout'>)</span> <span class='hs-varid'>ps</span>
<a name="line-8"></a>       <span class='hs-keyword'>_</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>   <span class='hs-comment'>-- Non-class predicates are ok</span>
<a name="line-9"></a>  <span class='hs-keyword'>where</span>
<a name="line-10"></a>    <span class='hs-varid'>fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>pred</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
\subsection{Checking instance for termination}
%*                                                                      *
%************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="checkValidInstance"></a><span class='hs-definition'>checkValidInstance</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LHsType</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-2"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ThetaType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-definition'>checkValidInstance</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>hs_type</span> <span class='hs-varid'>ty</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>clas</span><span class='hs-layout'>,</span><span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getClassPredTys_maybe</span> <span class='hs-varid'>tau</span>
<a name="line-5"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varop'>`lengthIs`</span> <span class='hs-varid'>classArity</span> <span class='hs-varid'>clas</span>
<a name="line-6"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>setSrcSpan</span> <span class='hs-varid'>head_loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkValidInstHead</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span>
<a name="line-7"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkValidTheta</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>theta</span>
<a name="line-8"></a>
<a name="line-9"></a>        <span class='hs-comment'>-- The Termination and Coverate Conditions</span>
<a name="line-10"></a>        <span class='hs-comment'>-- Check that instance inference will terminate (if we care)</span>
<a name="line-11"></a>        <span class='hs-comment'>-- For Haskell 98 this will already have been done by checkValidTheta,</span>
<a name="line-12"></a>        <span class='hs-comment'>-- but as we may be using other extensions we need to check.</span>
<a name="line-13"></a>        <span class='hs-comment'>-- </span>
<a name="line-14"></a>        <span class='hs-comment'>-- Note that the Termination Condition is *more conservative* than </span>
<a name="line-15"></a>        <span class='hs-comment'>-- the checkAmbiguity test we do on other type signatures</span>
<a name="line-16"></a>        <span class='hs-comment'>--   e.g.  Bar a =&gt; Bar Int is ambiguous, but it also fails</span>
<a name="line-17"></a>        <span class='hs-comment'>--   the termination condition, because 'a' appears more often</span>
<a name="line-18"></a>        <span class='hs-comment'>--   in the constraint than in the head</span>
<a name="line-19"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>undecidable_ok</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_UndecidableInstances</span>
<a name="line-20"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>undecidable_ok</span> 
<a name="line-21"></a>          <span class='hs-keyword'>then</span> <span class='hs-varid'>checkAmbiguity</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span>
<a name="line-22"></a>          <span class='hs-keyword'>else</span> <span class='hs-varid'>checkInstTermination</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>theta</span>
<a name="line-23"></a>
<a name="line-24"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkInstCoverage</span> <span class='hs-varid'>undecidable_ok</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-25"></a>            <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>   <span class='hs-comment'>-- Check succeeded</span>
<a name="line-26"></a>            <span class='hs-conid'>Just</span> <span class='hs-varid'>msg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addErrTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>instTypeErr</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>msg</span><span class='hs-layout'>)</span>
<a name="line-27"></a>                  
<a name="line-28"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>clas</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> 
<a name="line-29"></a>
<a name="line-30"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> 
<a name="line-31"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Malformed instance head:"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tau</span><span class='hs-layout'>)</span>
<a name="line-32"></a>  <span class='hs-keyword'>where</span>
<a name="line-33"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>tau</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitSigmaTy</span> <span class='hs-varid'>ty</span>
<a name="line-34"></a>
<a name="line-35"></a>        <span class='hs-comment'>-- The location of the "head" of the instance</span>
<a name="line-36"></a>    <span class='hs-varid'>head_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>hs_type</span> <span class='hs-keyword'>of</span>
<a name="line-37"></a>                 <span class='hs-conid'>L</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsForAllTy</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>loc</span>
<a name="line-38"></a>                 <span class='hs-conid'>L</span> <span class='hs-varid'>loc</span> <span class='hs-keyword'>_</span>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>loc</span>
</pre>\end{code}

Note [Paterson conditions]
~~~~~~~~~~~~~~~~~~~~~~~~~~
Termination test: the so-called "Paterson conditions" (see Section 5 of
"Understanding functionsl dependencies via Constraint Handling Rules, 
JFP Jan 2007).

We check that each assertion in the context satisfies:
 (1) no variable has more occurrences in the assertion than in the head, and
 (2) the assertion has fewer constructors and variables (taken together
     and counting repetitions) than the head.
This is only needed with -fglasgow-exts, as Haskell 98 restrictions
(which have already been checked) guarantee termination. 

The underlying idea is that 

    for any ground substitution, each assertion in the
    context has fewer type constructors than the head.


\begin{code}
<pre><a name="line-1"></a><a name="checkInstTermination"></a><span class='hs-definition'>checkInstTermination</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2"></a><span class='hs-comment'>-- See Note [Paterson conditions]</span>
<a name="line-3"></a><span class='hs-definition'>checkInstTermination</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>theta</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_preds</span> <span class='hs-varid'>theta</span>
<a name="line-5"></a>  <span class='hs-keyword'>where</span>
<a name="line-6"></a>   <span class='hs-varid'>fvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvTypes</span> <span class='hs-varid'>tys</span>
<a name="line-7"></a>   <span class='hs-varid'>size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-varid'>tys</span>
<a name="line-8"></a>
<a name="line-9"></a>   <span class='hs-varid'>check_preds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-10"></a>   <span class='hs-varid'>check_preds</span> <span class='hs-varid'>preds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>check</span> <span class='hs-varid'>preds</span>
<a name="line-11"></a>
<a name="line-12"></a>   <span class='hs-varid'>check</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-13"></a>   <span class='hs-varid'>check</span> <span class='hs-varid'>pred</span> 
<a name="line-14"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span> <span class='hs-keyword'>of</span>
<a name="line-15"></a>         <span class='hs-conid'>TuplePred</span> <span class='hs-varid'>preds</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_preds</span> <span class='hs-varid'>preds</span>  <span class='hs-comment'>-- Look inside tuple predicates; Trac #8359</span>
<a name="line-16"></a>         <span class='hs-conid'>EqPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>          <span class='hs-comment'>-- You can't get from equalities</span>
<a name="line-17"></a>                                               <span class='hs-comment'>-- to class predicates, so this is safe</span>
<a name="line-18"></a>         <span class='hs-sel'>_other</span>      <span class='hs-comment'>-- ClassPred, IrredPred</span>
<a name="line-19"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span>
<a name="line-20"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addErrTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>predUndecErr</span> <span class='hs-varid'>pred</span> <span class='hs-layout'>(</span><span class='hs-varid'>nomoreMsg</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>parens</span> <span class='hs-varid'>undecidableMsg</span><span class='hs-layout'>)</span>
<a name="line-21"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sizePred</span> <span class='hs-varid'>pred</span> <span class='hs-varop'>&gt;=</span> <span class='hs-varid'>size</span>
<a name="line-22"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addErrTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>predUndecErr</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>smallerMsg</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>parens</span> <span class='hs-varid'>undecidableMsg</span><span class='hs-layout'>)</span>
<a name="line-23"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-24"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-25"></a>     <span class='hs-keyword'>where</span>
<a name="line-26"></a>        <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOut</span> <span class='hs-varid'>isKindVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>fvType</span> <span class='hs-varid'>pred</span> <span class='hs-varop'>\\</span> <span class='hs-varid'>fvs</span><span class='hs-layout'>)</span>
<a name="line-27"></a>             <span class='hs-comment'>-- Rightly or wrongly, we only check for</span>
<a name="line-28"></a>             <span class='hs-comment'>-- excessive occurrences of *type* variables.</span>
<a name="line-29"></a>             <span class='hs-comment'>-- e.g. type instance Demote {T k} a = T (Demote {k} (Any {k}))</span>
<a name="line-30"></a>
<a name="line-31"></a><a name="predUndecErr"></a><span class='hs-definition'>predUndecErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-32"></a><span class='hs-definition'>predUndecErr</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>msg</span><span class='hs-layout'>,</span>
<a name="line-33"></a>                        <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"in the constraint:"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprType</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-34"></a>
<a name="line-35"></a><a name="nomoreMsg"></a><span class='hs-definition'>nomoreMsg</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-36"></a><span class='hs-definition'>nomoreMsg</span> <span class='hs-varid'>tvs</span> 
<a name="line-37"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Variable"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>plural</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprWithCommas</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> 
<a name="line-38"></a>        <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-keyword'>if</span> <span class='hs-varid'>isSingleton</span> <span class='hs-varid'>tvs</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"occurs"</span><span class='hs-layout'>)</span>
<a name="line-39"></a>                                  <span class='hs-keyword'>else</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"occur"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-40"></a>          <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"more often than in the instance head"</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-41"></a>
<a name="line-42"></a><a name="smallerMsg"></a><span class='hs-definition'>smallerMsg</span><span class='hs-layout'>,</span> <span class='hs-varid'>undecidableMsg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SDoc</span>
<a name="line-43"></a><span class='hs-definition'>smallerMsg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Constraint is no smaller than the instance head"</span><span class='hs-layout'>)</span>
<a name="line-44"></a><a name="undecidableMsg"></a><span class='hs-definition'>undecidableMsg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Use UndecidableInstances to permit this"</span><span class='hs-layout'>)</span>
</pre>\end{code}



Note [Associated type instances]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We allow this:
  class C a where
    type T x a
  instance C Int where
    type T (S y) Int = y
    type T Z     Int = Char

Note that 
  a) The variable 'x' is not bound by the class decl
  b) 'x' is instantiated to a non-type-variable in the instance
  c) There are several type instance decls for T in the instance

All this is fine.  Of course, you can't give any *more* instances
for (T ty Int) elsewhere, because it's an *associated* type.

Note [Checking consistent instantiation]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  class C a b where
    type T a x b

  instance C [p] Int
    type T [p] y Int = (p,y,y)  -- Induces the family instance TyCon
                                --    type TR p y = (p,y,y)

So we 
  * Form the mini-envt from the class type variables a,b
    to the instance decl types [p],Int:   [a->[p], b->Int]

  * Look at the tyvars a,x,b of the type family constructor T
    (it shares tyvars with the class C)

  * Apply the mini-evnt to them, and check that the result is
    consistent with the instance types [p] y Int

We do *not* assume (at this point) the the bound variables of 
the assoicated type instance decl are the same as for the parent
instance decl. So, for example,

  instance C [p] Int
    type T [q] y Int = ...

would work equally well. Reason: making the *kind* variables line
up is much harder. Example (Trac #7282):
  class Foo (xs :: [k]) where
     type Bar xs :: *

   instance Foo '[] where
     type Bar '[] = Int
Here the instance decl really looks like
   instance Foo k ('[] k) where
     type Bar k ('[] k) = Int
but the k's are not scoped, and hence won't match Uniques.

So instead we just match structure, with tcMatchTyX, and check
that distinct type variables match 1-1 with distinct type variables.

HOWEVER, we *still* make the instance type variables scope over the
type instances, to pick up non-obvious kinds.  Eg
   class Foo (a :: k) where
      type F a
   instance Foo (b :: k -> k) where
      type F b = Int
Here the instance is kind-indexed and really looks like
      type F (k->k) (b::k->k) = Int
But if the 'b' didn't scope, we would make F's instance too
poly-kinded.

\begin{code}
<pre><a name="line-1"></a><a name="checkConsistentFamInst"></a><span class='hs-definition'>checkConsistentFamInst</span> 
<a name="line-2"></a>               <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Class</span>
<a name="line-3"></a>                        <span class='hs-layout'>,</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>Type</span> <span class='hs-layout'>)</span>  <span class='hs-comment'>-- ^ Class of associated type</span>
<a name="line-4"></a>                                         <span class='hs-comment'>-- and instantiation of class TyVars</span>
<a name="line-5"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span>              <span class='hs-comment'>-- ^ Family tycon</span>
<a name="line-6"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>            <span class='hs-comment'>-- ^ Type variables of the family instance</span>
<a name="line-7"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>             <span class='hs-comment'>-- ^ Type patterns from instance</span>
<a name="line-8"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-9"></a><span class='hs-comment'>-- See Note [Checking consistent instantiation]</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-definition'>checkConsistentFamInst</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-12"></a><span class='hs-definition'>checkConsistentFamInst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>clas</span><span class='hs-layout'>,</span> <span class='hs-varid'>mini_env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>at_tvs</span> <span class='hs-varid'>at_tys</span>
<a name="line-13"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- Check that the associated type indeed comes from this class</span>
<a name="line-14"></a>         <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>clas</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tyConAssoc_maybe</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-15"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>badATErr</span> <span class='hs-layout'>(</span><span class='hs-varid'>className</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-16"></a>
<a name="line-17"></a>         <span class='hs-comment'>-- See Note [Checking consistent instantiation] in TcTyClsDecls</span>
<a name="line-18"></a>         <span class='hs-comment'>-- Check right to left, so that we spot type variable</span>
<a name="line-19"></a>         <span class='hs-comment'>-- inconsistencies before (more confusing) kind variables</span>
<a name="line-20"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>discardResult</span> <span class='hs-varop'>$</span> <span class='hs-varid'>foldrM</span> <span class='hs-varid'>check_arg</span> <span class='hs-varid'>emptyTvSubst</span> <span class='hs-varop'>$</span>
<a name="line-21"></a>                         <span class='hs-varid'>tyConTyVars</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>at_tys</span> <span class='hs-layout'>}</span>
<a name="line-22"></a>  <span class='hs-keyword'>where</span>
<a name="line-23"></a>    <span class='hs-varid'>at_tv_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>at_tvs</span>
<a name="line-24"></a>
<a name="line-25"></a>    <span class='hs-varid'>check_arg</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TvSubst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>TvSubst</span>
<a name="line-26"></a>    <span class='hs-varid'>check_arg</span> <span class='hs-layout'>(</span><span class='hs-varid'>fam_tc_tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>at_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>subst</span>
<a name="line-27"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>inst_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>mini_env</span> <span class='hs-varid'>fam_tc_tv</span>
<a name="line-28"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tcMatchTyX</span> <span class='hs-varid'>at_tv_set</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>at_ty</span> <span class='hs-varid'>inst_ty</span> <span class='hs-keyword'>of</span>
<a name="line-29"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>subst</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>all_distinct</span> <span class='hs-varid'>subst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>subst</span>
<a name="line-30"></a>           <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>failWithTc</span> <span class='hs-varop'>$</span> <span class='hs-varid'>wrongATArgErr</span> <span class='hs-varid'>at_ty</span> <span class='hs-varid'>inst_ty</span>
<a name="line-31"></a>                <span class='hs-comment'>-- No need to instantiate here, because the axiom</span>
<a name="line-32"></a>                <span class='hs-comment'>-- uses the same type variables as the assocated class</span>
<a name="line-33"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-34"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>subst</span>   <span class='hs-comment'>-- Allow non-type-variable instantiation</span>
<a name="line-35"></a>                       <span class='hs-comment'>-- See Note [Associated type instances]</span>
<a name="line-36"></a>
<a name="line-37"></a>    <span class='hs-varid'>all_distinct</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TvSubst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-38"></a>    <span class='hs-comment'>-- True if all the variables mapped the substitution </span>
<a name="line-39"></a>    <span class='hs-comment'>-- map to *distinct* type *variables*</span>
<a name="line-40"></a>    <span class='hs-varid'>all_distinct</span> <span class='hs-varid'>subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>at_tvs</span>
<a name="line-41"></a>       <span class='hs-keyword'>where</span>
<a name="line-42"></a>         <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>   <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-43"></a>         <span class='hs-varid'>go</span> <span class='hs-varid'>acc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span><span class='hs-conop'>:</span><span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupTyVar</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>of</span>
<a name="line-44"></a>                             <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>acc</span> <span class='hs-varid'>tvs</span>
<a name="line-45"></a>                             <span class='hs-conid'>Just</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-46"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>tv'</span> <span class='hs-varop'>`notElem`</span> <span class='hs-varid'>acc</span>
<a name="line-47"></a>                                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs</span>
<a name="line-48"></a>                             <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-49"></a>
<a name="line-50"></a><a name="badATErr"></a><span class='hs-definition'>badATErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-51"></a><span class='hs-definition'>badATErr</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>op</span>
<a name="line-52"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hsep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Class"</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> 
<a name="line-53"></a>          <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"does not have an associated type"</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>op</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-54"></a>
<a name="line-55"></a><a name="wrongATArgErr"></a><span class='hs-definition'>wrongATArgErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-56"></a><span class='hs-definition'>wrongATArgErr</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>instTy</span> <span class='hs-keyglyph'>=</span>
<a name="line-57"></a>  <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Type indexes must match class instance head"</span><span class='hs-layout'>)</span>
<a name="line-58"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Found"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-59"></a>        <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"but expected"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>instTy</span><span class='hs-layout'>)</span>
<a name="line-60"></a>      <span class='hs-keyglyph'>]</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
        Checking type instance well-formedness and termination
%*                                                                      *
%************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="checkValidTyFamInst"></a><span class='hs-comment'>-- Check that a "type instance" is well-formed (which includes decidability</span>
<a name="line-2"></a><span class='hs-comment'>-- unless -XUndecidableInstances is given).</span>
<a name="line-3"></a><span class='hs-comment'>--</span>
<a name="line-4"></a><span class='hs-definition'>checkValidTyFamInst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>Type</span> <span class='hs-layout'>)</span>
<a name="line-5"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-6"></a><span class='hs-definition'>checkValidTyFamInst</span> <span class='hs-varid'>mb_clsinfo</span> <span class='hs-varid'>fam_tc</span> 
<a name="line-7"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>CoAxBranch</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cab_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cab_lhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typats</span>
<a name="line-8"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>cab_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cab_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setSrcSpan</span> <span class='hs-varid'>loc</span> <span class='hs-varop'>$</span> 
<a name="line-10"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkValidFamPats</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>typats</span>
<a name="line-11"></a>
<a name="line-12"></a>         <span class='hs-comment'>-- The right-hand side is a tau type</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkValidMonoType</span> <span class='hs-varid'>rhs</span>
<a name="line-14"></a>
<a name="line-15"></a>         <span class='hs-comment'>-- We have a decidable instance unless otherwise permitted</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>undecidable_ok</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_UndecidableInstances</span>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-varid'>undecidable_ok</span> <span class='hs-varop'>$</span>
<a name="line-18"></a>           <span class='hs-varid'>mapM_</span> <span class='hs-varid'>addErrTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkFamInstRhs</span> <span class='hs-varid'>typats</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcTyFamInsts</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-19"></a>
<a name="line-20"></a>         <span class='hs-comment'>-- Check that type patterns match the class instance head</span>
<a name="line-21"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkConsistentFamInst</span> <span class='hs-varid'>mb_clsinfo</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>typats</span> <span class='hs-layout'>}</span>
<a name="line-22"></a>
<a name="line-23"></a><a name="checkFamInstRhs"></a><span class='hs-comment'>-- Make sure that each type family application is </span>
<a name="line-24"></a><span class='hs-comment'>--   (1) strictly smaller than the lhs,</span>
<a name="line-25"></a><span class='hs-comment'>--   (2) mentions no type variable more often than the lhs, and</span>
<a name="line-26"></a><span class='hs-comment'>--   (3) does not contain any further type family instances.</span>
<a name="line-27"></a><span class='hs-comment'>--</span>
<a name="line-28"></a><span class='hs-definition'>checkFamInstRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>                  <span class='hs-comment'>-- lhs</span>
<a name="line-29"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>TyCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- type family instances</span>
<a name="line-30"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MsgDoc</span><span class='hs-keyglyph'>]</span>
<a name="line-31"></a><span class='hs-definition'>checkFamInstRhs</span> <span class='hs-varid'>lhsTys</span> <span class='hs-varid'>famInsts</span>
<a name="line-32"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapCatMaybes</span> <span class='hs-varid'>check</span> <span class='hs-varid'>famInsts</span>
<a name="line-33"></a>  <span class='hs-keyword'>where</span>
<a name="line-34"></a>   <span class='hs-varid'>size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-varid'>lhsTys</span>
<a name="line-35"></a>   <span class='hs-varid'>fvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvTypes</span> <span class='hs-varid'>lhsTys</span>
<a name="line-36"></a>   <span class='hs-varid'>check</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-37"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-varid'>isTyFamFree</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-38"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>famInstUndecErr</span> <span class='hs-varid'>famInst</span> <span class='hs-varid'>nestedMsg</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>parens</span> <span class='hs-varid'>undecidableMsg</span><span class='hs-layout'>)</span>
<a name="line-39"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span>
<a name="line-40"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>famInstUndecErr</span> <span class='hs-varid'>famInst</span> <span class='hs-layout'>(</span><span class='hs-varid'>nomoreMsg</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>parens</span> <span class='hs-varid'>undecidableMsg</span><span class='hs-layout'>)</span>
<a name="line-41"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>size</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-varid'>tys</span>
<a name="line-42"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>famInstUndecErr</span> <span class='hs-varid'>famInst</span> <span class='hs-varid'>smallerAppMsg</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>parens</span> <span class='hs-varid'>undecidableMsg</span><span class='hs-layout'>)</span>
<a name="line-43"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-44"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-45"></a>      <span class='hs-keyword'>where</span>
<a name="line-46"></a>        <span class='hs-varid'>famInst</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-47"></a>        <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOut</span> <span class='hs-varid'>isKindVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>fvTypes</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>\\</span> <span class='hs-varid'>fvs</span><span class='hs-layout'>)</span>
<a name="line-48"></a>             <span class='hs-comment'>-- Rightly or wrongly, we only check for</span>
<a name="line-49"></a>             <span class='hs-comment'>-- excessive occurrences of *type* variables.</span>
<a name="line-50"></a>             <span class='hs-comment'>-- e.g. type instance Demote {T k} a = T (Demote {k} (Any {k}))</span>
<a name="line-51"></a>
<a name="line-52"></a><a name="checkValidFamPats"></a><span class='hs-definition'>checkValidFamPats</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-53"></a><span class='hs-comment'>-- Patterns in a 'type instance' or 'data instance' decl should</span>
<a name="line-54"></a><span class='hs-comment'>-- a) contain no type family applications</span>
<a name="line-55"></a><span class='hs-comment'>--    (vanilla synonyms are fine, though)</span>
<a name="line-56"></a><span class='hs-comment'>-- b) properly bind all their free type variables</span>
<a name="line-57"></a><span class='hs-comment'>--    e.g. we disallow (Trac #7536)</span>
<a name="line-58"></a><span class='hs-comment'>--         type T a = Int</span>
<a name="line-59"></a><span class='hs-comment'>--         type instance F (T a) = a</span>
<a name="line-60"></a><span class='hs-comment'>-- c) Have the right number of patterns</span>
<a name="line-61"></a><span class='hs-definition'>checkValidFamPats</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>ty_pats</span>
<a name="line-62"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- A family instance must have exactly the same number of type</span>
<a name="line-63"></a>         <span class='hs-comment'>-- parameters as the family declaration.  You can't write</span>
<a name="line-64"></a>         <span class='hs-comment'>--     type family F a :: * -&gt; *</span>
<a name="line-65"></a>         <span class='hs-comment'>--     type instance F Int y = y</span>
<a name="line-66"></a>         <span class='hs-comment'>-- because then the type (F Int) would be like (\y.y)</span>
<a name="line-67"></a>         <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>ty_pats</span> <span class='hs-varop'>==</span> <span class='hs-varid'>fam_arity</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-68"></a>           <span class='hs-varid'>wrongNumberOfParmsErr</span> <span class='hs-layout'>(</span><span class='hs-varid'>fam_arity</span> <span class='hs-comment'>-</span> <span class='hs-varid'>length</span> <span class='hs-varid'>fam_kvs</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- report only types</span>
<a name="line-69"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>checkTyFamFreeness</span> <span class='hs-varid'>ty_pats</span>
<a name="line-70"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>unbound_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOut</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>exactTyVarsOfTypes</span> <span class='hs-varid'>ty_pats</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs</span>
<a name="line-71"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>unbound_tvs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>famPatErr</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>unbound_tvs</span> <span class='hs-varid'>ty_pats</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-72"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>fam_arity</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>fam_tc</span>
<a name="line-73"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>fam_kvs</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitForAllTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConKind</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-74"></a>
<a name="line-75"></a><a name="wrongNumberOfParmsErr"></a><span class='hs-definition'>wrongNumberOfParmsErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Arity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-76"></a><span class='hs-definition'>wrongNumberOfParmsErr</span> <span class='hs-varid'>exp_arity</span>
<a name="line-77"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Number of parameters must match family declaration; expected"</span><span class='hs-layout'>)</span>
<a name="line-78"></a>    <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>exp_arity</span>
<a name="line-79"></a>
<a name="line-80"></a><a name="checkTyFamFreeness"></a><span class='hs-comment'>-- Ensure that no type family instances occur in a type.</span>
<a name="line-81"></a><span class='hs-comment'>--</span>
<a name="line-82"></a><span class='hs-definition'>checkTyFamFreeness</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-83"></a><span class='hs-definition'>checkTyFamFreeness</span> <span class='hs-varid'>ty</span>
<a name="line-84"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTyFamFree</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-85"></a>    <span class='hs-varid'>tyFamInstIllegalErr</span> <span class='hs-varid'>ty</span>
<a name="line-86"></a>
<a name="line-87"></a><a name="isTyFamFree"></a><span class='hs-comment'>-- Check that a type does not contain any type family applications.</span>
<a name="line-88"></a><span class='hs-comment'>--</span>
<a name="line-89"></a><span class='hs-definition'>isTyFamFree</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-90"></a><span class='hs-definition'>isTyFamFree</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>null</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tcTyFamInsts</span>
<a name="line-91"></a>
<a name="line-92"></a><span class='hs-comment'>-- Error messages</span>
<a name="line-93"></a>
<a name="line-94"></a><a name="tyFamInstIllegalErr"></a><span class='hs-definition'>tyFamInstIllegalErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-95"></a><span class='hs-definition'>tyFamInstIllegalErr</span> <span class='hs-varid'>ty</span>
<a name="line-96"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Illegal type synonym family application in instance"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> 
<a name="line-97"></a>         <span class='hs-varid'>colon</span><span class='hs-layout'>)</span> <span class='hs-num'>2</span> <span class='hs-varop'>$</span>
<a name="line-98"></a>      <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-99"></a>
<a name="line-100"></a><a name="famInstUndecErr"></a><span class='hs-definition'>famInstUndecErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-101"></a><span class='hs-definition'>famInstUndecErr</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>msg</span> 
<a name="line-102"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>msg</span><span class='hs-layout'>,</span> 
<a name="line-103"></a>         <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"in the type family application:"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> 
<a name="line-104"></a>                 <span class='hs-varid'>pprType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-105"></a>
<a name="line-106"></a><a name="famPatErr"></a><span class='hs-definition'>famPatErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-107"></a><span class='hs-definition'>famPatErr</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>pats</span>
<a name="line-108"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Family instance purports to bind type variable"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>plural</span> <span class='hs-varid'>tvs</span>
<a name="line-109"></a>          <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprQuotedList</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span>
<a name="line-110"></a>       <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"but the real LHS (expanding synonyms) is:"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-111"></a>             <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprTypeApp</span> <span class='hs-varid'>fam_tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>expandTypeSynonyms</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"= ..."</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-112"></a>
<a name="line-113"></a><a name="nestedMsg"></a><span class='hs-definition'>nestedMsg</span><span class='hs-layout'>,</span> <span class='hs-varid'>smallerAppMsg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SDoc</span>
<a name="line-114"></a><span class='hs-definition'>nestedMsg</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Nested type family application"</span><span class='hs-layout'>)</span>
<a name="line-115"></a><a name="smallerAppMsg"></a><span class='hs-definition'>smallerAppMsg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Application is no smaller than the instance head"</span><span class='hs-layout'>)</span>
</pre>\end{code}

%************************************************************************
%*                                                                      *
\subsection{Auxiliary functions}
%*                                                                      *
%************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="fvType"></a><span class='hs-comment'>-- Free variables of a type, retaining repetitions, and expanding synonyms</span>
<a name="line-2"></a><span class='hs-definition'>fvType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>
<a name="line-3"></a><span class='hs-definition'>fvType</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>exp_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>exp_ty</span>
<a name="line-4"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>tv</span><span class='hs-keyglyph'>]</span>
<a name="line-5"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvTypes</span> <span class='hs-varid'>tys</span>
<a name="line-6"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-7"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>++</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>res</span>
<a name="line-8"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>++</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>arg</span>
<a name="line-9"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-varid'>tyvar</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varop'>/=</span> <span class='hs-varid'>tyvar</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>fvType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-10"></a>
<a name="line-11"></a><a name="fvTypes"></a><span class='hs-definition'>fvTypes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>
<a name="line-12"></a><span class='hs-definition'>fvTypes</span> <span class='hs-varid'>tys</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-13"></a>
<a name="line-14"></a><a name="sizeType"></a><span class='hs-definition'>sizeType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-15"></a><span class='hs-comment'>-- Size of a type: the number of variables and constructors</span>
<a name="line-16"></a><span class='hs-definition'>sizeType</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>exp_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>exp_ty</span>
<a name="line-17"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-18"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span>
<a name="line-19"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-20"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>res</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span>
<a name="line-21"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>arg</span>
<a name="line-22"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>ty</span>
<a name="line-23"></a>
<a name="line-24"></a><a name="sizeTypes"></a><span class='hs-definition'>sizeTypes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-25"></a><span class='hs-comment'>-- IA0_NOTE: Avoid kinds.</span>
<a name="line-26"></a><span class='hs-definition'>sizeTypes</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-27"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>isKind</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
<a name="line-28"></a>
<a name="line-29"></a><a name="sizePred"></a><span class='hs-comment'>-- Size of a predicate</span>
<a name="line-30"></a><span class='hs-comment'>--</span>
<a name="line-31"></a><span class='hs-comment'>-- We are considering whether class constraints terminate.</span>
<a name="line-32"></a><span class='hs-comment'>-- Equality constraints and constraints for the implicit</span>
<a name="line-33"></a><span class='hs-comment'>-- parameter class always termiante so it is safe to say "size 0".</span>
<a name="line-34"></a><span class='hs-comment'>-- (Implicit parameter constraints always terminate because</span>
<a name="line-35"></a><span class='hs-comment'>-- there are no instances for them---they are only solved by</span>
<a name="line-36"></a><span class='hs-comment'>-- "local instances" in expressions).</span>
<a name="line-37"></a><span class='hs-comment'>-- See Trac #4200.</span>
<a name="line-38"></a><span class='hs-definition'>sizePred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-39"></a><span class='hs-definition'>sizePred</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>goClass</span> <span class='hs-varid'>ty</span>
<a name="line-40"></a>  <span class='hs-keyword'>where</span>
<a name="line-41"></a>    <span class='hs-varid'>goClass</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isIPPred</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-42"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-43"></a>
<a name="line-44"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClassPred</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tys'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-varid'>tys'</span>
<a name="line-45"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>EqPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-46"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TuplePred</span> <span class='hs-varid'>ts</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>goClass</span> <span class='hs-varid'>ts</span><span class='hs-layout'>)</span>
<a name="line-47"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>IrredPred</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>ty</span>
</pre>\end{code}

Note [Paterson conditions on PredTypes]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We are considering whether *class* constraints terminate
(see Note [Paterson conditions]). Precisely, the Paterson conditions
would have us check that "the constraint has fewer constructors and variables
(taken together and counting repetitions) than the head.".

However, we can be a bit more refined by looking at which kind of constraint
this actually is. There are two main tricks:

 1. It seems like it should be OK not to count the tuple type constructor
    for a PredType like (Show a, Eq a) :: Constraint, since we don't
    count the "implicit" tuple in the ThetaType itself.

    In fact, the Paterson test just checks *each component* of the top level
    ThetaType against the size bound, one at a time. By analogy, it should be
    OK to return the size of the *largest* tuple component as the size of the
    whole tuple.

 2. Once we get into an implicit parameter or equality we
    can't get back to a class constraint, so it's safe
    to say "size 0".  See Trac #4200.

NB: we don't want to detect PredTypes in sizeType (and then call 
sizePred on them), or we might get an infinite loop if that PredType
is irreducible. See Trac #5581.
</body>
</html>
