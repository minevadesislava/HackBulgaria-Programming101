<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>7.25. Roles</title><link rel="stylesheet" type="text/css" href="fptools.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.8.3"><link rel="up" href="ghc-language-features.html" title="Chapter 7. GHC Language Features"><link rel="prev" href="generic-programming.html" title="7.24. Generic programming"><link rel="next" href="lang-parallel.html" title="7.26. Concurrent and Parallel Haskell"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.25. Roles

</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="generic-programming.html">Prev</a> </td><th width="60%" align="center">Chapter 7. GHC Language Features</th><td width="20%" align="right"> <a accesskey="n" href="lang-parallel.html">Next</a></td></tr></table><hr></div><div class="sect1" title="7.25. Roles"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="roles"></a>7.25. Roles
<a class="indexterm" name="idp25243136"></a>
</h2></div></div></div><p>
Using <code class="option">-XGeneralizedNewtypeDeriving</code> (<a class="xref" href="deriving.html#generalized-newtype-deriving" title="7.5.5.1.  Generalising the deriving clause">Section 7.5.5.1, &#8220; Generalising the deriving clause &#8221;</a>), a programmer can take existing
instances of classes and "lift" these into instances of that class for a
newtype. However, this is not always safe. For example, consider the following:
</p><pre class="programlisting">
  newtype Age = MkAge { unAge :: Int }

  type family Inspect x
  type instance Inspect Age = Int
  type instance Inspect Int = Bool

  class BadIdea a where
    bad :: a -&gt; Inspect a

  instance BadIdea Int where
    bad = (&gt; 0)

  deriving instance BadIdea Age    -- not allowed!
</pre><p>
If the derived instance were allowed, what would the type of its method
<code class="literal">bad</code> be? It would seem to be <code class="literal">Age -&gt; Inspect
Age</code>, which is equivalent to <code class="literal">Age -&gt; Int</code>, according
to the type family <code class="literal">Inspect</code>. Yet, if we simply adapt the
implementation from the instance for <code class="literal">Int</code>, the implementation
for <code class="literal">bad</code> produces a <code class="literal">Bool</code>, and we have trouble.
</p><p>
The way to identify such situations is to have <span class="emphasis"><em>roles</em></span> assigned
to type variables of datatypes, classes, and type synonyms.</p><p>
Roles as implemented in GHC are a from a simplified version of the work
described in <a class="ulink" href="http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf" target="_top">Generative
type abstraction and type-level computation</a>, published at POPL 2011.</p><div class="sect2" title="7.25.1. Nominal, Representational, and Phantom"><div class="titlepage"><div><div><h3 class="title"><a name="idp25254608"></a>7.25.1. Nominal, Representational, and Phantom</h3></div></div></div><p>The goal of the roles system is to track when two types have the same
underlying representation. In the example above, <code class="literal">Age</code> and
<code class="literal">Int</code> have the same representation. But, the corresponding
instances of <code class="literal">BadIdea</code> would <span class="emphasis"><em>not</em></span> have
the same representation, because the types of the implementations of
<code class="literal">bad</code> would be different.</p><p>Suppose we have two uses of a type constructor, each applied to the same
parameters except for one difference. (For example, <code class="literal">T Age Bool
c</code> and <code class="literal">T Int Bool c</code> for some type
<code class="literal">T</code>.) The role of a type parameter says what we need to
know about the two differing type arguments in order to know that the two
outer types have the same representation (in the example, what must be true
about <code class="literal">Age</code> and <code class="literal">Int</code> in order to show that
<code class="literal">T Age Bool c</code> has the same representation as <code class="literal">
T Int Bool c</code>).</p><p>GHC supports three different roles for type parameters: nominal,
representational, and phantom. If a type parameter has a nominal role, then
the two types that differ must not actually differ at all: they must be
identical (after type family reduction). If a type parameter has a
representational role, then the two types must have the same representation.
(If <code class="literal">T</code>'s first parameter's role is representational, then
<code class="literal">T Age Bool c</code> and <code class="literal">T Int Bool c</code> would have
the same representation, because <code class="literal">Age</code> and
<code class="literal">Int</code> have the same representation.) If a type parameter has
a phantom role, then we need no further information.</p><p>Here are some examples:</p><pre class="programlisting">
  data Simple a = MkSimple a          -- a has role representational

  type family F
  type instance F Int = Bool
  type instance F Age = Char

  data Complex a = MkComplex (F a)    -- a has role nominal

  data Phant a = MkPhant Bool         -- a has role phantom
</pre><p>The type <code class="literal">Simple</code> has its parameter at role
representational, which is generally the most common case. <code class="literal">Simple
Age</code> would have the same representation as <code class="literal">Simple
Int</code>. The type <code class="literal">Complex</code>, on the other hand, has its
parameter at role nominal, because <code class="literal">Simple Age</code> and
<code class="literal">Simple Int</code> are <span class="emphasis"><em>not</em></span> the same. Lastly,
<code class="literal">Phant Age</code> and <code class="literal">Phant Bool</code> have the same
representation, even though <code class="literal">Age</code> and <code class="literal">Bool</code>
are unrelated.</p></div><div class="sect2" title="7.25.2. Role inference"><div class="titlepage"><div><div><h3 class="title"><a name="idp25278896"></a>7.25.2. Role inference</h3></div></div></div><p>
What role should a given type parameter should have? GHC performs role
inference to determine the correct role for every parameter. It starts with a
few base facts: <code class="literal">(-&gt;)</code> has two representational parameters;
<code class="literal">(~)</code> has two nominal parameters; all type families'
parameters are nominal; and all GADT-like parameters are nominal. Then, these
facts are propagated to all places where these types are used. The default
role for datatypes and synonyms is phantom; the default role for classes is
nominal. Thus, for datatypes and synonyms, any parameters unused in the
right-hand side (or used only in other types in phantom positions) will be
phantom. Whenever a parameter is used in a representational position (that is,
used as a type argument to a constructor whose corresponding variable is at
role representational), we raise its role from phantom to representational.
Similarly, when a parameter is used in a nominal position, its role is
upgraded to nominal. We never downgrade a role from nominal to phantom or
representational, or from representational to phantom. In this way, we infer
the most-general role for each parameter.
</p><p>
Classes have their roles default to nominal to promote coherence of class
instances. If a <code class="literal">C Int</code> were stored in a datatype, it would
be quite bad if that were somehow changed into a <code class="literal">C Age</code>
somewhere, especially if another <code class="literal">C Age</code> had been declared!
</p><p>There is one particularly tricky case that should be explained:</p><pre class="programlisting">
  data Tricky a b = MkTricky (a b)
</pre><p>What should <code class="literal">Tricky</code>'s roles be? At first blush, it
would seem that both <code class="literal">a</code> and <code class="literal">b</code> should be
at role representational, since both are used in the right-hand side and
neither is involved in a type family. However, this would be wrong, as the
following example shows:</p><pre class="programlisting">
  data Nom a = MkNom (F a)   -- type family F from example above
</pre><p>Is <code class="literal">Tricky Nom Age</code> representationally equal to
<code class="literal">Tricky Nom Int</code>? No! The former stores a
<code class="literal">Char</code> and the latter stores a <code class="literal">Bool</code>. The
solution to this is to require all parameters to type variables to have role
nominal. Thus, GHC would infer role representational for <code class="literal">a</code>
but role nominal for <code class="literal">b</code>.</p></div><div class="sect2" title="7.25.3. Role annotations"><div class="titlepage"><div><div><h3 class="title"><a name="idp25294800"></a>7.25.3. Role annotations
<a class="indexterm" name="idp25295344"></a>
</h3></div></div></div><p>
Sometimes the programmer wants to constrain the inference process. For
example, the base library contains the following definition:
</p><pre class="programlisting">
  data Ptr a = Ptr Addr#
</pre><p>
The idea is that <code class="literal">a</code> should really be a representational
parameter, but role inference assigns it to phantom. This makes some level of
sense: a pointer to an <code class="literal">Int</code> really is representationally the
same as a pointer to a <code class="literal">Bool</code>. But, that's not at all how we
want to use <code class="literal">Ptr</code>s! So, we want to be able to say</p><pre class="programlisting">
  type role Ptr representational
  data Ptr a = Ptr Addr#
</pre><p>
The <code class="literal">type role</code> (enabled with
<code class="option">-XRoleAnnotations</code>) declaration forces the parameter
<code class="literal">a</code> to be at role representational, not role phantom. GHC
then checks the user-supplied roles to make sure they don't break any
promises. It would be bad, for example, if the user could make
<code class="literal">BadIdea</code>'s role be representational.
</p><p>As another example, we can consider a type <code class="literal">Set a</code> that
represents a set of data, ordered according to <code class="literal">a</code>'s
<code class="literal">Ord</code> instance. While it would generally be type-safe to
consider <code class="literal">a</code> to be at role representational, it is possible
that a <code class="literal">newtype</code> and its base type have
<span class="emphasis"><em>different</em></span> orderings encoded in their respective
<code class="literal">Ord</code> instances. This would lead to misbehavior at runtime.
So, the author of the <code class="literal">Set</code> datatype would like its parameter
to be at role nominal. This would be done with a declaration</p><pre class="programlisting">
  type role Set nominal
</pre><p>Role annotations can also be used should a programmer wish to write
a class with a representational (or phantom) role.</p><p>The other place where role annotations may be necessary are in
<code class="literal">hs-boot</code> files (<a class="xref" href="separate-compilation.html#mutual-recursion" title="4.7.9. How to compile mutually recursive modules">Section 4.7.9, &#8220;How to compile mutually recursive modules&#8221;</a>), where
the right-hand sides of definitions can be omitted. As usual, the
types/classes declared in an <code class="literal">hs-boot</code> file must match up
with the definitions in the <code class="literal">hs</code> file, including down to the
roles. The default role is representational in <code class="literal">hs-boot</code> files,
corresponding to the common use case.</p><p>
Role annotations are allowed on data, newtype, and class declarations. A role
annotation declaration starts with <code class="literal">type role</code> and is
followed by one role listing for each parameter of the type. (This parameter
count includes parameters implicitly specified by a kind signature in a
GADT-style data or newtype declaration.) Each role listing is a role
(<code class="literal">nominal</code>, <code class="literal">representational</code>, or
<code class="literal">phantom</code>) or a <code class="literal">_</code>. Using a
<code class="literal">_</code> says that GHC should infer that role. The role annotation
may go anywhere in the same module as the datatype or class definition
(much like a value-level type signature).
Here are some examples:</p><pre class="programlisting">
  type role T1 _ phantom
  data T1 a b = MkT1 a     -- b is not used; annotation is fine but unnecessary

  type role T2 _ phantom
  data T2 a b = MkT2 b     -- ERROR: b is used and cannot be phantom

  type role T3 _ nominal
  data T3 a b = MkT3 a     -- OK: nominal is higher than necessary, but safe

  type role T4 nominal
  data T4 a = MkT4 (a Int) -- OK, but nominal is higher than necessary

  type role C representational _
  class C a b where ...    -- OK, b will get a nominal role

  type role X nominal
  type X a = ...           -- ERROR: role annotations not allowed for type synonyms
</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="generic-programming.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ghc-language-features.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="lang-parallel.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.24. Generic programming </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.26. Concurrent and Parallel Haskell</td></tr></table></div></body></html>
