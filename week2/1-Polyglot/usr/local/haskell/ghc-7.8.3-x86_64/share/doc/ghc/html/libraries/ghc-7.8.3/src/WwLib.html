<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>stranal/WwLib.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
%
% (c) The GRASP/AQUA Project, Glasgow University, 1993-1998
%
\section[WwLib]{A library for the ``worker\/wrapper'' back-end to the strictness analyser}

\begin{code}
<pre><a name="line-1"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>WwLib</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkWwBodies</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkWWstr</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkWorkerArgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>deepSplitProductType_maybe</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-4"></a>
<a name="line-5"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreSyn</span>
<a name="line-6"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreUtils</span>        <span class='hs-layout'>(</span> <span class='hs-varid'>exprType</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCast</span> <span class='hs-layout'>)</span>
<a name="line-7"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Id</span>               <span class='hs-layout'>(</span> <span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-varid'>idType</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkSysLocal</span><span class='hs-layout'>,</span> <span class='hs-varid'>idDemandInfo</span><span class='hs-layout'>,</span> <span class='hs-varid'>setIdDemandInfo</span><span class='hs-layout'>,</span>
<a name="line-8"></a>                          <span class='hs-varid'>setIdUnfolding</span><span class='hs-layout'>,</span>
<a name="line-9"></a>                          <span class='hs-varid'>setIdInfo</span><span class='hs-layout'>,</span> <span class='hs-varid'>idOneShotInfo</span><span class='hs-layout'>,</span> <span class='hs-varid'>setIdOneShotInfo</span>
<a name="line-10"></a>                        <span class='hs-layout'>)</span>
<a name="line-11"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>IdInfo</span>           <span class='hs-layout'>(</span> <span class='hs-varid'>vanillaIdInfo</span> <span class='hs-layout'>)</span>
<a name="line-12"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DataCon</span>
<a name="line-13"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Demand</span>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MkCore</span>           <span class='hs-layout'>(</span> <span class='hs-varid'>mkRuntimeErrorApp</span><span class='hs-layout'>,</span> <span class='hs-varid'>aBSENT_ERROR_ID</span> <span class='hs-layout'>)</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MkId</span>             <span class='hs-layout'>(</span> <span class='hs-varid'>voidArgId</span><span class='hs-layout'>,</span> <span class='hs-varid'>voidPrimId</span> <span class='hs-layout'>)</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TysPrim</span>          <span class='hs-layout'>(</span> <span class='hs-varid'>voidPrimTy</span> <span class='hs-layout'>)</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TysWiredIn</span>       <span class='hs-layout'>(</span> <span class='hs-varid'>tupleCon</span> <span class='hs-layout'>)</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>hiding</span>  <span class='hs-layout'>(</span> <span class='hs-varid'>substTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>substTyVarBndr</span> <span class='hs-layout'>)</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FamInstEnv</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>       <span class='hs-layout'>(</span> <span class='hs-conid'>TupleSort</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>OneShotInfo</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>worstOneShot</span> <span class='hs-layout'>)</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Literal</span>          <span class='hs-layout'>(</span> <span class='hs-varid'>absentLiteralOf</span> <span class='hs-layout'>)</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>UniqSupply</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unique</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Maybes</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
\subsection[mkWrapperAndWorker]{@mkWrapperAndWorker@}
%*                                                                      *
%************************************************************************

Here's an example.  The original function is:

\begin{verbatim}
g :: forall a . Int -> [a] -> a

g = \/\ a -> \ x ys ->
        case x of
          0 -> head ys
          _ -> head (tail ys)
\end{verbatim}

From this, we want to produce:
\begin{verbatim}
-- wrapper (an unfolding)
g :: forall a . Int -> [a] -> a

g = \/\ a -> \ x ys ->
        case x of
          I# x# -> $wg a x# ys
            -- call the worker; don't forget the type args!

-- worker
$wg :: forall a . Int# -> [a] -> a

$wg = \/\ a -> \ x# ys ->
        let
            x = I# x#
        in
            case x of               -- note: body of g moved intact
              0 -> head ys
              _ -> head (tail ys)
\end{verbatim}

Something we have to be careful about:  Here's an example:

\begin{verbatim}
-- "f" strictness: U(P)U(P)
f (I# a) (I# b) = a +# b

g = f   -- "g" strictness same as "f"
\end{verbatim}

\tr{f} will get a worker all nice and friendly-like; that's good.
{\em But we don't want a worker for \tr{g}}, even though it has the
same strictness as \tr{f}.  Doing so could break laziness, at best.

Consequently, we insist that the number of strictness-info items is
exactly the same as the number of lambda-bound arguments.  (This is
probably slightly paranoid, but OK in practice.)  If it isn't the
same, we ``revise'' the strictness info, so that we won't propagate
the unusable strictness-info into the interfaces.


%************************************************************************
%*                                                                      *
\subsection{The worker wrapper core}
%*                                                                      *
%************************************************************************

@mkWwBodies@ is called when doing the worker\/wrapper split inside a module.

\begin{code}
<pre><a name="line-1"></a><a name="mkWwBodies"></a><span class='hs-definition'>mkWwBodies</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-2"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-3"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>                                  <span class='hs-comment'>-- Type of original function</span>
<a name="line-4"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>                              <span class='hs-comment'>-- Strictness of original function</span>
<a name="line-5"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdResult</span>                             <span class='hs-comment'>-- Info about function result</span>
<a name="line-6"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShotInfo</span><span class='hs-keyglyph'>]</span>                         <span class='hs-comment'>-- One-shot-ness of the function, value args only</span>
<a name="line-7"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>              <span class='hs-comment'>-- Demands for worker (value) args</span>
<a name="line-8"></a>                             <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Wrapper body, lacking only the worker Id</span>
<a name="line-9"></a>                             <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Worker body, lacking the original function rhs</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-comment'>-- wrap_fn_args E       = \x y -&gt; E</span>
<a name="line-12"></a><span class='hs-comment'>-- work_fn_args E       = E x y</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-comment'>-- wrap_fn_str E        = case x of { (a,b) -&gt;</span>
<a name="line-15"></a><span class='hs-comment'>--                        case a of { (a1,a2) -&gt;</span>
<a name="line-16"></a><span class='hs-comment'>--                        E a1 a2 b y }}</span>
<a name="line-17"></a><span class='hs-comment'>-- work_fn_str E        = \a2 a2 b y -&gt;</span>
<a name="line-18"></a><span class='hs-comment'>--                        let a = (a1,a2) in</span>
<a name="line-19"></a><span class='hs-comment'>--                        let x = (a,b) in</span>
<a name="line-20"></a><span class='hs-comment'>--                        E</span>
<a name="line-21"></a>
<a name="line-22"></a><span class='hs-definition'>mkWwBodies</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>demands</span> <span class='hs-varid'>res_info</span> <span class='hs-varid'>one_shots</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>demands</span> <span class='hs-varop'>`zip`</span> <span class='hs-layout'>(</span><span class='hs-varid'>one_shots</span> <span class='hs-varop'>++</span> <span class='hs-varid'>repeat</span> <span class='hs-conid'>NoOneShotInfo</span><span class='hs-layout'>)</span>
<a name="line-24"></a>              <span class='hs-varid'>all_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>worstOneShot</span> <span class='hs-varop'>.</span> <span class='hs-varid'>snd</span><span class='hs-layout'>)</span> <span class='hs-conid'>OneShotLam</span> <span class='hs-varid'>arg_info</span>
<a name="line-25"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>emptyTvSubst</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>arg_info</span>
<a name="line-26"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful1</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_str</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_str</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>wrap_args</span>
<a name="line-27"></a>
<a name="line-28"></a>        <span class='hs-comment'>-- Do CPR w/w.  See Note [Always do CPR w/w]</span>
<a name="line-29"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful2</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_cpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_cpr</span><span class='hs-layout'>,</span>  <span class='hs-varid'>cpr_res_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWcpr</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>res_ty</span> <span class='hs-varid'>res_info</span>
<a name="line-30"></a>
<a name="line-31"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_lam_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_call_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWorkerArgs</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>work_args</span> <span class='hs-varid'>all_one_shots</span> <span class='hs-varid'>cpr_res_ty</span>
<a name="line-32"></a>              <span class='hs-varid'>worker_args_dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>work_call_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>v</span><span class='hs-keyglyph'>]</span>
<a name="line-33"></a>              <span class='hs-varid'>wrapper_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrap_fn_args</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_cpr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_str</span> <span class='hs-varop'>.</span> <span class='hs-varid'>applyToVars</span> <span class='hs-varid'>work_call_args</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Var</span>
<a name="line-34"></a>              <span class='hs-varid'>worker_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>work_lam_args</span><span class='hs-varop'>.</span> <span class='hs-varid'>work_fn_str</span> <span class='hs-varop'>.</span> <span class='hs-varid'>work_fn_cpr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>work_fn_args</span>
<a name="line-35"></a>
<a name="line-36"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>useful1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>only_one_void_argument</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>useful2</span>
<a name="line-37"></a>          <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>worker_args_dmds</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrapper_body</span><span class='hs-layout'>,</span> <span class='hs-varid'>worker_body</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-38"></a>          <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
<a name="line-39"></a>        <span class='hs-layout'>}</span>
<a name="line-40"></a>        <span class='hs-comment'>-- We use an INLINE unconditionally, even if the wrapper turns out to be</span>
<a name="line-41"></a>        <span class='hs-comment'>-- something trivial like</span>
<a name="line-42"></a>        <span class='hs-comment'>--      fw = ...</span>
<a name="line-43"></a>        <span class='hs-comment'>--      f = __inline__ (coerce T fw)</span>
<a name="line-44"></a>        <span class='hs-comment'>-- The point is to propagate the coerce to f's call sites, so even though</span>
<a name="line-45"></a>        <span class='hs-comment'>-- f's RHS is now trivial (size 1) we still want the __inline__ to prevent</span>
<a name="line-46"></a>        <span class='hs-comment'>-- fw from being inlined into f's RHS</span>
<a name="line-47"></a>  <span class='hs-keyword'>where</span>
<a name="line-48"></a>    <span class='hs-comment'>-- Note [Do not split void functions]</span>
<a name="line-49"></a>    <span class='hs-varid'>only_one_void_argument</span>
<a name="line-50"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>demands</span>
<a name="line-51"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_ty1</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-52"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isAbsDmd</span> <span class='hs-varid'>d</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isVoidTy</span> <span class='hs-varid'>arg_ty1</span>
<a name="line-53"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-54"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-55"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-56"></a>
</pre>\end{code}

Note [Always do CPR w/w]
~~~~~~~~~~~~~~~~~~~~~~~~
At one time we refrained from doing CPR w/w for thunks, on the grounds that
we might duplicate work.  But that is already handled by the demand analyser,
which doesn't give the CPR proprety if w/w might waste work: see
Note [CPR for thunks] in DmdAnal.

And if something *has* been given the CPR property and we don't w/w, it's
a disaster, because then the enclosing function might say it has the CPR
property, but now doesn't and there a cascade of disaster.  A good example
is Trac #5920.


%************************************************************************
%*                                                                      *
\subsection{Making wrapper args}
%*                                                                      *
%************************************************************************

During worker-wrapper stuff we may end up with an unlifted thing
which we want to let-bind without losing laziness.  So we
add a void argument.  E.g.

        f = /\a -> \x y z -> E::Int#    -- E does not mention x,y,z
==>
        fw = /\ a -> \void -> E
        f  = /\ a -> \x y z -> fw realworld

We use the state-token type which generates no code.

\begin{code}
<pre><a name="line-1"></a><a name="mkWorkerArgs"></a><span class='hs-definition'>mkWorkerArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>
<a name="line-2"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OneShotInfo</span>  <span class='hs-comment'>-- Whether all arguments are one-shot</span>
<a name="line-3"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- Type of body</span>
<a name="line-4"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- Lambda bound args</span>
<a name="line-5"></a>                 <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Args at call site</span>
<a name="line-6"></a><span class='hs-definition'>mkWorkerArgs</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>args</span> <span class='hs-varid'>all_one_shot</span> <span class='hs-varid'>res_ty</span>
<a name="line-7"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>args</span> <span class='hs-varop'>||</span> <span class='hs-varid'>not</span> <span class='hs-varid'>needsAValueLambda</span>
<a name="line-8"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-9"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-10"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>args</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>newArg</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>voidPrimId</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-11"></a>    <span class='hs-keyword'>where</span>
<a name="line-12"></a>      <span class='hs-varid'>needsAValueLambda</span> <span class='hs-keyglyph'>=</span>
<a name="line-13"></a>        <span class='hs-varid'>isUnLiftedType</span> <span class='hs-varid'>res_ty</span>
<a name="line-14"></a>        <span class='hs-varop'>||</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_FunToThunk</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-15"></a>           <span class='hs-comment'>-- see Note [Protecting the last value argument]</span>
<a name="line-16"></a>
<a name="line-17"></a>      <span class='hs-comment'>-- see Note [All One-Shot Arguments of a Worker]</span>
<a name="line-18"></a>      <span class='hs-varid'>newArg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdOneShotInfo</span> <span class='hs-varid'>voidArgId</span> <span class='hs-varid'>all_one_shot</span>
</pre>\end{code}

Note [Protecting the last value argument]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If the user writes (\_ -> E), they might be intentionally disallowing
the sharing of E. Since absence analysis and worker-wrapper are keen
to remove such unused arguments, we add in a void argument to prevent
the function from becoming a thunk.

The user can avoid adding the void argument with the -ffun-to-thunk
flag. However, this can create sharing, which may be bad in two ways. 1) It can
create a space leak. 2) It can prevent inlining *under a lambda*. If w/w
removes the last argument from a function f, then f now looks like a thunk, and
so f can't be inlined *under a lambda*.

Note [All One-Shot Arguments of a Worker]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sometimes, derived join-points are just lambda-lifted thunks, whose
only argument is of the unit type and is never used. This might
interfere with the absence analysis, basing on which results these
never-used arguments are eliminated in the worker. The additional
argument `all_one_shot` of `mkWorkerArgs` is to prevent this.

Example.  Suppose we have
   foo = \p(one-shot) q(one-shot). y + 3
Then we drop the unused args to give
   foo   = \pq. $wfoo void#
   $wfoo = \void(one-shot). y + 3

But suppse foo didn't have all one-shot args:
   foo = \p(not-one-shot) q(one-shot). expensive y + 3
Then we drop the unused args to give
   foo   = \pq. $wfoo void#
   $wfoo = \void(not-one-shot). y + 3

If we made the void-arg one-shot we might inline an expensive
computation for y, which would be terrible!


%************************************************************************
%*                                                                      *
\subsection{Coercion stuff}
%*                                                                      *
%************************************************************************

We really want to "look through" coerces.
Reason: I've seen this situation:

        let f = coerce T (\s -> E)
        in \x -> case x of
                    p -> coerce T' f
                    q -> \s -> E2
                    r -> coerce T' f

If only we w/w'd f, we'd get
        let f = coerce T (\s -> fw s)
            fw = \s -> E
        in ...

Now we'll inline f to get

        let fw = \s -> E
        in \x -> case x of
                    p -> fw
                    q -> \s -> E2
                    r -> fw

Now we'll see that fw has arity 1, and will arity expand
the \x to get what we want.

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>-- mkWWargs just does eta expansion</span>
<a name="line-2"></a><span class='hs-comment'>-- is driven off the function type and arity.</span>
<a name="line-3"></a><span class='hs-comment'>-- It chomps bites off foralls, arrows, newtypes</span>
<a name="line-4"></a><span class='hs-comment'>-- and keeps repeating that until it's satisfied the supplied arity</span>
<a name="line-5"></a>
<a name="line-6"></a><a name="mkWWargs"></a><span class='hs-definition'>mkWWargs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TvSubst</span>             <span class='hs-comment'>-- Freshening substitution to apply to the type</span>
<a name="line-7"></a>                                <span class='hs-comment'>--   See Note [Freshen type variables]</span>
<a name="line-8"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>                <span class='hs-comment'>-- The type of the function</span>
<a name="line-9"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Demand</span><span class='hs-layout'>,</span><span class='hs-conid'>OneShotInfo</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- Demands and one-shot info for value arguments</span>
<a name="line-10"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span>  <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>            <span class='hs-comment'>-- Wrapper args</span>
<a name="line-11"></a>                     <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- Wrapper fn</span>
<a name="line-12"></a>                     <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- Worker fn</span>
<a name="line-13"></a>                     <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>                      <span class='hs-comment'>-- Type of wrapper body</span>
<a name="line-14"></a>
<a name="line-15"></a><span class='hs-definition'>mkWWargs</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>arg_info</span>
<a name="line-16"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>arg_info</span>
<a name="line-17"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty</span><span class='hs-layout'>)</span>
<a name="line-18"></a>
<a name="line-19"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>dmd</span><span class='hs-layout'>,</span><span class='hs-varid'>one_shot</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>arg_info'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>arg_info</span>
<a name="line-20"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-21"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-22"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>arg_ty</span>
<a name="line-23"></a>              <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_wrap_arg</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>arg_ty'</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>one_shot</span>
<a name="line-24"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-25"></a>              <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty'</span> <span class='hs-varid'>arg_info'</span>
<a name="line-26"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span> <span class='hs-conop'>:</span> <span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span>
<a name="line-27"></a>                  <span class='hs-conid'>Lam</span> <span class='hs-varid'>id</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span>
<a name="line-28"></a>                  <span class='hs-varid'>work_fn_args</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varop'>`App`</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-29"></a>                  <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-30"></a>
<a name="line-31"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTy_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-32"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTyVarBndr</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>tv</span>
<a name="line-33"></a>                <span class='hs-comment'>-- This substTyVarBndr clones the type variable when necy</span>
<a name="line-34"></a>                <span class='hs-comment'>-- See Note [Freshen type variables]</span>
<a name="line-35"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-36"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>subst'</span> <span class='hs-varid'>fun_ty'</span> <span class='hs-varid'>arg_info</span>
<a name="line-37"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span>
<a name="line-38"></a>                  <span class='hs-conid'>Lam</span> <span class='hs-varid'>tv'</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span>
<a name="line-39"></a>                  <span class='hs-varid'>work_fn_args</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varop'>`App`</span> <span class='hs-conid'>Type</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-40"></a>                  <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-41"></a>
<a name="line-42"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>rep_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>topNormaliseNewType_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-43"></a>        <span class='hs-comment'>-- The newtype case is for when the function has</span>
<a name="line-44"></a>        <span class='hs-comment'>-- a newtype after the arrow (rare)</span>
<a name="line-45"></a>        <span class='hs-comment'>--</span>
<a name="line-46"></a>        <span class='hs-comment'>-- It's also important when we have a function returning (say) a pair</span>
<a name="line-47"></a>        <span class='hs-comment'>-- wrapped in a  newtype, at least if CPR analysis can look</span>
<a name="line-48"></a>        <span class='hs-comment'>-- through such newtypes, which it probably can since they are</span>
<a name="line-49"></a>        <span class='hs-comment'>-- simply coerces.</span>
<a name="line-50"></a>
<a name="line-51"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-52"></a>            <span class='hs-keyglyph'>&lt;-</span>  <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>rep_ty</span> <span class='hs-varid'>arg_info</span>
<a name="line-53"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span>
<a name="line-54"></a>                  <span class='hs-keyglyph'>\</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_fn_args</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-55"></a>                  <span class='hs-keyglyph'>\</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>work_fn_args</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-56"></a>                  <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-57"></a>
<a name="line-58"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-59"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>)</span>                    <span class='hs-comment'>-- Should not happen: if there is a demand</span>
<a name="line-60"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- then there should be a function arrow</span>
<a name="line-61"></a>
<a name="line-62"></a><a name="applyToVars"></a><span class='hs-definition'>applyToVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-63"></a><span class='hs-definition'>applyToVars</span> <span class='hs-varid'>vars</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarApps</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>vars</span>
<a name="line-64"></a>
<a name="line-65"></a><a name="mk_wrap_arg"></a><span class='hs-definition'>mk_wrap_arg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OneShotInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-66"></a><span class='hs-definition'>mk_wrap_arg</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>one_shot</span>
<a name="line-67"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSysLocal</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"w"</span><span class='hs-layout'>)</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>ty</span>
<a name="line-68"></a>       <span class='hs-varop'>`setIdDemandInfo`</span> <span class='hs-varid'>dmd</span>
<a name="line-69"></a>       <span class='hs-varop'>`setIdOneShotInfo`</span> <span class='hs-varid'>one_shot</span>
</pre>\end{code}

Note [Freshen type variables]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Wen we do a worker/wrapper split, we must not use shadowed names,
else we'll get
   f = /\ a /\a. fw a a
which is obviously wrong.  Type variables can can in principle shadow,
within a type (e.g. forall a. a -> forall a. a->a).  But type
variables *are* mentioned in <blah>, so we must substitute.

That's why we carry the TvSubst through mkWWargs

%************************************************************************
%*                                                                      *
\subsection{Strictness stuff}
%*                                                                      *
%************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="mkWWstr"></a><span class='hs-definition'>mkWWstr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-2"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-3"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>                                <span class='hs-comment'>-- Wrapper args; have their demand info on them</span>
<a name="line-4"></a>                                                <span class='hs-comment'>--  *Includes type variables*</span>
<a name="line-5"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>                        <span class='hs-comment'>-- Is this useful</span>
<a name="line-6"></a>                   <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>                       <span class='hs-comment'>-- Worker args</span>
<a name="line-7"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Wrapper body, lacking the worker call</span>
<a name="line-8"></a>                                                <span class='hs-comment'>-- and without its lambdas</span>
<a name="line-9"></a>                                                <span class='hs-comment'>-- This fn adds the unboxing</span>
<a name="line-10"></a>
<a name="line-11"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- Worker body, lacking the original body of the function,</span>
<a name="line-12"></a>                                                <span class='hs-comment'>-- and lacking its lambdas.</span>
<a name="line-13"></a>                                                <span class='hs-comment'>-- This fn does the reboxing</span>
<a name="line-14"></a><span class='hs-definition'>mkWWstr</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>
<a name="line-15"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-16"></a>
<a name="line-17"></a><span class='hs-definition'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-18"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>useful1</span><span class='hs-layout'>,</span> <span class='hs-varid'>args1</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn1</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr_one</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg</span>
<a name="line-19"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>useful2</span><span class='hs-layout'>,</span> <span class='hs-varid'>args2</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn2</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>args</span>
<a name="line-20"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>useful2</span><span class='hs-layout'>,</span> <span class='hs-varid'>args1</span> <span class='hs-varop'>++</span> <span class='hs-varid'>args2</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn1</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn2</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn1</span> <span class='hs-varop'>.</span> <span class='hs-varid'>work_fn2</span><span class='hs-layout'>)</span>
<a name="line-21"></a>
</pre>\end{code}

Note [Unpacking arguments with product and polymorphic demands]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The argument is unpacked in a case if it has a product type and has a
strict *and* used demand put on it. I.e., arguments, with demands such
as the following ones:

   <S,U(U, L)>
   <S(L,S),U>

will be unpacked, but

   <S,U> or <B,U>

will not, because the pieces aren't used. This is quite important otherwise
we end up unpacking massive tuples passed to the bottoming function. Example:

        f :: ((Int,Int) -> String) -> (Int,Int) -> a
        f g pr = error (g pr)

        main = print (f fst (1, error "no"))

Does 'main' print "error 1" or "error no"?  We don't really want 'f'
to unbox its second argument.  This actually happened in GHC's onwn
source code, in Packages.applyPackageFlag, which ended up un-boxing
the enormous DynFlags tuple, and being strict in the
as-yet-un-filled-in pkgState files.

\begin{code}
<pre><a name="line-1"></a><a name="mkWWstr_one"></a><span class='hs-comment'>----------------------</span>
<a name="line-2"></a><span class='hs-comment'>-- mkWWstr_one wrap_arg = (useful, work_args, wrap_fn, work_fn)</span>
<a name="line-3"></a><span class='hs-comment'>--   *  wrap_fn assumes wrap_arg is in scope,</span>
<a name="line-4"></a><span class='hs-comment'>--        brings into scope work_args (via cases)</span>
<a name="line-5"></a><span class='hs-comment'>--   * work_fn assumes work_args are in scope, a</span>
<a name="line-6"></a><span class='hs-comment'>--        brings into scope wrap_arg (via lets)</span>
<a name="line-7"></a><span class='hs-definition'>mkWWstr_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span>
<a name="line-8"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-9"></a><span class='hs-definition'>mkWWstr_one</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>arg</span>
<a name="line-11"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>  <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-12"></a>
<a name="line-13"></a>  <span class='hs-comment'>-- See Note [Worker-wrapper for bottoming functions]</span>
<a name="line-14"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isAbsDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-15"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>work_fn</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mk_absent_let</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>arg</span>
<a name="line-16"></a>     <span class='hs-comment'>-- Absent case.  We can't always handle absence for arbitrary</span>
<a name="line-17"></a>     <span class='hs-comment'>-- unlifted types, so we need to choose just the cases we can</span>
<a name="line-18"></a>     <span class='hs-comment'>--- (that's what mk_absent_let does)</span>
<a name="line-19"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span><span class='hs-layout'>)</span>
<a name="line-20"></a>
<a name="line-21"></a>  <span class='hs-comment'>-- See Note [Worthy functions for Worker-Wrapper split]</span>
<a name="line-22"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSeqDmd</span> <span class='hs-varid'>dmd</span>  <span class='hs-comment'>-- `seq` demand; evaluate in wrapper in the hope</span>
<a name="line-23"></a>                  <span class='hs-comment'>-- of dropping seqs in the worker</span>
<a name="line-24"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_w_unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>evaldUnfolding</span>
<a name="line-25"></a>          <span class='hs-comment'>-- Tell the worker arg that it's sure to be evaluated</span>
<a name="line-26"></a>          <span class='hs-comment'>-- so that internal seqs can be dropped</span>
<a name="line-27"></a>    <span class='hs-keyword'>in</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_w_unf</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>mk_seq_case</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-28"></a>                <span class='hs-comment'>-- Pass the arg, anyway, even if it is in theory discarded</span>
<a name="line-29"></a>                <span class='hs-comment'>-- Consider</span>
<a name="line-30"></a>                <span class='hs-comment'>--      f x y = x `seq` y</span>
<a name="line-31"></a>                <span class='hs-comment'>-- x gets a (Eval (Poly Abs)) demand, but if we fail to pass it to the worker</span>
<a name="line-32"></a>                <span class='hs-comment'>-- we ABSOLUTELY MUST record that x is evaluated in the wrapper.</span>
<a name="line-33"></a>                <span class='hs-comment'>-- Something like:</span>
<a name="line-34"></a>                <span class='hs-comment'>--      f x y = x `seq` fw y</span>
<a name="line-35"></a>                <span class='hs-comment'>--      fw y = let x{Evald} = error "oops" in (x `seq` y)</span>
<a name="line-36"></a>                <span class='hs-comment'>-- If we don't pin on the "Evald" flag, the seq doesn't disappear, and</span>
<a name="line-37"></a>                <span class='hs-comment'>-- we end up evaluating the absent thunk.</span>
<a name="line-38"></a>                <span class='hs-comment'>-- But the Evald flag is pretty weird, and I worry that it might disappear</span>
<a name="line-39"></a>                <span class='hs-comment'>-- during simplification, so for now I've just nuked this whole case</span>
<a name="line-40"></a>
<a name="line-41"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStrictDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-42"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>cs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitProdDmd_maybe</span> <span class='hs-varid'>dmd</span>
<a name="line-43"></a>      <span class='hs-comment'>-- See Note [Unpacking arguments with product and polymorphic demands]</span>
<a name="line-44"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>data_con</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_con_arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-45"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>deepSplitProductType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-46"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>cs</span> <span class='hs-varop'>`equalLength`</span> <span class='hs-varid'>inst_con_arg_tys</span>
<a name="line-47"></a>      <span class='hs-comment'>-- See Note [mkWWstr and unsafeCoerce]</span>
<a name="line-48"></a>  <span class='hs-keyglyph'>=</span>  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>uniq1</span><span class='hs-conop'>:</span><span class='hs-varid'>uniqs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-49"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span>   <span class='hs-varid'>unpk_args</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>uniqs</span> <span class='hs-varid'>inst_con_arg_tys</span>
<a name="line-50"></a>                <span class='hs-varid'>unpk_args_w_ds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWithEqual</span> <span class='hs-str'>"mkWWstr"</span> <span class='hs-varid'>set_worker_arg_info</span> <span class='hs-varid'>unpk_args</span> <span class='hs-varid'>cs</span>
<a name="line-51"></a>                <span class='hs-varid'>unbox_fn</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkUnpackCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span> <span class='hs-varid'>uniq1</span>
<a name="line-52"></a>                                              <span class='hs-varid'>data_con</span> <span class='hs-varid'>unpk_args</span>
<a name="line-53"></a>                <span class='hs-varid'>rebox_fn</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span>
<a name="line-54"></a>                <span class='hs-varid'>con_app</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>data_con</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>unpk_args</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-55"></a>         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>worker_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>unpk_args_w_ds</span>
<a name="line-56"></a>         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>worker_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>unbox_fn</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rebox_fn</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-57"></a>                           <span class='hs-comment'>-- Don't pass the arg, rebox instead</span>
<a name="line-58"></a>
<a name="line-59"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- Other cases</span>
<a name="line-60"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-61"></a>
<a name="line-62"></a>  <span class='hs-keyword'>where</span>
<a name="line-63"></a>    <span class='hs-varid'>dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>arg</span>
<a name="line-64"></a>    <span class='hs-varid'>one_shot</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idOneShotInfo</span> <span class='hs-varid'>arg</span>
<a name="line-65"></a>        <span class='hs-comment'>-- If the wrapper argument is a one-shot lambda, then</span>
<a name="line-66"></a>        <span class='hs-comment'>-- so should (all) the corresponding worker arguments be</span>
<a name="line-67"></a>        <span class='hs-comment'>-- This bites when we do w/w on a case join point</span>
<a name="line-68"></a>    <span class='hs-varid'>set_worker_arg_info</span> <span class='hs-varid'>worker_arg</span> <span class='hs-varid'>demand</span> 
<a name="line-69"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>worker_arg</span> <span class='hs-varop'>`setIdDemandInfo`</span>  <span class='hs-varid'>demand</span>
<a name="line-70"></a>                   <span class='hs-varop'>`setIdOneShotInfo`</span> <span class='hs-varid'>one_shot</span>
<a name="line-71"></a>
<a name="line-72"></a><a name="nop_fn"></a><span class='hs-comment'>----------------------</span>
<a name="line-73"></a><span class='hs-definition'>nop_fn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-74"></a><span class='hs-definition'>nop_fn</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
</pre>\end{code}

Note [mkWWstr and unsafeCoerce]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
By using unsafeCoerce, it is possible to make the number of demands fail to
match the number of constructor arguments; this happened in Trac #8037.
If so, the worker/wrapper split doesn't work right and we get a Core Lint
bug.  The fix here is simply to decline to do w/w if that happens.

\begin{code}
<pre><a name="line-1"></a><a name="deepSplitProductType_maybe"></a><span class='hs-definition'>deepSplitProductType_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-comment'>-- If    deepSplitProductType_maybe ty = Just (dc, tys, arg_tys, co)</span>
<a name="line-3"></a><span class='hs-comment'>-- then  dc @ tys (args::arg_tys) :: rep_ty</span>
<a name="line-4"></a><span class='hs-comment'>--       co :: ty ~ rep_ty</span>
<a name="line-5"></a><span class='hs-definition'>deepSplitProductType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-6"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-7"></a>                    <span class='hs-varop'>`orElse`</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkReflCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-8"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-9"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isDataProductTyCon_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>dataConInstArgTys</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-11"></a><span class='hs-definition'>deepSplitProductType_maybe</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-12"></a>
<a name="line-13"></a><a name="deepSplitCprType_maybe"></a><span class='hs-definition'>deepSplitCprType_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConTag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-14"></a><span class='hs-comment'>-- If    deepSplitCprType_maybe n ty = Just (dc, tys, arg_tys, co)</span>
<a name="line-15"></a><span class='hs-comment'>-- then  dc @ tys (args::arg_tys) :: rep_ty</span>
<a name="line-16"></a><span class='hs-comment'>--       co :: ty ~ rep_ty</span>
<a name="line-17"></a><span class='hs-definition'>deepSplitCprType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>con_tag</span> <span class='hs-varid'>ty</span>
<a name="line-18"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-19"></a>                    <span class='hs-varop'>`orElse`</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkReflCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-20"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-21"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isDataTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-22"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>cons</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>tc</span>
<a name="line-23"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>cons</span> <span class='hs-varop'>`lengthAtLeast`</span> <span class='hs-varid'>con_tag</span> <span class='hs-comment'>-- This might not be true if we import the</span>
<a name="line-24"></a>                                 <span class='hs-comment'>-- type constructor via a .hs-bool file (#8743)</span>
<a name="line-25"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>con</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cons</span> <span class='hs-varop'>!!</span> <span class='hs-layout'>(</span><span class='hs-varid'>con_tag</span> <span class='hs-comment'>-</span> <span class='hs-varid'>fIRST_TAG</span><span class='hs-layout'>)</span>
<a name="line-26"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>dataConInstArgTys</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-27"></a><span class='hs-definition'>deepSplitCprType_maybe</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
\subsection{CPR stuff}
%*                                                                      *
%************************************************************************


@mkWWcpr@ takes the worker/wrapper pair produced from the strictness
info and adds in the CPR transformation.  The worker returns an
unboxed tuple containing non-CPR components.  The wrapper takes this
tuple and re-produces the correct structured output.

The non-CPR results appear ordered in the unboxed tuple as if by a
left-to-right traversal of the result structure.


\begin{code}
<pre><a name="line-1"></a><a name="mkWWcpr"></a><span class='hs-definition'>mkWWcpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-2"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>                              <span class='hs-comment'>-- function body type</span>
<a name="line-3"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdResult</span>                         <span class='hs-comment'>-- CPR analysis results</span>
<a name="line-4"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>                     <span class='hs-comment'>-- Is w/w'ing useful?</span>
<a name="line-5"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- New wrapper</span>
<a name="line-6"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- New worker</span>
<a name="line-7"></a>                   <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>                     <span class='hs-comment'>-- Type of worker's body</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-definition'>mkWWcpr</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>res</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>returnsCPR_maybe</span> <span class='hs-varid'>res</span> <span class='hs-keyword'>of</span>
<a name="line-11"></a>       <span class='hs-conid'>Nothing</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>body_ty</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- No CPR info</span>
<a name="line-12"></a>       <span class='hs-conid'>Just</span> <span class='hs-varid'>con_tag</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>stuff</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>deepSplitCprType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>con_tag</span> <span class='hs-varid'>body_ty</span>
<a name="line-13"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkWWcpr_help</span> <span class='hs-varid'>stuff</span>
<a name="line-14"></a>                    <span class='hs-keyglyph'>|</span>  <span class='hs-varid'>otherwise</span>
<a name="line-15"></a>                       <span class='hs-comment'>-- See Note [non-algebraic or open body type warning]</span>
<a name="line-16"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"mkWWcpr: non-algebraic or open body type"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>body_ty</span> <span class='hs-layout'>)</span>
<a name="line-17"></a>                       <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>body_ty</span><span class='hs-layout'>)</span>
<a name="line-18"></a>
<a name="line-19"></a><a name="mkWWcpr_help"></a><span class='hs-definition'>mkWWcpr_help</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-20"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>
<a name="line-21"></a>
<a name="line-22"></a><span class='hs-definition'>mkWWcpr_help</span> <span class='hs-layout'>(</span><span class='hs-varid'>data_con</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_ty1</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>arg_tys</span>
<a name="line-24"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isUnLiftedType</span> <span class='hs-varid'>arg_ty1</span>
<a name="line-25"></a>        <span class='hs-comment'>-- Special case when there is a single result of unlifted type</span>
<a name="line-26"></a>        <span class='hs-comment'>--</span>
<a name="line-27"></a>        <span class='hs-comment'>-- Wrapper:     case (..call worker..) of x -&gt; C x</span>
<a name="line-28"></a>        <span class='hs-comment'>-- Worker:      case (   ..body..    ) of C x -&gt; x</span>
<a name="line-29"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_uniq</span> <span class='hs-conop'>:</span> <span class='hs-varid'>arg_uniq</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-30"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>arg_uniq</span>  <span class='hs-varid'>arg_ty1</span>
<a name="line-31"></a>             <span class='hs-varid'>con_app</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>data_con</span> <span class='hs-varid'>inst_tys</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-32"></a>
<a name="line-33"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-conid'>True</span>
<a name="line-34"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>wkr_call</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Case</span> <span class='hs-varid'>wkr_call</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DEFAULT</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-35"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>body</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkUnpackCase</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co</span> <span class='hs-varid'>work_uniq</span> <span class='hs-varid'>data_con</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-36"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>arg_ty1</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-37"></a>
<a name="line-38"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- The general case</span>
<a name="line-39"></a>        <span class='hs-comment'>-- Wrapper: case (..call worker..) of (# a, b #) -&gt; C a b</span>
<a name="line-40"></a>        <span class='hs-comment'>-- Worker:  case (   ...body...  ) of C a b -&gt; (# a, b #)</span>
<a name="line-41"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_uniq</span> <span class='hs-conop'>:</span> <span class='hs-varid'>uniqs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-42"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_wild</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>uniqs</span> <span class='hs-layout'>(</span><span class='hs-varid'>ubx_tup_ty</span> <span class='hs-conop'>:</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span>
<a name="line-43"></a>             <span class='hs-varid'>ubx_tup_con</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tupleCon</span> <span class='hs-conid'>UnboxedTuple</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span>
<a name="line-44"></a>             <span class='hs-varid'>ubx_tup_ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprType</span> <span class='hs-varid'>ubx_tup_app</span>
<a name="line-45"></a>             <span class='hs-varid'>ubx_tup_app</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>ubx_tup_con</span> <span class='hs-varid'>arg_tys</span> <span class='hs-varid'>args</span>
<a name="line-46"></a>             <span class='hs-varid'>con_app</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>data_con</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>args</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-47"></a>
<a name="line-48"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span>
<a name="line-49"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>wkr_call</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Case</span> <span class='hs-varid'>wkr_call</span> <span class='hs-varid'>wrap_wild</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>ubx_tup_con</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-50"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>body</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkUnpackCase</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co</span> <span class='hs-varid'>work_uniq</span> <span class='hs-varid'>data_con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>ubx_tup_app</span>
<a name="line-51"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>ubx_tup_ty</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-52"></a>
<a name="line-53"></a><a name="mkUnpackCase"></a><span class='hs-definition'>mkUnpackCase</span> <span class='hs-keyglyph'>::</span>  <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-54"></a><span class='hs-comment'>-- (mkUnpackCase e co uniq Con args body)</span>
<a name="line-55"></a><span class='hs-comment'>--      returns</span>
<a name="line-56"></a><span class='hs-comment'>-- case e |&gt; co of bndr { Con args -&gt; body }</span>
<a name="line-57"></a>
<a name="line-58"></a><span class='hs-definition'>mkUnpackCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>body</span>   <span class='hs-comment'>-- See Note [Profiling and unpacking]</span>
<a name="line-59"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkUnpackCase</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-60"></a><span class='hs-definition'>mkUnpackCase</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>co</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>boxing_con</span> <span class='hs-varid'>unpk_args</span> <span class='hs-varid'>body</span>
<a name="line-61"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Case</span> <span class='hs-varid'>casted_scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-62"></a>         <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>boxing_con</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpk_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-63"></a>  <span class='hs-keyword'>where</span>
<a name="line-64"></a>    <span class='hs-varid'>casted_scrut</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scrut</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>co</span>
<a name="line-65"></a>    <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>uniq</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>casted_scrut</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [non-algebraic or open body type warning]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are a few cases where the W/W transformation is told that something
returns a constructor, but the type at hand doesn't really match this. One
real-world example involves unsafeCoerce:
  foo = IO a
  foo = unsafeCoere c_exit
  foreign import ccall "c_exit" c_exit :: IO ()
Here CPR will tell you that `foo` returns a () constructor for sure, but trying
to create a worker/wrapper for type `a` obviously fails.
(This was a real example until ee8e792  in libraries/base.)

It does not seem feasible to avoid all such cases already in the analyser (and
after all, the analysis is not really wrong), so we simply do nothing here in
mkWWcpr. But we still want to emit warning with -DDEBUG, to hopefully catch
other cases where something went avoidably wrong.


Note [Profiling and unpacking]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If the original function looked like
        f = \ x -> {-# SCC "foo" #-} E

then we want the CPR'd worker to look like
        \ x -> {-# SCC "foo" #-} (case E of I# x -> x)
and definitely not
        \ x -> case ({-# SCC "foo" #-} E) of I# x -> x)

This transform doesn't move work or allocation
from one cost centre to another.

Later [SDM]: presumably this is because we want the simplifier to
eliminate the case, and the scc would get in the way?  I'm ok with
including the case itself in the cost centre, since it is morally
part of the function (post transformation) anyway.


%************************************************************************
%*                                                                      *
\subsection{Utilities}
%*                                                                      *
%************************************************************************

Note [Absent errors]
~~~~~~~~~~~~~~~~~~~~
We make a new binding for Ids that are marked absent, thus
   let x = absentError "x :: Int"
The idea is that this binding will never be used; but if it
buggily is used we'll get a runtime error message.

Coping with absence for *unlifted* types is important; see, for
example, Trac #4306.  For these we find a suitable literal,
using Literal.absentLiteralOf.  We don't have literals for
every primitive type, so the function is partial.

    [I did try the experiment of using an error thunk for unlifted
    things too, relying on the simplifier to drop it as dead code,
    by making absentError
      (a) *not* be a bottoming Id,
      (b) be "ok for speculation"
    But that relies on the simplifier finding that it really
    is dead code, which is fragile, and indeed failed when
    profiling is on, which disables various optimisations.  So
    using a literal will do.]

\begin{code}
<pre><a name="line-1"></a><a name="mk_absent_let"></a><span class='hs-definition'>mk_absent_let</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-definition'>mk_absent_let</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>arg</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isUnLiftedType</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-4"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>abs_rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-5"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConAppTyCon_maybe</span> <span class='hs-varid'>arg_ty</span>
<a name="line-6"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>lit</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>absentLiteralOf</span> <span class='hs-varid'>tc</span>
<a name="line-7"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>voidPrimTy</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>voidPrimId</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-11"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"No absent value for"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_ty</span> <span class='hs-layout'>)</span>
<a name="line-12"></a>    <span class='hs-conid'>Nothing</span>
<a name="line-13"></a>  <span class='hs-keyword'>where</span>
<a name="line-14"></a>    <span class='hs-varid'>arg_ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>arg</span>
<a name="line-15"></a>    <span class='hs-varid'>abs_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkRuntimeErrorApp</span> <span class='hs-varid'>aBSENT_ERROR_ID</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>msg</span>
<a name="line-16"></a>    <span class='hs-varid'>msg</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>showSDocDebug</span> <span class='hs-varid'>dflags</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-17"></a>
<a name="line-18"></a><a name="mk_seq_case"></a><span class='hs-definition'>mk_seq_case</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-19"></a><span class='hs-definition'>mk_seq_case</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>sanitiseCaseBndr</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DEFAULT</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-20"></a>
<a name="line-21"></a><a name="sanitiseCaseBndr"></a><span class='hs-definition'>sanitiseCaseBndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-22"></a><span class='hs-comment'>-- The argument we are scrutinising has the right type to be</span>
<a name="line-23"></a><span class='hs-comment'>-- a case binder, so it's convenient to re-use it for that purpose.</span>
<a name="line-24"></a><span class='hs-comment'>-- But we *must* throw away all its IdInfo.  In particular, the argument</span>
<a name="line-25"></a><span class='hs-comment'>-- will have demand info on it, and that demand info may be incorrect for</span>
<a name="line-26"></a><span class='hs-comment'>-- the case binder.  e.g.       case ww_arg of ww_arg { I# x -&gt; ... }</span>
<a name="line-27"></a><span class='hs-comment'>-- Quite likely ww_arg isn't used in '...'.  The case may get discarded</span>
<a name="line-28"></a><span class='hs-comment'>-- if the case binder says "I'm demanded".  This happened in a situation</span>
<a name="line-29"></a><span class='hs-comment'>-- like         (x+y) `seq` ....</span>
<a name="line-30"></a><span class='hs-definition'>sanitiseCaseBndr</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span> <span class='hs-varop'>`setIdInfo`</span> <span class='hs-varid'>vanillaIdInfo</span>
<a name="line-31"></a>
<a name="line-32"></a><a name="mk_ww_local"></a><span class='hs-definition'>mk_ww_local</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-33"></a><span class='hs-definition'>mk_ww_local</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSysLocal</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"ww"</span><span class='hs-layout'>)</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>ty</span>
</pre>\end{code}
</body>
</html>
