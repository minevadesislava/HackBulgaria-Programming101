<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcTyDecls.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
%
% (c) The University of Glasgow 2006
% (c) The GRASP/AQUA Project, Glasgow University, 1992-1999
%

Analysis functions over data types.  Specficially, detecting recursive types.

This stuff is only used for source-code decls; it's recorded in interface
files for imported data types.

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>{-# OPTIONS -fno-warn-tabs #-}</span>
<a name="line-2"></a><span class='hs-comment'>-- The above warning supression flag is a temporary kludge.</span>
<a name="line-3"></a><span class='hs-comment'>-- While working on this module you are encouraged to remove it and</span>
<a name="line-4"></a><span class='hs-comment'>-- detab the module (please do the detabbing in a separate patch). See</span>
<a name="line-5"></a><span class='hs-comment'>--     <a href="http://ghc.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces">http://ghc.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces</a></span>
<a name="line-6"></a><span class='hs-comment'>-- for details</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcTyDecls</span><span class='hs-layout'>(</span>
<a name="line-9"></a>        <span class='hs-varid'>calcRecFlags</span><span class='hs-layout'>,</span> <span class='hs-conid'>RecTyInfo</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> 
<a name="line-10"></a>        <span class='hs-varid'>calcSynCycles</span><span class='hs-layout'>,</span> <span class='hs-varid'>calcClassCycles</span><span class='hs-layout'>,</span>
<a name="line-11"></a>        <span class='hs-conid'>RoleAnnots</span><span class='hs-layout'>,</span> <span class='hs-varid'>extractRoleAnnots</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyRoleAnnots</span><span class='hs-layout'>,</span> <span class='hs-varid'>lookupRoleAnnots</span>
<a name="line-12"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-15"></a>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TypeRep</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>HsSyn</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Kind</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>HscTypes</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DataCon</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>NameEnv</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>NameSet</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Coercion</span> <span class='hs-layout'>(</span> <span class='hs-varid'>ltRole</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Avail</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Digraph</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>SrcLoc</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>UniqSet</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Maybes</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-conid'>Applicative</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
        Cycles in class and type synonym declarations
%*                                                                      *
%************************************************************************

Checking for class-decl loops is easy, because we don't allow class decls
in interface files.

We allow type synonyms in hi-boot files, but we *trust* hi-boot files,
so we don't check for loops that involve them.  So we only look for synonym
loops in the module being compiled.

We check for type synonym and class cycles on the *source* code.
Main reasons:

  a) Otherwise we'd need a special function to extract type-synonym tycons
     from a type, whereas we already have the free vars pinned on the decl

  b) If we checked for type synonym loops after building the TyCon, we
        can't do a hoistForAllTys on the type synonym rhs, (else we fall into
        a black hole) which seems unclean.  Apart from anything else, it'd mean
        that a type-synonym rhs could have for-alls to the right of an arrow,
        which means adding new cases to the validity checker

        Indeed, in general, checking for cycles beforehand means we need to
        be less careful about black holes through synonym cycles.

The main disadvantage is that a cycle that goes via a type synonym in an
.hi-boot file can lead the compiler into a loop, because it assumes that cycles
only occur entirely within the source code of the module being compiled.
But hi-boot files are trusted anyway, so this isn't much worse than (say)
a kind error.

[  NOTE ----------------------------------------------
If we reverse this decision, this comment came from tcTyDecl1, and should
 go back there
        -- dsHsType, not tcHsKindedType, to avoid a loop.  tcHsKindedType does hoisting,
        -- which requires looking through synonyms... and therefore goes into a loop
        -- on (erroneously) recursive synonyms.
        -- Solution: do not hoist synonyms, because they'll be hoisted soon enough
        --           when they are substituted

We'd also need to add back in this definition

synTyConsOfType :: Type -> [TyCon]
-- Does not look through type synonyms at all
-- Return a list of synonym tycons
synTyConsOfType ty
  = nameEnvElts (go ty)
  where
     go :: Type -> NameEnv TyCon  -- The NameEnv does duplicate elim
     go (TyVarTy v)               = emptyNameEnv
     go (TyConApp tc tys)         = go_tc tc tys
     go (AppTy a b)               = go a `plusNameEnv` go b
     go (FunTy a b)               = go a `plusNameEnv` go b
     go (ForAllTy _ ty)           = go ty

     go_tc tc tys | isSynTyCon tc = extendNameEnv (go_s tys) (tyConName tc) tc
                  | otherwise     = go_s tys
     go_s tys = foldr (plusNameEnv . go) emptyNameEnv tys
---------------------------------------- END NOTE ]

\begin{code}
<pre><a name="line-1"></a><a name="mkSynEdges"></a><span class='hs-definition'>mkSynEdges</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LTyClDecl</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>LTyClDecl</span> <span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-2"></a><span class='hs-definition'>mkSynEdges</span> <span class='hs-varid'>syn_decls</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>ldecl</span><span class='hs-layout'>,</span> <span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>nameSetToList</span> <span class='hs-varid'>fvs</span><span class='hs-layout'>)</span>
<a name="line-3"></a>                       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ldecl</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>SynDecl</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tcdLName</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>L</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>name</span>
<a name="line-4"></a>                                            <span class='hs-layout'>,</span> <span class='hs-varid'>tcdFVs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>syn_decls</span> <span class='hs-keyglyph'>]</span>
<a name="line-5"></a>
<a name="line-6"></a><a name="calcSynCycles"></a><span class='hs-definition'>calcSynCycles</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LTyClDecl</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>SCC</span> <span class='hs-layout'>(</span><span class='hs-conid'>LTyClDecl</span> <span class='hs-conid'>Name</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-7"></a><span class='hs-definition'>calcSynCycles</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stronglyConnCompFromEdgedVertices</span> <span class='hs-varop'>.</span> <span class='hs-varid'>mkSynEdges</span>
</pre>\end{code}

Note [Superclass cycle check]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We can't allow cycles via superclasses because it would result in the
type checker looping when it canonicalises a class constraint (superclasses
are added during canonicalisation).  More precisely, given a constraint
    C ty1 .. tyn
we want to instantiate all of C's superclasses, transitively, and
that set must be finite.  So if
     class (D b, E b a) => C a b
then when we encounter the constraint
     C ty1 ty2
we'll instantiate the superclasses
     (D ty2, E ty2 ty1)
and then *their* superclasses, and so on.  This set must be finite!

It is OK for superclasses to be type synonyms for other classes, so
must "look through" type synonyms. Eg
     type X a = C [a]
     class X a => C a	-- No!  Recursive superclass!

We want definitions such as:

  class C cls a where cls a => a -> a
  class C D a => D a where

to be accepted, even though a naive acyclicity check would reject the
program as having a cycle between D and its superclass.  Why? Because
when we instantiate 
     D ty1
we get the superclas
     C D ty1
and C has no superclasses, so we have terminated with a finite set.

More precisely, the rule is this: the superclasses sup_C of a class C
are rejected iff:

  C \elem expand(sup_C)

Where expand is defined as follows:

(1)  expand(a ty1 ... tyN) = expand(ty1) \union ... \union expand(tyN)

(2)  expand(D ty1 ... tyN) = {D} 
                             \union sup_D[ty1/x1, ..., tyP/xP] 
                             \union expand(ty(P+1)) ... \union expand(tyN)
           where (D x1 ... xM) is a class, P = min(M,N)

(3)  expand(T ty1 ... tyN) = expand(ty1) \union ... \union expand(tyN)
        where T is not a class

Eqn (1) is conservative; when there's a type variable at the head,
look in all the argument types.  Eqn (2) expands superclasses; the
third component of the union is like Eqn (1).  Eqn (3) happens mainly
when the context is a (constraint) tuple, such as (Eq a, Show a).

Furthermore, expand always looks through type synonyms.

\begin{code}
<pre><a name="line-1"></a><a name="calcClassCycles"></a><span class='hs-definition'>calcClassCycles</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCon</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<a name="line-2"></a><span class='hs-definition'>calcClassCycles</span> <span class='hs-varid'>cls</span> 
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nubBy</span> <span class='hs-varid'>eqAsCycle</span> <span class='hs-varop'>$</span> 
<a name="line-4"></a>    <span class='hs-varid'>expandTheta</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitUniqSet</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>classSCTheta</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>
<a name="line-5"></a>  <span class='hs-keyword'>where</span>
<a name="line-6"></a>    <span class='hs-comment'>-- The last TyCon in the cycle is always the same as the first</span>
<a name="line-7"></a>    <span class='hs-varid'>eqAsCycle</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>xs</span> <span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>cycles</span> <span class='hs-layout'>(</span><span class='hs-varid'>tail</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-8"></a>    <span class='hs-varid'>cycles</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>take</span> <span class='hs-varid'>n</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tails</span> <span class='hs-varop'>.</span> <span class='hs-varid'>cycle</span> <span class='hs-varop'>$</span> <span class='hs-varid'>xs</span>
<a name="line-9"></a>      <span class='hs-keyword'>where</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>xs</span>
<a name="line-10"></a>
<a name="line-11"></a>    <span class='hs-comment'>-- No more superclasses to expand ==&gt; no problems with cycles</span>
<a name="line-12"></a>    <span class='hs-comment'>-- See Note [Superclass cycle check]</span>
<a name="line-13"></a>    <span class='hs-varid'>expandTheta</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UniqSet</span> <span class='hs-conid'>Class</span> <span class='hs-comment'>-- Path of Classes to here in set form</span>
<a name="line-14"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCon</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Path to here</span>
<a name="line-15"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span>     <span class='hs-comment'>-- Superclass work list</span>
<a name="line-16"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCon</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- Input error paths</span>
<a name="line-17"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCon</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- Final error paths</span>
<a name="line-18"></a>    <span class='hs-varid'>expandTheta</span> <span class='hs-keyword'>_</span>    <span class='hs-keyword'>_</span>    <span class='hs-conid'>[]</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
<a name="line-19"></a>    <span class='hs-varid'>expandTheta</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-layout'>(</span><span class='hs-varid'>pred</span><span class='hs-conop'>:</span><span class='hs-varid'>theta</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-varid'>pred</span> <span class='hs-varop'>.</span> <span class='hs-varid'>expandTheta</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-varid'>theta</span>
<a name="line-20"></a>
<a name="line-21"></a>    <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-22"></a>      <span class='hs-comment'>-- Expand unsaturated classes to their superclass theta if they are yet unseen.</span>
<a name="line-23"></a>      <span class='hs-comment'>-- If they have already been seen then we have detected an error!</span>
<a name="line-24"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConClass_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-25"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>remainder</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>papp</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyVars</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-26"></a>            <span class='hs-varid'>rest_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>either</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>id</span> <span class='hs-varid'>remainder</span>
<a name="line-27"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`elementOfUniqSet`</span> <span class='hs-varid'>seen</span>
<a name="line-28"></a>         <span class='hs-keyword'>then</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span><span class='hs-conop'>:</span><span class='hs-varid'>path</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> 
<a name="line-29"></a>              <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-30"></a>         <span class='hs-keyword'>else</span> <span class='hs-varid'>expandTheta</span> <span class='hs-layout'>(</span><span class='hs-varid'>addOneToUniqSet</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-conop'>:</span><span class='hs-varid'>path</span><span class='hs-layout'>)</span> 
<a name="line-31"></a>                          <span class='hs-layout'>(</span><span class='hs-varid'>substTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTopTvSubst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>classSCTheta</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-32"></a>              <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest_tys</span>
<a name="line-33"></a>
<a name="line-34"></a>      <span class='hs-comment'>-- For synonyms, try to expand them: some arguments might be</span>
<a name="line-35"></a>      <span class='hs-comment'>-- phantoms, after all. We can expand with impunity because at</span>
<a name="line-36"></a>      <span class='hs-comment'>-- this point the type synonym cycle check has already happened.</span>
<a name="line-37"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>synTyConDefn_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-38"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>remainder</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>papp</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>tys</span>
<a name="line-39"></a>            <span class='hs-varid'>rest_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>either</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>id</span> <span class='hs-varid'>remainder</span>
<a name="line-40"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-conop'>:</span><span class='hs-varid'>path</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTopTvSubst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> 
<a name="line-41"></a>        <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest_tys</span>
<a name="line-42"></a>
<a name="line-43"></a>      <span class='hs-comment'>-- For non-class, non-synonyms, just check the arguments</span>
<a name="line-44"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-45"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flip</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-46"></a>
<a name="line-47"></a>    <span class='hs-varid'>expandType</span> <span class='hs-keyword'>_</span>    <span class='hs-keyword'>_</span>    <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
<a name="line-48"></a>    <span class='hs-varid'>expandType</span> <span class='hs-keyword'>_</span>    <span class='hs-keyword'>_</span>    <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
<a name="line-49"></a>    <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>.</span> <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-varid'>t2</span>
<a name="line-50"></a>    <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>.</span> <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-varid'>t2</span>
<a name="line-51"></a>    <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-sel'>_tv</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expandType</span> <span class='hs-varid'>seen</span> <span class='hs-varid'>path</span> <span class='hs-varid'>t</span>
<a name="line-52"></a>
<a name="line-53"></a>    <span class='hs-varid'>papp</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>TyVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-54"></a>    <span class='hs-varid'>papp</span> <span class='hs-conid'>[]</span>       <span class='hs-varid'>tys</span>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-55"></a>    <span class='hs-varid'>papp</span> <span class='hs-varid'>tvs</span>      <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span>
<a name="line-56"></a>    <span class='hs-varid'>papp</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span><span class='hs-conop'>:</span><span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-conop'>:</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>remainder</span><span class='hs-layout'>)</span>
<a name="line-57"></a>      <span class='hs-keyword'>where</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>remainder</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>papp</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>tys</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
        Deciding which type constructors are recursive
%*                                                                      *
%************************************************************************

Identification of recursive TyCons
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The knot-tying parameters: @rec_details_list@ is an alist mapping @Name@s to
@TyThing@s.

Identifying a TyCon as recursive serves two purposes

1.  Avoid infinite types.  Non-recursive newtypes are treated as
"transparent", like type synonyms, after the type checker.  If we did
this for all newtypes, we'd get infinite types.  So we figure out for
each newtype whether it is "recursive", and add a coercion if so.  In
effect, we are trying to "cut the loops" by identifying a loop-breaker.

2.  Avoid infinite unboxing.  This is nothing to do with newtypes.
Suppose we have
        data T = MkT Int T
        f (MkT x t) = f t
Well, this function diverges, but we don't want the strictness analyser
to diverge.  But the strictness analyser will diverge because it looks
deeper and deeper into the structure of T.   (I believe there are
examples where the function does something sane, and the strictness
analyser still diverges, but I can't see one now.)

Now, concerning (1), the FC2 branch currently adds a coercion for ALL
newtypes.  I did this as an experiment, to try to expose cases in which
the coercions got in the way of optimisations.  If it turns out that we
can indeed always use a coercion, then we don't risk recursive types,
and don't need to figure out what the loop breakers are.

For newtype *families* though, we will always have a coercion, so they
are always loop breakers!  So you can easily adjust the current
algorithm by simply treating all newtype families as loop breakers (and
indeed type families).  I think.



For newtypes, we label some as "recursive" such that

    INVARIANT: there is no cycle of non-recursive newtypes

In any loop, only one newtype need be marked as recursive; it is
a "loop breaker".  Labelling more than necessary as recursive is OK,
provided the invariant is maintained.

A newtype M.T is defined to be "recursive" iff
        (a) it is declared in an hi-boot file (see RdrHsSyn.hsIfaceDecl)
        (b) it is declared in a source file, but that source file has a
            companion hi-boot file which declares the type
   or   (c) one can get from T's rhs to T via type
            synonyms, or non-recursive newtypes *in M*
             e.g.  newtype T = MkT (T -> Int)

(a) is conservative; declarations in hi-boot files are always
        made loop breakers. That's why in (b) we can restrict attention
        to tycons in M, because any loops through newtypes outside M
        will be broken by those newtypes
(b) ensures that a newtype is not treated as a loop breaker in one place
and later as a non-loop-breaker.  This matters in GHCi particularly, when
a newtype T might be embedded in many types in the environment, and then
T's source module is compiled.  We don't want T's recursiveness to change.

The "recursive" flag for algebraic data types is irrelevant (never consulted)
for types with more than one constructor.


An algebraic data type M.T is "recursive" iff
        it has just one constructor, and
        (a) it is declared in an hi-boot file (see RdrHsSyn.hsIfaceDecl)
        (b) it is declared in a source file, but that source file has a
            companion hi-boot file which declares the type
 or     (c) one can get from its arg types to T via type synonyms,
            or by non-recursive newtypes or non-recursive product types in M
             e.g.  data T = MkT (T -> Int) Bool
Just like newtype in fact

A type synonym is recursive if one can get from its
right hand side back to it via type synonyms.  (This is
reported as an error.)

A class is recursive if one can get from its superclasses
back to it.  (This is an error too.)

Hi-boot types
~~~~~~~~~~~~~
A data type read from an hi-boot file will have an AbstractTyCon as its AlgTyConRhs
and will respond True to isAbstractTyCon. The idea is that we treat these as if one
could get from these types to anywhere.  So when we see

        module Baz where
        import {-# SOURCE #-} Foo( T )
        newtype S = MkS T

then we mark S as recursive, just in case. What that means is that if we see

        import Baz( S )
        newtype R = MkR S

then we don't need to look inside S to compute R's recursiveness.  Since S is imported
(not from an hi-boot file), one cannot get from R back to S except via an hi-boot file,
and that means that some data type will be marked recursive along the way.  So R is
unconditionly non-recursive (i.e. there'll be a loop breaker elsewhere if necessary)

This in turn means that we grovel through fewer interface files when computing
recursiveness, because we need only look at the type decls in the module being
compiled, plus the outer structure of directly-mentioned types.

\begin{code}
<pre><a name="line-1"></a><a name="RecTyInfo"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>RecTyInfo</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RTI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rti_promotable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-2"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>rti_roles</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>
<a name="line-3"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>rti_is_rec</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RecFlag</span> <span class='hs-layout'>}</span>
<a name="line-4"></a>
<a name="line-5"></a><a name="calcRecFlags"></a><span class='hs-definition'>calcRecFlags</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ModDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>  <span class='hs-comment'>-- hs-boot file?</span>
<a name="line-6"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleAnnots</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyThing</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RecTyInfo</span>
<a name="line-7"></a><span class='hs-comment'>-- The 'boot_names' are the things declared in M.hi-boot, if M is the current module.</span>
<a name="line-8"></a><span class='hs-comment'>-- Any type constructors in boot_names are automatically considered loop breakers</span>
<a name="line-9"></a><span class='hs-definition'>calcRecFlags</span> <span class='hs-varid'>boot_details</span> <span class='hs-varid'>is_boot</span> <span class='hs-varid'>mrole_env</span> <span class='hs-varid'>tyclss</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RTI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rti_promotable</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_promotable</span>
<a name="line-11"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>rti_roles</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>roles</span>
<a name="line-12"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>rti_is_rec</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_rec</span> <span class='hs-layout'>}</span>
<a name="line-13"></a>  <span class='hs-keyword'>where</span>
<a name="line-14"></a>    <span class='hs-varid'>rec_tycon_names</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNameSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>tyConName</span> <span class='hs-varid'>all_tycons</span><span class='hs-layout'>)</span>
<a name="line-15"></a>    <span class='hs-varid'>all_tycons</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapCatMaybes</span> <span class='hs-varid'>getTyCon</span> <span class='hs-varid'>tyclss</span>
<a name="line-16"></a>                   <span class='hs-comment'>-- Recursion of newtypes/data types can happen via</span>
<a name="line-17"></a>                   <span class='hs-comment'>-- the class TyCon, so tyclss includes the class tycons</span>
<a name="line-18"></a>
<a name="line-19"></a>    <span class='hs-varid'>is_promotable</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varid'>isPromotableTyCon</span> <span class='hs-varid'>rec_tycon_names</span><span class='hs-layout'>)</span> <span class='hs-varid'>all_tycons</span>
<a name="line-20"></a>
<a name="line-21"></a>    <span class='hs-varid'>roles</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inferRoles</span> <span class='hs-varid'>is_boot</span> <span class='hs-varid'>mrole_env</span> <span class='hs-varid'>all_tycons</span>
<a name="line-22"></a>
<a name="line-23"></a>    <span class='hs-comment'>----------------- Recursion calculation ----------------</span>
<a name="line-24"></a>    <span class='hs-varid'>is_rec</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>`elemNameSet`</span> <span class='hs-varid'>rec_names</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Recursive</span>
<a name="line-25"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRecursive</span>
<a name="line-26"></a>
<a name="line-27"></a>    <span class='hs-varid'>boot_name_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>availsToNameSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>md_exports</span> <span class='hs-varid'>boot_details</span><span class='hs-layout'>)</span>
<a name="line-28"></a>    <span class='hs-varid'>rec_names</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>boot_name_set</span>     <span class='hs-varop'>`unionNameSets`</span>
<a name="line-29"></a>                <span class='hs-varid'>nt_loop_breakers</span>  <span class='hs-varop'>`unionNameSets`</span>
<a name="line-30"></a>                <span class='hs-varid'>prod_loop_breakers</span>
<a name="line-31"></a>
<a name="line-32"></a>
<a name="line-33"></a>        <span class='hs-comment'>-------------------------------------------------</span>
<a name="line-34"></a>        <span class='hs-comment'>--                      NOTE</span>
<a name="line-35"></a>        <span class='hs-comment'>-- These edge-construction loops rely on</span>
<a name="line-36"></a>        <span class='hs-comment'>-- every loop going via tyclss, the types and classes</span>
<a name="line-37"></a>        <span class='hs-comment'>-- in the module being compiled.  Stuff in interface</span>
<a name="line-38"></a>        <span class='hs-comment'>-- files should be correctly marked.  If not (e.g. a</span>
<a name="line-39"></a>        <span class='hs-comment'>-- type synonym in a hi-boot file) we can get an infinite</span>
<a name="line-40"></a>        <span class='hs-comment'>-- loop.  We could program round this, but it'd make the code</span>
<a name="line-41"></a>        <span class='hs-comment'>-- rather less nice, so I'm not going to do that yet.</span>
<a name="line-42"></a>
<a name="line-43"></a>    <span class='hs-varid'>single_con_tycons</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>all_tycons</span>
<a name="line-44"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>`elemNameSet`</span> <span class='hs-varid'>boot_name_set</span><span class='hs-layout'>)</span>
<a name="line-45"></a>                                 <span class='hs-comment'>-- Remove the boot_name_set because they are </span>
<a name="line-46"></a>                                 <span class='hs-comment'>-- going to be loop breakers regardless.</span>
<a name="line-47"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>isSingleton</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-48"></a>        <span class='hs-comment'>-- Both newtypes and data types, with exactly one data constructor</span>
<a name="line-49"></a>
<a name="line-50"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>new_tycons</span><span class='hs-layout'>,</span> <span class='hs-varid'>prod_tycons</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partition</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-varid'>single_con_tycons</span>
<a name="line-51"></a>        <span class='hs-comment'>-- NB: we do *not* call isProductTyCon because that checks</span>
<a name="line-52"></a>	<span class='hs-comment'>--     for vanilla-ness of data constructors; and that depends</span>
<a name="line-53"></a>	<span class='hs-comment'>--     on empty existential type variables; and that is figured</span>
<a name="line-54"></a>	<span class='hs-comment'>--     out by tcResultType; which uses tcMatchTy; which uses</span>
<a name="line-55"></a>	<span class='hs-comment'>--     coreView; which calls coreExpandTyCon_maybe; which uses</span>
<a name="line-56"></a>	<span class='hs-comment'>--     the recursiveness of the TyCon.  Result... a black hole.</span>
<a name="line-57"></a>	<span class='hs-comment'>-- YUK YUK YUK</span>
<a name="line-58"></a>
<a name="line-59"></a>        <span class='hs-comment'>--------------- Newtypes ----------------------</span>
<a name="line-60"></a>    <span class='hs-varid'>nt_loop_breakers</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNameSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>findLoopBreakers</span> <span class='hs-varid'>nt_edges</span><span class='hs-layout'>)</span>
<a name="line-61"></a>    <span class='hs-varid'>is_rec_nt</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConName</span> <span class='hs-varid'>tc</span>  <span class='hs-varop'>`elemNameSet`</span> <span class='hs-varid'>nt_loop_breakers</span>
<a name="line-62"></a>        <span class='hs-comment'>-- is_rec_nt is a locally-used helper function</span>
<a name="line-63"></a>
<a name="line-64"></a>    <span class='hs-varid'>nt_edges</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-varid'>mk_nt_edges</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>new_tycons</span><span class='hs-keyglyph'>]</span>
<a name="line-65"></a>
<a name="line-66"></a>    <span class='hs-varid'>mk_nt_edges</span> <span class='hs-varid'>nt</span>      <span class='hs-comment'>-- Invariant: nt is a newtype</span>
<a name="line-67"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_nt_edges1</span> <span class='hs-varid'>nt</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConsOfType</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_tc_rhs</span> <span class='hs-varid'>nt</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-68"></a>                        <span class='hs-comment'>-- tyConsOfType looks through synonyms</span>
<a name="line-69"></a>
<a name="line-70"></a>    <span class='hs-varid'>mk_nt_edges1</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tc</span>
<a name="line-71"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>new_tycons</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>tc</span><span class='hs-keyglyph'>]</span>           <span class='hs-comment'>-- Loop</span>
<a name="line-72"></a>                <span class='hs-comment'>-- At this point we know that either it's a local *data* type,</span>
<a name="line-73"></a>                <span class='hs-comment'>-- or it's imported.  Either way, it can't form part of a newtype cycle</span>
<a name="line-74"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-75"></a>
<a name="line-76"></a>        <span class='hs-comment'>--------------- Product types ----------------------</span>
<a name="line-77"></a>    <span class='hs-varid'>prod_loop_breakers</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNameSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>findLoopBreakers</span> <span class='hs-varid'>prod_edges</span><span class='hs-layout'>)</span>
<a name="line-78"></a>
<a name="line-79"></a>    <span class='hs-varid'>prod_edges</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>mk_prod_edges</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>prod_tycons</span><span class='hs-keyglyph'>]</span>
<a name="line-80"></a>
<a name="line-81"></a>    <span class='hs-varid'>mk_prod_edges</span> <span class='hs-varid'>tc</span>    <span class='hs-comment'>-- Invariant: tc is a product tycon</span>
<a name="line-82"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_prod_edges1</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConOrigArgTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-83"></a>
<a name="line-84"></a>    <span class='hs-varid'>mk_prod_edges1</span> <span class='hs-varid'>ptc</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_prod_edges2</span> <span class='hs-varid'>ptc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConsOfType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-85"></a>
<a name="line-86"></a>    <span class='hs-varid'>mk_prod_edges2</span> <span class='hs-varid'>ptc</span> <span class='hs-varid'>tc</span>
<a name="line-87"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>prod_tycons</span>   <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>tc</span><span class='hs-keyglyph'>]</span>                <span class='hs-comment'>-- Local product</span>
<a name="line-88"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>new_tycons</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>is_rec_nt</span> <span class='hs-varid'>tc</span>     <span class='hs-comment'>-- Local newtype</span>
<a name="line-89"></a>                                    <span class='hs-keyword'>then</span> <span class='hs-conid'>[]</span>
<a name="line-90"></a>                                    <span class='hs-keyword'>else</span> <span class='hs-varid'>mk_prod_edges1</span> <span class='hs-varid'>ptc</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_tc_rhs</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-91"></a>                <span class='hs-comment'>-- At this point we know that either it's a local non-product data type,</span>
<a name="line-92"></a>                <span class='hs-comment'>-- or it's imported.  Either way, it can't form part of a cycle</span>
<a name="line-93"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-94"></a>
<a name="line-95"></a><a name="new_tc_rhs"></a><span class='hs-definition'>new_tc_rhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-96"></a><span class='hs-definition'>new_tc_rhs</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-layout'>(</span><span class='hs-varid'>newTyConRhs</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Ignore the type variables</span>
<a name="line-97"></a>
<a name="line-98"></a><a name="getTyCon"></a><span class='hs-definition'>getTyCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyThing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>TyCon</span>
<a name="line-99"></a><span class='hs-definition'>getTyCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>ATyCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tc</span>
<a name="line-100"></a><span class='hs-definition'>getTyCon</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-101"></a>
<a name="line-102"></a><a name="findLoopBreakers"></a><span class='hs-definition'>findLoopBreakers</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>TyCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCon</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span>
<a name="line-103"></a><span class='hs-comment'>-- Finds a set of tycons that cut all loops</span>
<a name="line-104"></a><span class='hs-definition'>findLoopBreakers</span> <span class='hs-varid'>deps</span>
<a name="line-105"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span><span class='hs-varid'>ds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span><span class='hs-varid'>ds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>deps</span><span class='hs-keyglyph'>]</span>
<a name="line-106"></a>  <span class='hs-keyword'>where</span>
<a name="line-107"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>edges</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>name</span>
<a name="line-108"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CyclicSCC</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>edges'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>stronglyConnCompFromEdgedVerticesR</span> <span class='hs-varid'>edges</span><span class='hs-layout'>,</span>
<a name="line-109"></a>                 <span class='hs-varid'>name</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConName</span> <span class='hs-varid'>tc</span> <span class='hs-conop'>:</span> <span class='hs-varid'>go</span> <span class='hs-varid'>edges'</span><span class='hs-keyglyph'>]</span>
</pre>\end{code}


%************************************************************************
%*                                                                      *
                  Promotion calculation
%*                                                                      *
%************************************************************************

See Note [Checking whether a group is promotable]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We only want to promote a TyCon if all its data constructors
are promotable; it'd be very odd to promote some but not others.

But the data constructors may mention this or other TyCons.

So we treat the recursive uses as all OK (ie promotable) and
do one pass to check that each TyCon is promotable.

Currently type synonyms are not promotable, though that
could change.

\begin{code}
<pre><a name="line-1"></a><a name="isPromotableTyCon"></a><span class='hs-definition'>isPromotableTyCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NameSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2"></a><span class='hs-definition'>isPromotableTyCon</span> <span class='hs-varid'>rec_tycons</span> <span class='hs-varid'>tc</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>isAlgTyCon</span> <span class='hs-varid'>tc</span>    <span class='hs-comment'>-- Only algebraic; not even synonyms</span>
<a name="line-4"></a>                     <span class='hs-comment'>-- (we could reconsider the latter)</span>
<a name="line-5"></a>  <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>ok_kind</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConKind</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-6"></a>  <span class='hs-varop'>&amp;&amp;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>algTyConRhs</span> <span class='hs-varid'>tc</span> <span class='hs-keyword'>of</span> 
<a name="line-7"></a>       <span class='hs-conid'>DataTyCon</span> <span class='hs-layout'>{</span> <span class='hs-varid'>data_cons</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cs</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>all</span> <span class='hs-varid'>ok_con</span> <span class='hs-varid'>cs</span> 
<a name="line-8"></a>       <span class='hs-conid'>NewTyCon</span> <span class='hs-layout'>{</span> <span class='hs-varid'>data_con</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c</span> <span class='hs-layout'>}</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ok_con</span> <span class='hs-varid'>c</span>
<a name="line-9"></a>       <span class='hs-conid'>AbstractTyCon</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-10"></a>       <span class='hs-conid'>DataFamilyTyCon</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-11"></a>
<a name="line-12"></a>  <span class='hs-keyword'>where</span>
<a name="line-13"></a>    <span class='hs-varid'>ok_kind</span> <span class='hs-varid'>kind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>isLiftedTypeKind</span> <span class='hs-varid'>args</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isLiftedTypeKind</span> <span class='hs-varid'>res</span>
<a name="line-14"></a>            <span class='hs-keyword'>where</span>  <span class='hs-comment'>-- Checks for * -&gt; ... -&gt; * -&gt; *</span>
<a name="line-15"></a>              <span class='hs-layout'>(</span><span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitKindFunTys</span> <span class='hs-varid'>kind</span>
<a name="line-16"></a>
<a name="line-17"></a>    <span class='hs-comment'>-- See Note [Promoted data constructors] in TyCon</span>
<a name="line-18"></a>    <span class='hs-varid'>ok_con</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varid'>isLiftedTypeKind</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tyVarKind</span><span class='hs-layout'>)</span> <span class='hs-varid'>ex_tvs</span>
<a name="line-19"></a>              <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>eq_spec</span>   <span class='hs-comment'>-- No constraints</span>
<a name="line-20"></a>              <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span>
<a name="line-21"></a>              <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varid'>isPromotableType</span> <span class='hs-varid'>rec_tycons</span><span class='hs-layout'>)</span> <span class='hs-varid'>orig_arg_tys</span>
<a name="line-22"></a>       <span class='hs-keyword'>where</span>
<a name="line-23"></a>         <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>ex_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_spec</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>orig_arg_tys</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConFullSig</span> <span class='hs-varid'>con</span>
<a name="line-24"></a>
<a name="line-25"></a>
<a name="line-26"></a><a name="isPromotableType"></a><span class='hs-definition'>isPromotableType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NameSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-27"></a><span class='hs-comment'>-- Must line up with DataCon.promoteType</span>
<a name="line-28"></a><span class='hs-comment'>-- But the function lives here because we must treat the</span>
<a name="line-29"></a><span class='hs-comment'>-- *recursive* tycons as promotable</span>
<a name="line-30"></a><span class='hs-definition'>isPromotableType</span> <span class='hs-varid'>rec_tcs</span> <span class='hs-varid'>con_arg_ty</span>
<a name="line-31"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>con_arg_ty</span>
<a name="line-32"></a>  <span class='hs-keyword'>where</span>
<a name="line-33"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>tys</span> <span class='hs-varop'>`lengthIs`</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span> 
<a name="line-34"></a>                         <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>`elemNameSet`</span> <span class='hs-varid'>rec_tcs</span> 
<a name="line-35"></a>                             <span class='hs-varop'>||</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>promotableTyCon_maybe</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-36"></a>                         <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>all</span> <span class='hs-varid'>go</span> <span class='hs-varid'>tys</span>
<a name="line-37"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> 	 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>res</span>
<a name="line-38"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>    	 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-39"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>               	 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
</pre>\end{code}

%************************************************************************
%*                                                                      *
        Role annotations
%*                                                                      *
%************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="RoleAnnots"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>RoleAnnots</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NameEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>LRoleAnnotDecl</span> <span class='hs-conid'>Name</span><span class='hs-layout'>)</span>
<a name="line-2"></a>
<a name="line-3"></a><a name="extractRoleAnnots"></a><span class='hs-definition'>extractRoleAnnots</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyClGroup</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleAnnots</span>
<a name="line-4"></a><span class='hs-definition'>extractRoleAnnots</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyClGroup</span> <span class='hs-layout'>{</span> <span class='hs-varid'>group_roles</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>roles</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-5"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNameEnv</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>tycon</span><span class='hs-layout'>,</span> <span class='hs-varid'>role_annot</span><span class='hs-layout'>)</span>
<a name="line-6"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>role_annot</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>RoleAnnotDecl</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tycon</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>roles</span> <span class='hs-keyglyph'>]</span>
<a name="line-7"></a>
<a name="line-8"></a><a name="emptyRoleAnnots"></a><span class='hs-definition'>emptyRoleAnnots</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RoleAnnots</span>
<a name="line-9"></a><span class='hs-definition'>emptyRoleAnnots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyNameEnv</span>
<a name="line-10"></a>
<a name="line-11"></a><a name="lookupRoleAnnots"></a><span class='hs-definition'>lookupRoleAnnots</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RoleAnnots</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>LRoleAnnotDecl</span> <span class='hs-conid'>Name</span><span class='hs-layout'>)</span>
<a name="line-12"></a><span class='hs-definition'>lookupRoleAnnots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupNameEnv</span>
<a name="line-13"></a>
</pre>\end{code}

%************************************************************************
%*                                                                      *
        Role inference
%*                                                                      *
%************************************************************************

Note [Role inference]
~~~~~~~~~~~~~~~~~~~~~
The role inference algorithm datatype definitions to infer the roles on the
parameters. Although these roles are stored in the tycons, we can perform this
algorithm on the built tycons, as long as we don't peek at an as-yet-unknown
roles field! Ah, the magic of laziness.

First, we choose appropriate initial roles. For families and classes, roles
(including initial roles) are N. For datatypes, we start with the role in the
role annotation (if any), or otherwise use Phantom. This is done in
initialRoleEnv1.

The function irGroup then propagates role information until it reaches a
fixpoint, preferring N over (R or P) and R over P. To aid in this, we have a
monad RoleM, which is a combination reader and state monad. In its state are
the current RoleEnv, which gets updated by role propagation, and an update
bit, which we use to know whether or not we've reached the fixpoint. The
environment of RoleM contains the tycon whose parameters we are inferring, and
a VarEnv from parameters to their positions, so we can update the RoleEnv.
Between tycons, this reader information is missing; it is added by
addRoleInferenceInfo.

There are two kinds of tycons to consider: algebraic ones (excluding classes)
and type synonyms. (Remember, families don't participate -- all their parameters
are N.) An algebraic tycon processes each of its datacons, in turn. Note that
a datacon's universally quantified parameters might be different from the parent
tycon's parameters, so we use the datacon's univ parameters in the mapping from
vars to positions. Note also that we don't want to infer roles for existentials
(they're all at N, too), so we put them in the set of local variables. As an
optimisation, we skip any tycons whose roles are already all Nominal, as there
nowhere else for them to go. For synonyms, we just analyse their right-hand sides.

irType walks through a type, looking for uses of a variable of interest and
propagating role information. Because anything used under a phantom position
is at phantom and anything used under a nominal position is at nominal, the
irType function can assume that anything it sees is at representational. (The
other possibilities are pruned when they're encountered.)

The rest of the code is just plumbing.

How do we know that this algorithm is correct? It should meet the following
specification:

Let Z be a role context -- a mapping from variables to roles. The following
rules define the property (Z |- t : r), where t is a type and r is a role:

Z(a) = r'        r' <= r
------------------------- RCVar
Z |- a : r

---------- RCConst
Z |- T : r               -- T is a type constructor

Z |- t1 : r
Z |- t2 : N
-------------- RCApp
Z |- t1 t2 : r

forall i<=n. (r_i is R or N) implies Z |- t_i : r_i
roles(T) = r_1 .. r_n
---------------------------------------------------- RCDApp
Z |- T t_1 .. t_n : R

Z, a:N |- t : r
---------------------- RCAll
Z |- forall a:k.t : r


We also have the following rules:

For all datacon_i in type T, where a_1 .. a_n are universally quantified
and b_1 .. b_m are existentially quantified, and the arguments are t_1 .. t_p,
then if forall j<=p, a_1 : r_1 .. a_n : r_n, b_1 : N .. b_m : N |- t_j : R,
then roles(T) = r_1 .. r_n

roles(->) = R, R
roles(~#) = N, N

With -dcore-lint on, the output of this algorithm is checked in checkValidRoles,
called from checkValidTycon.

Note [Role-checking data constructor arguments]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider
  data T a where
    MkT :: Eq b => F a -> (a->a) -> T (G a)

Then we want to check the roles at which 'a' is used
in MkT's type.  We want to work on the user-written type,
so we need to take into account
  * the arguments:   (F a) and (a->a)
  * the context:     C a b
  * the result type: (G a)   -- this is in the eq_spec

\begin{code}
<pre><a name="line-1"></a><a name="RoleEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>RoleEnv</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NameEnv</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>        <span class='hs-comment'>-- from tycon names to roles</span>
<a name="line-2"></a>
<a name="line-3"></a><a name="inferRoles"></a><span class='hs-comment'>-- This, and any of the functions it calls, must *not* look at the roles</span>
<a name="line-4"></a><span class='hs-comment'>-- field of a tycon we are inferring roles about!</span>
<a name="line-5"></a><span class='hs-comment'>-- See Note [Role inference]</span>
<a name="line-6"></a><span class='hs-definition'>inferRoles</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleAnnots</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCon</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>
<a name="line-7"></a><span class='hs-definition'>inferRoles</span> <span class='hs-varid'>is_boot</span> <span class='hs-varid'>annots</span> <span class='hs-varid'>tycons</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>role_env</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>initialRoleEnv</span> <span class='hs-varid'>is_boot</span> <span class='hs-varid'>annots</span> <span class='hs-varid'>tycons</span>
<a name="line-9"></a>        <span class='hs-varid'>role_env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irGroup</span> <span class='hs-varid'>role_env</span> <span class='hs-varid'>tycons</span> <span class='hs-keyword'>in</span>
<a name="line-10"></a>    <span class='hs-keyglyph'>\</span><span class='hs-varid'>name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupNameEnv</span> <span class='hs-varid'>role_env'</span> <span class='hs-varid'>name</span> <span class='hs-keyword'>of</span>
<a name="line-11"></a>      <span class='hs-conid'>Just</span> <span class='hs-varid'>roles</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>roles</span>
<a name="line-12"></a>      <span class='hs-conid'>Nothing</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"inferRoles"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-13"></a>
<a name="line-14"></a><a name="initialRoleEnv"></a><span class='hs-definition'>initialRoleEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleAnnots</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCon</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleEnv</span>
<a name="line-15"></a><span class='hs-definition'>initialRoleEnv</span> <span class='hs-varid'>is_boot</span> <span class='hs-varid'>annots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendNameEnvList</span> <span class='hs-varid'>emptyNameEnv</span> <span class='hs-varop'>.</span>
<a name="line-16"></a>                                <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>initialRoleEnv1</span> <span class='hs-varid'>is_boot</span> <span class='hs-varid'>annots</span><span class='hs-layout'>)</span>
<a name="line-17"></a>
<a name="line-18"></a><a name="initialRoleEnv1"></a><span class='hs-definition'>initialRoleEnv1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleAnnots</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-19"></a><span class='hs-definition'>initialRoleEnv1</span> <span class='hs-varid'>is_boot</span> <span class='hs-varid'>annots_env</span> <span class='hs-varid'>tc</span>
<a name="line-20"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFamilyTyCon</span> <span class='hs-varid'>tc</span>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-varid'>tyvars</span><span class='hs-layout'>)</span>
<a name="line-21"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isAlgTyCon</span> <span class='hs-varid'>tc</span>         <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>default_roles</span><span class='hs-layout'>)</span>
<a name="line-22"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTypeSynonymTyCon</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>default_roles</span><span class='hs-layout'>)</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"initialRoleEnv1"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-24"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>name</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConName</span> <span class='hs-varid'>tc</span>
<a name="line-25"></a>        <span class='hs-varid'>tyvars</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConTyVars</span> <span class='hs-varid'>tc</span>
<a name="line-26"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>kvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>span</span> <span class='hs-varid'>isKindVar</span> <span class='hs-varid'>tyvars</span>
<a name="line-27"></a>
<a name="line-28"></a>          <span class='hs-comment'>-- if the number of annotations in the role annotation decl</span>
<a name="line-29"></a>          <span class='hs-comment'>-- is wrong, just ignore it. We check this in the validity check.</span>
<a name="line-30"></a>        <span class='hs-varid'>role_annots</span>
<a name="line-31"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupNameEnv</span> <span class='hs-varid'>annots_env</span> <span class='hs-varid'>name</span> <span class='hs-keyword'>of</span>
<a name="line-32"></a>              <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>L</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>RoleAnnotDecl</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>annots</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-33"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>annots</span> <span class='hs-varop'>`equalLength`</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>map</span> <span class='hs-varid'>unLoc</span> <span class='hs-varid'>annots</span>
<a name="line-34"></a>              <span class='hs-keyword'>_</span>                            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs</span>
<a name="line-35"></a>        <span class='hs-varid'>default_roles</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-varid'>kvs</span> <span class='hs-varop'>++</span>
<a name="line-36"></a>                        <span class='hs-varid'>zipWith</span> <span class='hs-varid'>orElse</span> <span class='hs-varid'>role_annots</span> <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-varid'>default_role</span><span class='hs-layout'>)</span>
<a name="line-37"></a>
<a name="line-38"></a>        <span class='hs-varid'>default_role</span>
<a name="line-39"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isClassTyCon</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nominal</span>
<a name="line-40"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_boot</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Representational</span>
<a name="line-41"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Phantom</span>
<a name="line-42"></a>
<a name="line-43"></a><a name="irGroup"></a><span class='hs-definition'>irGroup</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RoleEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCon</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleEnv</span>
<a name="line-44"></a><span class='hs-definition'>irGroup</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tcs</span>
<a name="line-45"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>update</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runRoleM</span> <span class='hs-varid'>env</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>irTyCon</span> <span class='hs-varid'>tcs</span> <span class='hs-keyword'>in</span>
<a name="line-46"></a>    <span class='hs-keyword'>if</span> <span class='hs-varid'>update</span>
<a name="line-47"></a>    <span class='hs-keyword'>then</span> <span class='hs-varid'>irGroup</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>tcs</span>
<a name="line-48"></a>    <span class='hs-keyword'>else</span> <span class='hs-varid'>env'</span>
<a name="line-49"></a>
<a name="line-50"></a><a name="irTyCon"></a><span class='hs-definition'>irTyCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-conid'>()</span>
<a name="line-51"></a><span class='hs-definition'>irTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-52"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isAlgTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-53"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>old_roles</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupRoles</span> <span class='hs-varid'>tc</span>
<a name="line-54"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-varid'>old_roles</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>  <span class='hs-comment'>-- also catches data families,</span>
<a name="line-55"></a>                                                <span class='hs-comment'>-- which don't want or need role inference</span>
<a name="line-56"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>whenIsJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConClass_maybe</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>irClass</span> <span class='hs-varid'>tc_name</span><span class='hs-layout'>)</span>
<a name="line-57"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>addRoleInferenceInfo</span> <span class='hs-varid'>tc_name</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConTyVars</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-58"></a>         <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>irType</span> <span class='hs-varid'>emptyVarSet</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConStupidTheta</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See #8958</span>
<a name="line-59"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>irDataCon</span> <span class='hs-varid'>tc_name</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>visibleDataCons</span> <span class='hs-varop'>$</span> <span class='hs-varid'>algTyConRhs</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-60"></a>
<a name="line-61"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>SynonymTyCon</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>synTyConRhs_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-62"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addRoleInferenceInfo</span> <span class='hs-varid'>tc_name</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConTyVars</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-63"></a>    <span class='hs-varid'>irType</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>ty</span>
<a name="line-64"></a>
<a name="line-65"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-66"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-67"></a>
<a name="line-68"></a>  <span class='hs-keyword'>where</span>
<a name="line-69"></a>    <span class='hs-varid'>tc_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConName</span> <span class='hs-varid'>tc</span>
<a name="line-70"></a>
<a name="line-71"></a><a name="irClass"></a><span class='hs-comment'>-- any type variable used in an associated type must be Nominal</span>
<a name="line-72"></a><span class='hs-definition'>irClass</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-conid'>()</span>
<a name="line-73"></a><span class='hs-definition'>irClass</span> <span class='hs-varid'>tc_name</span> <span class='hs-varid'>cls</span>
<a name="line-74"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addRoleInferenceInfo</span> <span class='hs-varid'>tc_name</span> <span class='hs-varid'>cls_tvs</span> <span class='hs-varop'>$</span>
<a name="line-75"></a>    <span class='hs-varid'>mapM_</span> <span class='hs-varid'>ir_at</span> <span class='hs-layout'>(</span><span class='hs-varid'>classATs</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span>
<a name="line-76"></a>  <span class='hs-keyword'>where</span>
<a name="line-77"></a>    <span class='hs-varid'>cls_tvs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classTyVars</span> <span class='hs-varid'>cls</span>
<a name="line-78"></a>    <span class='hs-varid'>cls_tv_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>cls_tvs</span>
<a name="line-79"></a>
<a name="line-80"></a>    <span class='hs-varid'>ir_at</span> <span class='hs-varid'>at_tc</span>
<a name="line-81"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>updateRole</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>varSetElems</span> <span class='hs-varid'>nvars</span><span class='hs-layout'>)</span>
<a name="line-82"></a>      <span class='hs-keyword'>where</span> <span class='hs-varid'>nvars</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVarSet</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tyConTyVars</span> <span class='hs-varid'>at_tc</span><span class='hs-layout'>)</span> <span class='hs-varop'>`intersectVarSet`</span> <span class='hs-varid'>cls_tv_set</span>
<a name="line-83"></a>
<a name="line-84"></a><a name="irDataCon"></a><span class='hs-comment'>-- See Note [Role inference]</span>
<a name="line-85"></a><span class='hs-definition'>irDataCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-conid'>()</span>
<a name="line-86"></a><span class='hs-definition'>irDataCon</span> <span class='hs-varid'>tc_name</span> <span class='hs-varid'>datacon</span>
<a name="line-87"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addRoleInferenceInfo</span> <span class='hs-varid'>tc_name</span> <span class='hs-varid'>univ_tvs</span> <span class='hs-varop'>$</span>
<a name="line-88"></a>    <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>irType</span> <span class='hs-varid'>ex_var_set</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqSpecPreds</span> <span class='hs-varid'>eq_spec</span> <span class='hs-varop'>++</span> <span class='hs-varid'>theta</span> <span class='hs-varop'>++</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span>
<a name="line-89"></a>      <span class='hs-comment'>-- See Note [Role-checking data constructor arguments] </span>
<a name="line-90"></a>  <span class='hs-keyword'>where</span>
<a name="line-91"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>univ_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ex_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_spec</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>,</span> <span class='hs-sel'>_res_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConFullSig</span> <span class='hs-varid'>datacon</span>
<a name="line-92"></a>    <span class='hs-varid'>ex_var_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>ex_tvs</span>
<a name="line-93"></a>
<a name="line-94"></a><a name="irType"></a><span class='hs-definition'>irType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-conid'>()</span>
<a name="line-95"></a><span class='hs-definition'>irType</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span>
<a name="line-96"></a>  <span class='hs-keyword'>where</span>
<a name="line-97"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>lcls</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>lcls</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-98"></a>                           <span class='hs-varid'>updateRole</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>tv</span>
<a name="line-99"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>lcls</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>lcls</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>mark_nominal</span> <span class='hs-varid'>lcls</span> <span class='hs-varid'>t2</span>
<a name="line-100"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>lcls</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-101"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>roles</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupRolesX</span> <span class='hs-varid'>tc</span>
<a name="line-102"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>zipWithM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>go_app</span> <span class='hs-varid'>lcls</span><span class='hs-layout'>)</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>}</span>
<a name="line-103"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>lcls</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>lcls</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>lcls</span> <span class='hs-varid'>t2</span>
<a name="line-104"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>lcls</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendVarSet</span> <span class='hs-varid'>lcls</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span>
<a name="line-105"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>    <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-106"></a>
<a name="line-107"></a>    <span class='hs-varid'>go_app</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Phantom</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>                 <span class='hs-comment'>-- nothing to do here</span>
<a name="line-108"></a>    <span class='hs-varid'>go_app</span> <span class='hs-varid'>lcls</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mark_nominal</span> <span class='hs-varid'>lcls</span> <span class='hs-varid'>ty</span>  <span class='hs-comment'>-- all vars below here are N</span>
<a name="line-109"></a>    <span class='hs-varid'>go_app</span> <span class='hs-varid'>lcls</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>lcls</span> <span class='hs-varid'>ty</span>
<a name="line-110"></a>
<a name="line-111"></a>    <span class='hs-varid'>mark_nominal</span> <span class='hs-varid'>lcls</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>nvars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>lcls</span> <span class='hs-keyword'>in</span>
<a name="line-112"></a>                           <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>updateRole</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>varSetElems</span> <span class='hs-varid'>nvars</span><span class='hs-layout'>)</span>
<a name="line-113"></a>
<a name="line-114"></a><a name="lookupRolesX"></a><span class='hs-comment'>-- like lookupRoles, but with Nominal tags at the end for oversaturated TyConApps</span>
<a name="line-115"></a><span class='hs-definition'>lookupRolesX</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>
<a name="line-116"></a><span class='hs-definition'>lookupRolesX</span> <span class='hs-varid'>tc</span>
<a name="line-117"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>roles</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupRoles</span> <span class='hs-varid'>tc</span>
<a name="line-118"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>roles</span> <span class='hs-varop'>++</span> <span class='hs-varid'>repeat</span> <span class='hs-conid'>Nominal</span> <span class='hs-layout'>}</span>
<a name="line-119"></a>
<a name="line-120"></a><a name="lookupRoles"></a><span class='hs-comment'>-- gets the roles either from the environment or the tycon</span>
<a name="line-121"></a><span class='hs-definition'>lookupRoles</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>
<a name="line-122"></a><span class='hs-definition'>lookupRoles</span> <span class='hs-varid'>tc</span>
<a name="line-123"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRoleEnv</span>
<a name="line-124"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupNameEnv</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-125"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>roles</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>roles</span>
<a name="line-126"></a>           <span class='hs-conid'>Nothing</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tyConRoles</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>}</span>
<a name="line-127"></a>
<a name="line-128"></a><a name="updateRole"></a><span class='hs-comment'>-- tries to update a role; won't ever update a role "downwards"</span>
<a name="line-129"></a><span class='hs-definition'>updateRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Role</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-conid'>()</span>
<a name="line-130"></a><span class='hs-definition'>updateRole</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tv</span>
<a name="line-131"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>var_ns</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getVarNs</span>
<a name="line-132"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>var_ns</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>of</span>
<a name="line-133"></a>       <span class='hs-layout'>{</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"updateRole"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-134"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>n</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-135"></a>       <span class='hs-layout'>{</span> <span class='hs-varid'>name</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTyConName</span>
<a name="line-136"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>updateRoleEnv</span> <span class='hs-varid'>name</span> <span class='hs-varid'>n</span> <span class='hs-varid'>role</span> <span class='hs-layout'>}</span><span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-137"></a>
<a name="line-138"></a><a name="RoleInferenceState"></a><span class='hs-comment'>-- the state in the RoleM monad</span>
<a name="line-139"></a><a name="RoleInferenceState"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>RoleInferenceState</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RIS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>role_env</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RoleEnv</span>
<a name="line-140"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>update</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-layout'>}</span>
<a name="line-141"></a>
<a name="line-142"></a><a name="VarPositions"></a><span class='hs-comment'>-- the environment in the RoleM monad</span>
<a name="line-143"></a><a name="VarPositions"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>VarPositions</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>Int</span>
<a name="line-144"></a><a name="RoleInferenceInfo"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>RoleInferenceInfo</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RII</span> <span class='hs-layout'>{</span> <span class='hs-varid'>var_ns</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarPositions</span>
<a name="line-145"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>name</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-layout'>}</span>
<a name="line-146"></a>
<a name="line-147"></a><a name="RoleM"></a><span class='hs-comment'>-- See [Role inference]</span>
<a name="line-148"></a><a name="RoleM"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>RoleM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RM</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unRM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>RoleInferenceInfo</span>
<a name="line-149"></a>                            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleInferenceState</span>
<a name="line-150"></a>                            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>RoleInferenceState</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-151"></a>
<a name="line-152"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-conid'>RoleM</span> <span class='hs-keyword'>where</span>
<a name="line-153"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftM</span>
<a name="line-154"></a>
<a name="line-155"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>RoleM</span> <span class='hs-keyword'>where</span>
<a name="line-156"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span>
<a name="line-157"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ap</span>
<a name="line-158"></a>
<a name="line-159"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-conid'>RoleM</span> <span class='hs-keyword'>where</span>
<a name="line-160"></a>  <span class='hs-varid'>return</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-varid'>state</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>state</span><span class='hs-layout'>)</span>
<a name="line-161"></a>  <span class='hs-varid'>a</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>f</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>m_info</span> <span class='hs-varid'>state</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>state'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unRM</span> <span class='hs-varid'>a</span> <span class='hs-varid'>m_info</span> <span class='hs-varid'>state</span> <span class='hs-keyword'>in</span>
<a name="line-162"></a>                                   <span class='hs-varid'>unRM</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a'</span><span class='hs-layout'>)</span> <span class='hs-varid'>m_info</span> <span class='hs-varid'>state'</span>
<a name="line-163"></a>
<a name="line-164"></a><a name="runRoleM"></a><span class='hs-definition'>runRoleM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RoleEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>RoleEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span>
<a name="line-165"></a><span class='hs-definition'>runRoleM</span> <span class='hs-varid'>env</span> <span class='hs-varid'>thing</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>update</span><span class='hs-layout'>)</span>
<a name="line-166"></a>  <span class='hs-keyword'>where</span> <span class='hs-conid'>RIS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>role_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>update</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>update</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unRM</span> <span class='hs-varid'>thing</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>state</span> 
<a name="line-167"></a>        <span class='hs-varid'>state</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RIS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>role_env</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>update</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-168"></a>
<a name="line-169"></a><a name="addRoleInferenceInfo"></a><span class='hs-definition'>addRoleInferenceInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-varid'>a</span>
<a name="line-170"></a><span class='hs-definition'>addRoleInferenceInfo</span> <span class='hs-varid'>name</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>thing</span>
<a name="line-171"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-sel'>_nothing</span> <span class='hs-varid'>state</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isNothing</span> <span class='hs-sel'>_nothing</span> <span class='hs-layout'>)</span>
<a name="line-172"></a>                            <span class='hs-varid'>unRM</span> <span class='hs-varid'>thing</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>info</span><span class='hs-layout'>)</span> <span class='hs-varid'>state</span>
<a name="line-173"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RII</span> <span class='hs-layout'>{</span> <span class='hs-varid'>var_ns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>zip</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>name</span> <span class='hs-layout'>}</span>
<a name="line-174"></a>
<a name="line-175"></a><a name="getRoleEnv"></a><span class='hs-definition'>getRoleEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RoleM</span> <span class='hs-conid'>RoleEnv</span>
<a name="line-176"></a><span class='hs-definition'>getRoleEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-varid'>state</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>RIS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>role_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>state</span><span class='hs-layout'>)</span>
<a name="line-177"></a>
<a name="line-178"></a><a name="getVarNs"></a><span class='hs-definition'>getVarNs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RoleM</span> <span class='hs-conid'>VarPositions</span>
<a name="line-179"></a><span class='hs-definition'>getVarNs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>m_info</span> <span class='hs-varid'>state</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-180"></a>                <span class='hs-keyword'>case</span> <span class='hs-varid'>m_info</span> <span class='hs-keyword'>of</span>
<a name="line-181"></a>                  <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"getVarNs"</span>
<a name="line-182"></a>                  <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>RII</span> <span class='hs-layout'>{</span> <span class='hs-varid'>var_ns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>var_ns</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>var_ns</span><span class='hs-layout'>,</span> <span class='hs-varid'>state</span><span class='hs-layout'>)</span>
<a name="line-183"></a>
<a name="line-184"></a><a name="getTyConName"></a><span class='hs-definition'>getTyConName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RoleM</span> <span class='hs-conid'>Name</span>
<a name="line-185"></a><span class='hs-definition'>getTyConName</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>m_info</span> <span class='hs-varid'>state</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-186"></a>                    <span class='hs-keyword'>case</span> <span class='hs-varid'>m_info</span> <span class='hs-keyword'>of</span>
<a name="line-187"></a>                      <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"getTyConName"</span>
<a name="line-188"></a>                      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>RII</span> <span class='hs-layout'>{</span> <span class='hs-varid'>name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>name</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>state</span><span class='hs-layout'>)</span>
<a name="line-189"></a>
<a name="line-190"></a>
<a name="line-191"></a><a name="updateRoleEnv"></a><span class='hs-definition'>updateRoleEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Role</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RoleM</span> <span class='hs-conid'>()</span>
<a name="line-192"></a><span class='hs-definition'>updateRoleEnv</span> <span class='hs-varid'>name</span> <span class='hs-varid'>n</span> <span class='hs-varid'>role</span>
<a name="line-193"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-varid'>state</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>RIS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>role_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>role_env</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>()</span><span class='hs-layout'>,</span>
<a name="line-194"></a>         <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupNameEnv</span> <span class='hs-varid'>role_env</span> <span class='hs-varid'>name</span> <span class='hs-keyword'>of</span>
<a name="line-195"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"updateRoleEnv"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-196"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>roles</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>before</span><span class='hs-layout'>,</span> <span class='hs-varid'>old_role</span> <span class='hs-conop'>:</span> <span class='hs-varid'>after</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAt</span> <span class='hs-varid'>n</span> <span class='hs-varid'>roles</span> <span class='hs-keyword'>in</span>
<a name="line-197"></a>                         <span class='hs-keyword'>if</span> <span class='hs-varid'>role</span> <span class='hs-varop'>`ltRole`</span> <span class='hs-varid'>old_role</span>
<a name="line-198"></a>                         <span class='hs-keyword'>then</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>roles'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>before</span> <span class='hs-varop'>++</span> <span class='hs-varid'>role</span> <span class='hs-conop'>:</span> <span class='hs-varid'>after</span>
<a name="line-199"></a>                                  <span class='hs-varid'>role_env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendNameEnv</span> <span class='hs-varid'>role_env</span> <span class='hs-varid'>name</span> <span class='hs-varid'>roles'</span> <span class='hs-keyword'>in</span>
<a name="line-200"></a>                              <span class='hs-conid'>RIS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>role_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>role_env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>update</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-201"></a>                         <span class='hs-keyword'>else</span> <span class='hs-varid'>state</span> <span class='hs-layout'>)</span>
<a name="line-202"></a>
</pre>\end{code}
</body>
</html>
